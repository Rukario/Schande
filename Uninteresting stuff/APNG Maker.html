<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="white">
<meta name="format-detection" content="telephone=no">
<meta name="viewport" content="width=675, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"/>
<style>

:root {
  color-scheme: light dark;

  --color-bg: Canvas;
  --color-bg: #2d0710;

  --color-fg: CanvasText;
  --color-fg: #f45;
}

body {
  caret-color: #ff8228;
  font-family: courier;
  font-size: 14px;
  -webkit-text-size-adjust: none;
}

[contenteditable]:focus, input:focus {
  outline: none;
}

#getfps:focus {
  outline: none;
}

a {
  color: #ff9449;

  ::visited {
    color: #ffc66d;
  }
}

.frame {
  display: inline-block;
  vertical-align: top;
}

input {
  &[type='text'] {
    cursor: text;
    height: 1em;
  }

  &[type='file'] {
    display: none;
  }

  &[type='color'] {
    width: 0;
    height: 0;
    padding: 0;
    margin: 0;
    border: 0;
    opacity: 0;
  }

  &[type='range'] {
    position:relative;
    top:6px;
    -webkit-appearance: none;
    appearance: none;
    height: 4px;
    background: #066;
    outline: none;
    border:8px solid transparent;
    background-clip: padding-box;
    box-shadow: inset 0 0 0 4px #066;
    opacity: 0.7;
    -webkit-transition: .2s;
    transition: opacity .2s;
    cursor: pointer;

    &::hover {
      opacity: 1;
    }

    &::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 12px;
      border-radius: 0px;
      height: 12px;
      background: #4bb;
      border:none;
    }

    &::-moz-range-thumb {
      border-radius: 0px;
      width: 12px;
      height: 12px;
      background: #4bb;
      border:none;
    }
  }

  &::placeholder {
    color: #3cb;
  }
}

ul {
  display: inline-grid;
  grid-template-rows: repeat(20, 1fr);
  grid-auto-flow: column;
  grid-column-gap: 10px;
  list-style: none;
  padding: 0;
  margin: 0;
}



.previous, .reverse, .inverse, .next, .butt {
  position: relative;
  display: inline-block;
  border-radius: 0px;
  padding: 4px 11px;
  margin: 4px;
  line-height: 1;
  font-size: 12px;
}

.previous, .reverse, .inverse, .next {
  cursor: pointer;
  font-family: sans-serif;
}

.next {
  background-color: #066;
  color: #6fe;
  border: 1px solid #033;
}

.previous {
  background-color: #4bb;
  color: #133;
  border: 1px solid #033;
}

.reverse {
  background-color: #428;
  color: #d9f;
  border: 1px solid #214;
}

.inverse {
  background-color: #d9f;
  color: #428;
  border: 1px solid #214;
}

#previewer {
  position: fixed;
  right: 0;
  top: 0;
  z-index: 1;
  pointer-events: none;

  &.makefit {
    max-height: 100vh;
    max-width: 100vw;
  }
}

.tooltip {
  display: none;
  position: absolute;
  margin-top: 37px;
  white-space: initial;
  background-color: inherit;
  padding: 2px 8px;
  font-family: sans-serif;
  font-size: 12px;
  max-width: calc(100% - 36px);
  line-height: calc(1em + 2px);
  z-index: 9999999;
  left: 0px;
  top: 0px;
  right: initial;
}

.menu {
  color: #9b859d;
  background-color: #110c13;
}

.exitmenu {
  color: var(--color-fg);
  background-color: var(--color-bg);
}

.cursor_tooltip {
  position: absolute;
  left: 0px;
  top: 0px;
  right: initial;
  display: none;
}

.backtip {
  cursor: default;
  position: relative;
  display: inline-block;
  font-size: 12px;
  padding: 5px 12px;
  top: -1px;
  background: inherit;
  z-index: 1;

  &::before {
    content: '';
    position: absolute;
    left: 0;
    top: 0;
    border: 1px solid #ffffff;
    background: transparent;
    mix-blend-mode: overlay;
    width: calc(100% - 2px);
    height: calc(100% - 2px);
    pointer-events: none;
  }
}

.local_tooltip {
  z-index: 2;
  display: inline-block;
  color: inherit;
  cursor: default;
  padding: 6px 11px 4px;
  margin: 1px;
}

.label {
  top: -11px;
  display: table;
  line-height: 1;
  font-size: 12px;
}

.cell {
  width: 352px;
  vertical-align: text-top;
  font-size: 14px;
  margin: 0 4px;

  &::before {
    border: 2px solid rgba(255, 255, 255, 0.75);
    width: calc(100% - 4px);
    height: calc(100% - 4px);
  }
}

.stdout {
  white-space: pre;
  line-height: calc(1em + 2px);
  color: #9b859d;
  background-color: #110c13;
  border: 2px solid #221926;
  display: inline-block;
  padding: 6px;
  margin-top: 12px;
}

.aczo {
  font-family: courier;
  font-size: 12px;
  border: none;
  border-top: 1px solid #033;
  border-bottom: 1px solid #033;
  margin: -4px 2px;
  bottom: 4px;
  padding: 8px 5px 9px;
  text-align: center;
  width: 34px;
  display: inline-block;

  clip-path: polygon(
14% 12%,
50% 0%,
86% 12%,
100% 68%,
82% 100%,
18% 100%,
0% 68%
);
}

.aczo28 {
  bottom: 5px;
  padding: 10px 7px 11px;
  width: 44px;
}

</style>
<script>
var isTouch = 'ontouchstart' in window;
var busyclick = false;
var mousepos = {
  x: 0,
  y: 0
};
var rubbermouse = {
  x: 0,
  y: 0
};

function getfontcolor(c, v){
  if(c[0] >= 'cc' && c[1] >= 'cc' && c[2] >= 'cc'){
    return ".exitmenu{background-color:#" + v + "; color:#586e75;}"
  } else if(c[0] >= "99" || c[1] >= "99" || c[2] >= "99"){
    return ".exitmenu{background-color:#" + v + "; color:#000;}"
  } else if(c[0] >= "20" && c[1] >= "10" && c[2] >= "10"){
    return ".exitmenu{background-color:#" + v + "; color:#93a1a1;}"
  } else if(c[0] >= "20" && c[1] >= "07" && c[2] >= "07"){/* red */
    return ".exitmenu{background-color:#" + v + "; color:#f45;}"
  } else {
    return ".exitmenu{background-color:#" + v + "; color:#fff;}"
  }
}

var sharp = [false, false];
if (window.location.href.includes('#')) {
  sharp[0] = window.location.href.split('#')[1];
}

if (sharp[0]) {
  if (sharp[0].endsWith('.css')) {
    const link = document.createElement('link');
    link.href = sharp[0];
    link.rel = 'stylesheet';
    document.getElementsByTagName('head')[0].appendChild(link);
    link.onerror = () => {
      sharp[1] = true;
    }
  } else {
    const s = document.createElement('style');
    s.innerHTML = getfontcolor(sharp[0].match(/.{1,2}/g), sharp[0]);
    document.getElementsByTagName('head')[0].appendChild(s);
  }
} else {
  const a = document.createElement('A');
  a.href = '#2d0710';
  a.click();
}



var FFdown = (e_) => {
  if (e_) {
    if (!isTouch || e_.touches.length === 1) {
      mousepos.x = isTouch ? e_.touches[0].clientX + window.visualViewport.offsetLeft: e_.x;
      mousepos.y = isTouch ? e_.touches[0].clientY + window.visualViewport.offsetTop: e_.y;
    }
  }

  const t = e_.target;
  const a = t.parentNode;
  const rect = t.getBoundingClientRect();
  if (t.tagName === 'CANVAS') {
    const ws = t.width/t.offsetWidth;
    const hs = t.height/t.offsetHeight;

    magic_wand([(mousepos.x - Math.ceil(rect.left)) * ws, (mousepos.y - Math.ceil(rect.top)) * hs]);
  } else if (t.hasAttribute('data-tooltip')) {
    tooltip.style.display = 'inline-block';
    tooltip.innerHTML = t.dataset.tooltip;
    const left = () => {
      setTimeout(() => {
        tooltip.style.display = 'none';
      }, 1250);
      a.removeEventListener('mouseleave', left);
    }
    a.addEventListener('mouseleave', left);
  }
}

var FFup = (e_) => {

}

var FFmove = (e_) => {
  if (e_) {
    if (!isTouch || e_.touches.length === 1) {
      e_.preventDefault();
      mousepos.x = isTouch ? e_.touches[0].clientX + window.visualViewport.offsetLeft: e_.x;
      mousepos.y = isTouch ? e_.touches[0].clientY + window.visualViewport.offsetTop: e_.y;
    }
  }
}

function plaintext(e) {
  e.preventDefault();
  const text = e.clipboardData.getData('text/plain').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  document.execCommand('insertHTML', false, text);
}

function splitlines(e) {
  return e.innerHTML.replace(/\<br\>/g, '\n').split('\n').filter((x) => x);
}

var makefit = false;
function quicklook(e) {
  if (e.target.classList.contains('lazy')) {
    e.preventDefault();
    const t = e.target;

    const img = new Image();
    img.src = t.parentNode.getAttribute('href');

    get_dim(img, 3);
    const ctx = newCanvas(dim[3][2], dim[3][3]);
    const previewer = ctx.canvas;
    previewer.id = 'previewer';
    if (makefit) {
      previewer.classList = 'makefit';
    }

    const eldest_sibling = t.parentNode.parentNode.parentNode.childNodes[0];
    if (eldest_sibling && eldest_sibling.childNodes[0].nodeName === 'A') {
      const img2 = new Image();
      img2.src = eldest_sibling.childNodes[0].getAttribute('href');
      if (img2.src === img.src) {
        ctx.fillRect(...dim[3]);
      } else {
        img.onload = () => {
          fps = 1;
          if (true) {
            img2.onload = canvasdiff(img, img2);
          } else {
            img2.onload = apngdiff(img, img2);
          }
        }
      }
    }

    t.parentNode.appendChild(previewer);
    const listener = () => {
      setTimeout(() => {
        t.parentNode.removeChild(previewer);
      }, 40);
      t.removeEventListener('mouseleave', listener);
    }
    t.addEventListener('mouseleave', listener);
  }
}

document.addEventListener('mouseover', quicklook);

function lazyload() {
  const lazyloadImages = document.querySelectorAll('.lazy');
  const imageObserver = new IntersectionObserver((entries, observer) => {
    for (const e of entries) {
      if (e.isIntersecting) {
        const image = e.target;
        image.src = image.dataset.src;
        imageObserver.unobserve(image);
      }
    };
  });

  for (const img of lazyloadImages) {
    img.style.height = '200px';
    img.style.width = 'auto';
    imageObserver.observe(img);
  };
}

var Expand = (c, t) => {
  if (!c.naturalWidth) {
    return setTimeout(Expand, 10, c, t);
  }
  c.style.maxWidth = '100%';
  c.style.display = '';
  t.style.display = 'none';
  t.style.opacity = '';
};

var Expander = (e) => {
  const t = e.target;
  if (t.parentNode.classList.contains('fileThumb')) {
    e.preventDefault();
    if (t.hasAttribute('data-src')) {
      const img = document.createElement('IMG');
      const unmolestedhref = t.parentNode.getAttribute('href');
      img.src = unmolestedhref;
      img.style.display = 'none';
      t.parentNode.appendChild(img);
      t.style.opacity = '0.75';
      setTimeout(Expand, 10, img, t);
    } else {
      const a = t.parentNode;
      a.firstChild.style.display = '';
      a.removeChild(t);
      a.offsetTop < window.pageYOffset && a.scrollIntoView({top: 0, behavior: 'smooth'});
    }
  }
};

function get_ext(f) {
  f = f.name.split('.');
  return f[f.length - 1];
}

function isImage(ext) {
  ext = ext.toLowerCase()
  if (['jpg', 'jpeg', 'bmp', 'png', 'heic'].includes(ext)) {
    return true;
  } else if (ext === 'gif') {
    return 'gif';
  }
}

function isVideo(ext) {
  ext = ext.toLowerCase();
  if (['m4v', 'avi', 'mpg', 'mp4', 'webm'].includes(ext)) {
    return true;
  }
}

function isUTF8(ext) {
  ext = ext.toLowerCase();
  if (['txt', 'bat', 'json', 'js', 'css', 'html'].includes(ext)) {
    return true;
  }
}

function setfps(text) {
  if (isNaN(text)) {
    getfps.style.backgroundColor = "#399"
    fps = 0;
  } else {
    if (0 < text && text <= 120) {
      getfps.style.backgroundColor = "#066"
      fps = Number(text);
    } else {
      getfps.style.backgroundColor = "#399"
      fps = 0;
    }
  }

  if (!text) {
    getfps.style.backgroundColor = "#066"
    fps = 0;
  }
}

function echo(B, b = '<br>', echoer = stdout) {
  echoer.insertAdjacentHTML('beforeend', b + B);
  echoer.style.display = 'inline-block';
}

function ABtoURL(ab) {
  return URL.createObjectURL(new Blob(ab, {type: 'application/octet-stream'}));
}

function ABtoIMG(ab, callback) {
  e = document.createElement('IMG');
  e.src = ABtoURL(ab);
  e.addEventListener('load', () => {
    callback(e);
  });
}

function ABtoAB(ab) {
  return [new Uint8Array(ab)];
}

function echoIMG(img, B) {
  img.style.maxHeight = '400px';
  const dl = document.createElement('A');
  dl.download = B;
  dl.href = img.src;
  dl.appendChild(img);
  echo('');
  stdout.appendChild(dl);
}

function newCanvas(w, h) {
  const d = document.createElement('CANVAS').getContext('2d');
  if (w) {
    d.width = d.canvas.width = w;
  }
  if (h) {
    d.height = d.canvas.height = h;
  }
  return d;
}

function echoCanvas(c) {
  c.style.maxHeight = '400px';
  echo('');
  stdout.appendChild(c);
}

function echoABtoDL(ab, B = 'blob.bin') {
  const e = document.createElement('A');
  e.href = ABtoURL(ABtoAB(ab));
  e.download = B;
  e.textContent = B;
  stdout.appendChild(e);
}

function echoIMGfromCanvas(c, B, ext = 'png') {
  const promise = new Promise(canvasToAB(c, ext));
  promise.then((arri) => {
    ABtoIMG(ABtoAB(arri), (e) => echoIMG(e, B));
  })
}

function echoPalette(h = 8, s = 1) {
  palette.sort();

  const w = Math.ceil(palette.length/h);

  const ctx = newCanvas(w*s, h*s);
  const ctx2 = newCanvas(ctx.width, ctx.height);
  ctx2.imageSmoothingEnabled = false;
  ctx2.scale(s, s);

  const img = ctx.createImageData(w, h);
  const d = img.data;
  for (const [i, p] of palette.entries()) {
    d[i*4] = parseInt(p.slice(0, 2), 16);
    d[i*4+1] = parseInt(p.slice(2, 4), 16);
    d[i*4+2] = parseInt(p.slice(4, 6), 16);
    d[i*4+3] = 255;
  }
  ctx.putImageData(img, 0, 0);

  ctx2.drawImage(ctx.canvas, 0, 0, ctx2.width, ctx2.height, 0, 0, ctx.width, ctx.height);
  echoIMGfromCanvas(ctx2.canvas);
  palette = [];
}

function constPNG(ar, ...arrays) {
  for (const z of arrays) {
    for (const a of Array.from(z)) {
      ar.push(a);
    }
  }
}

function reconstPNG(IHDR, arri) {  
  const new_IDAT = [];
  constPNG(
    new_IDAT,
    [0x49, 0x44, 0x41, 0x54], // IDAT
    arri,
  );

  const size = arri.length;
  arri = [];
  constPNG(arri,
    PNG_signature,
    IHDR,
    int32ToAB(size),
    new_IDAT,
    int32ToAB(crc32(new_IDAT)),
    IEND,
  );

  return arri;
}

function canvasToAB(c, ext = 'png', apngprod = false) {
  return (resolve) => {
    c.toBlob((blob0) => {
      var fr = new FileReader();
      fr.readAsArrayBuffer(blob0);
      fr.onload = () => {
        arri = new Uint8Array(fr.result);
        Module = {};
        Fi.end = performance.now();
        //echo((Fi.end - Fi.inter)/1000 + "s canvasToAB(c)")
        Fi.inter = performance.now();
        if (ext === 'png') {
          if (decompress) {
            //https://manpages.debian.org/stretch/optipng/optipng.1.en.html
            if (apngprod) {
              //Ideal settings for apng production
              arri = optipng(arri, ['-force', '-zw', '32k', '-f', '0', '-zs', '0', '-zm', '8', '-zc', '9', '-nx', '-strip', 'all']).data;
            } else {
              arri = optipng(arri, ['-force', '-zw', '32k', '-f', '0', '-zs', '0', '-zm', '8', '-zc', '9', '-strip', 'all']).data;
            }
          } else if (pako && false) {
            // ABtoIMG(ABtoAB(arri), (e) => echoIMG(e, name.split('.').slice(0, -1).join('.') + ' (canvas).png'));

            const IHDR = arri.slice(PNG_signature.length, PNG_signature.length + 25); // IHDR inherited

            const inflator = new pako.Inflate();
            for (const IDAT of findPos(arri, "IDAT", false)) {
              const clean_IDAT = arri.slice(IDAT.offset + 8, IDAT.offset + 8 + IDAT.len);
              inflator.push(clean_IDAT);
            }

            const pixels = inflator.result;
            if (!inflator.ended) {
              throw new Error('unexpected end of file');
            }

            arri = reconstPNG(IHDR, pako.deflate(pixels, {'level':6}));
          }
        }
        Fi.end = performance.now()
        //echo((Fi.end - Fi.inter)/1000 + "s OptiPNG")
        resolve(arri);
      };
    }, 'image/' + ext);
  }
}

function fullres(i) {
  dim[1] = [...dim[i]];
  dimension.innerHTML = dim[1][2] + " &times; " + dim[1][3];
}

function bigres(i) {
  //sets max dimension, divide by 2 when exceeded, increment division times when 2 isn't enough
  let len = Math.ceil(dim[i][2] / 4000);
  const leny = Math.ceil(dim[i][3] / 4000);

  if (leny > len) {
    len = leny;
  }

  dim[1] = [0, 0, Math.floor(dim[i][2] / len), Math.floor(dim[i][3] / len)];
  dimension.innerHTML = dim[1][2] + " &times; " + dim[1][3];

  if (len > 1) {
    const d = document.createElement("DIV");
    d.classList = "backtip butt";
    d.addEventListener("click", () => {
      fullres(i);
    });
    d.innerHTML = "use original";
    dimension.append(d);
  }
}

function get_dim(image, i) {
  dim[i] = [0, 0, image.width, image.height];
}

function ABtoFrame(arri, callback, interFrameN, fpsm = 1, callback2 = false, filler = false) {
  Fi.inter = performance.now();
  arri = Array.from(arri);
  newframe.arri = arri;
  Fi.end = performance.now();
  //echo((Fi.end - Fi.inter)/1000 + "s ArrayBuffer")
  if (callback === undefined) {
    Fi.fin = performance.now();

    const B = 'Frame ' + (interFrameN+1);
    echo(B + ' in ' + (Fi.fin - Fi.start)/1000 + 's');
    document.title = B;
    ABtoIMG(ABtoAB(arri), (e) => echoIMG(e, name));

    if (callback2) {
      callback2(interFrameN + nextFrame);
    } else {
      document.title = 'Make APNG';
      setfps(getfps.value);
    }
  } else if (interFrameN === undefined) {
    document.title = 'Make APNG';
    if (interecho) {
      ABtoIMG(ABtoAB(arri), (e) => echoIMG(e, 'Resave as.png'));
    };
    toFrame([1000, 1000]);
    callback(0, callback2);
  } else {
    if (filler) {
      echo('APNGified');
    } else {
      const B = 'Frame ' + (interFrameN + 1);
      echo(B);
      document.title = B;
      if (interecho) {
        ABtoIMG(ABtoAB(arri), (e) => echoIMG(e, B + '.png'));
      }
    }
    toFrame([1000/(fps/fpsm), 1000]);
    callback(interFrameN + nextFrame, callback2);
  }
}

function canvasToFrame(callback, interFrameN, fpsm = 1, callback2 = false, filler = false) {
  Fi.inter = performance.now();
  const promise = new Promise(canvasToAB(canvas, 'png', true));
  promise.then((arri) => {
    ABtoFrame(arri, callback, interFrameN, fpsm, callback2, filler);
  })
}

function Convolute(pixels, weights) {
  const side = Math.round(Math.sqrt(weights.length));
  const halfSide = Math.floor(side / 2);

  const [w, h] = [pixels.width, pixels.height];
  const output = newCanvas().createImageData(w, h);
  const [src, dst] = [pixels.data, output.data];

  for (const y of Array(h).keys()) {
    for (const x of Array(w).keys()) {
      const dstOff = (y * w + x) * 4;
      let [r, g, b, a] = [0, 0, 0, 0];
      for (const cy of Array(side).keys()) {
        for (const cx of Array(side).keys()) {
          const scy = Math.min(h - 1, Math.max(0, y + cy - halfSide));
          const scx = Math.min(w - 1, Math.max(0, x + cx - halfSide));
          const srcOff = (scy * w + scx) * 4;
          const wt = weights[cy * side + cx];
          r += src[srcOff] * wt;
          g += src[srcOff+1] * wt;
          b += src[srcOff+2] * wt;
          a += src[srcOff+3] * wt;
        }
      }
      dst[dstOff] = r;
      dst[dstOff+1] = g;
      dst[dstOff+2] = b;
      dst[dstOff+3] = 255;
    }
  }

  return output;
}

function edge(m) {
  Fi.start = performance.now();
  Fi.inter = performance.now();
  if (bg) {
    context.drawImage(bg, ...dim[1]);
  }
  context.drawImage(m, ...dim[1]);
  context.putImageData(Convolute(context.getImageData(...dim[1]), [-1, -1, -1, -1,  8, -1, -1, -1, -1]), 0, 0);
  fps = 1;
  canvasToFrame(staticAPNG, -2, 1);
}

function contour(a) {
  var r = [32, 64, 128, 160, 192, 224];
  var g = [8, 16, 32, 64, 128, 192];
  var b = [96, 128, 160, 192, 224, 240];
  /*var r = [32, 64, 112, 144, 176, 208]*/

  /*for (var i = 0; i < 6; i++) {
    var rgba = (00 + r[i].toString(16)).slice(-2) + (00 + g[i].toString(16)).slice(-2) + (00 + b[i].toString(16)).slice(-2);
    palette.push(rgba);
  }
  echoPalette(6, 4)*/

  for (var i = 0; i < a.length; i += 4) {
    a[i+3] = 255;
    if (a[i] === 0 && a[i+1] === 0 && a[i+2] === 0) {
      a[i] = 0;
      a[i+1] = 0;
      a[i+2] = 0;
    } else if (a[i] > 12 || a[i+1] > 12 || a[i+2] > 12) {
      a[i] = 255;
      a[i+1] = 255;
      a[i+2] = 255;
    } else if (a[i] > 10 || a[i+1] > 10 || a[i+2] > 10) {
      a[i] = r[5];
      a[i+1] = g[5];
      a[i+2] = b[5];
    } else if (a[i] > 8 || a[i+1] > 8 || a[i+2] > 8) {
      a[i] = r[4];
      a[i+1] = g[4];
      a[i+2] = b[4];
    } else if (a[i] > 6 || a[i+1] > 6 || a[i+2] > 6) {
      a[i] = r[3];
      a[i+1] = g[3];
      a[i+2] = b[3];
    } else if (a[i] > 4 || a[i+1] > 4 || a[i+2] > 4) {
      a[i] = r[2];
      a[i+1] = g[2];
      a[i+2] = b[2];
    } else if (a[i] > 2 || a[i+1] > 2 || a[i+2] > 2) {
      a[i] = r[1];
      a[i+1] = g[1];
      a[i+2] = b[1];
    } else if (a[i] > 0 || a[i+1] > 0 || a[i+2] > 0) {
      a[i] = r[0];
      a[i+1] = g[0];
      a[i+2] = b[0];
    };
  }
}

function detect() {
  seqFrameN = splitlines(framelist);
  canvas.width = dim[1][2];
  canvas.height = dim[1][3];
  dim[3] = [...dim[1]];
  if (seqFrameN.length > 1) {
    if (fps === 0) {
      echo('Bad FPS');
    } else {
      apngdiff(framearray[seqFrameN[0]-1][0], framearray[seqFrameN[1]-1][0], seqFrameN.length === 3 ? framearray[seqFrameN[2]-1][0] : false);
    }
  } else {
    edge(framearray[seqFrameN[0]-1][0]);
  }
}

var palette = [];
function frame_diff(a, b, i) {
  const d = {
    x: [],
    y: [],
  };
  for (const y of Array(dim[i][3]).keys()) {
    const o = (y+1)*dim[i][2];
    for (let x=(o-dim[i][2])*4; x<o*4; x+=4) {
      if (b[x+3] !== 0 && a[x+3] === 255 && a[x] === b[x] && a[x+1] === b[x+1] && a[x+2] === b[x+2]) {
        b[x+3] = 0;
      } else {
        d.x.push((x/4)+dim[i][2]-o);
        d.y.push(y);
        //var rgba = (00 + b[x].toString(16)).slice(-2) + (00 + b[x+1].toString(16)).slice(-2) + (00 + b[x+2].toString(16)).slice(-2);
        //if (palette.indexOf(rgba) < 0) {
        //  palette.push(rgba);
        //}
        // evil: indexOf, toString(16), pad zeros
        // reverse with parseInt(hexString, 16);
      }
    }
  }
  d.x.sort((a,b) => a-b);
  d.y.sort((a,b) => a-b);
  dim[3] = [d.x[0], d.y[0], d.x[d.x.length-1]-d.x[0]+1, d.y[d.y.length-1]-d.y[0]+1];
}

const qixmask = newCanvas();

function magic_wand(satellite) {
  qixmask.width = qixmask.canvas.width = canvas.width;
  qixmask.height = qixmask.canvas.height = canvas.height;

  const qixmap = qixmask.createImageData(canvas.width, canvas.height);
  const color = context.getImageData(0, 0, canvas.width, canvas.height);

  const n = satellite[0] + satellite[1] * qixmask.width;
  const rgba = color.data.slice(n*4, n*4+4);

  const monstermap = new Uint8Array(canvas.width * canvas.height);
  let pixels = 0;

  for (const n of Array(canvas.width * canvas.height).keys()) {
    if (color.data.slice(n*4, n*4+4).every((r, i) => r === rgba[i])) {
    //if (qixmap.data[n*4+3] === 255) {
      monstermap[n] = 1;
    } else {
      pixels++;
      monstermap[n] = 0;
    }
  }

  // while (satellite.length > 0) {
  //   const y = satellite.pop();
  //   const x = satellite.pop();
  //   if (x >= 0 && y >= 0 && x < canvas.width && y < canvas.height && monstermap[y*canvas.width + x]) {
  //     monstermap[y * canvas.width + x] = 0;
  //     satellite.push(x + 1, y);
  //     satellite.push(x - 1, y);
  //     satellite.push(x, y + 1);
  //     satellite.push(x, y - 1);
  //   }
  // }

  for (const [n, pixel] of monstermap.entries()) {
    if (pixel) {
      pixels++;
      qixmap.data[n*4] = 128;
      qixmap.data[n*4+1] = 0;
      qixmap.data[n*4+2] = 255;
      qixmap.data[n*4+3] = 255;
    }
  }

  qixmask.putImageData(qixmap, 0, 0);
  echoCanvas(qixmask.canvas);
}

function draw(x, i) {
  Fi.start = performance.now();
  Fi.inter = performance.now();
  canvas.width = dim[1][2];
  canvas.height = dim[1][3];
  if (bg) {
    context.drawImage(bg, ...dim[1]);
  }
  context.drawImage(x, ...dim[1]);
  frameBuffer[i] = context.getImageData(...dim[1]);
}

function difference(a, b) {
  let d = frameBuffer[b].data;
  let e = frameBuffer[a].data;
  for (let i = 0; i < d.length; i += 4) {
    d[i] = Math.abs(d[i] - e[i]);
    d[i+1] = Math.abs(d[i+1] - e[i+1]);
    d[i+2] = Math.abs(d[i+2] - e[i+2]);
  }
  contour(d);
  context.putImageData(frameBuffer[b], 0, 0);
}

function subtract(a, b) {
  let d = frameBuffer[b].data;
  let e = frameBuffer[a].data;
  for (let i = 0; i < d.length; i += 4) {
    d[i] -= e[i];
    d[i+1] -= e[i+1];
    d[i+2] -= e[i+2];
  }
  contour(d);
  context.putImageData(frameBuffer[b], 0, 0);
}

function cropdiff(a, b, end) {
  frame_diff(frameBuffer[a].data, frameBuffer[b].data, 1);
  if (!end) {
    frameBuffer[0] = context.getImageData(...dim[1]);
  }
  context.putImageData(frameBuffer[b], 0, 0);
  crop();
}

function apngdiff(m, s, s2=false) {
  draw(m, 1);
  let reuse = [false, false, false, false];

  const f1 = () => {
    if (s2) {
      reuse[1] = newframe.arri;
      reuse[3] = dim[3];
    } else {
      reuse[0] = newframe.arri;
      reuse[2] = dim[3];
    }
    draw(m, 2);
    cropdiff(0, 2, true);
    canvasToFrame(r2, 0);
  }

  const f2 = () => {
    draw(s, 2);
    cropdiff(1, 2);
    canvasToFrame((s2?f3:f1), 1);
  }

  const f3 = () => {
    reuse[0] = newframe.arri;
    reuse[2] = dim[3];
    draw(s2, 2);
    cropdiff(0, 2);
    canvasToFrame(f1, 2);
  }

  const r2 = () => {
    Fi.start = performance.now();
    Fi.inter = performance.now();
    dim[3] = reuse[2];
    ABtoFrame(reuse[0], (s2?r3:d1), 1);
  }

  const r3 = () => {
    Fi.start = performance.now();
    Fi.inter = performance.now();
    dim[3] = reuse[3];
    ABtoFrame(reuse[1], d1, 2);
  }

  const d1 = () => {
    draw(s, 2);
    subtract(1, 2);
    cropdiff(0, 2);
    canvasToFrame(d2, -2);
  }
  
  const d2 = () => {
    draw(s, 2);
    difference(1, 2);
    cropdiff(0, 2);
    canvasToFrame((s2?d3:d6), -2.5);
  }

  const d3 = () => {
    draw(s, 2);
    draw(s2, 3);
    subtract(2, 3);
    cropdiff(0, 3);
    canvasToFrame(d4, -3);
  }

  const d4 = () => {
    draw(s2, 3);
    difference(2, 3);
    cropdiff(0, 3);
    canvasToFrame(d5, -3.5);
  }

  const d5 = () => {
    draw(s2, 3);
    subtract(1, 3);
    cropdiff(0, 3);
    canvasToFrame(d6, -4);
  }

  const d6 = () => {
    if (s2) {
      draw(s2, 3);
      difference(3, 1);
    } else {
      draw(s, 2);
      subtract(2, 1);
    }
    cropdiff(0, 1, true);
    canvasToFrame(makeAPNG, (s2?-4.5:-3));
  }

  canvasToFrame(f2, 0);
}

function canvasdiff(m, s) {
  context.drawImage(m, ...dim[1])
  frameBuffer[0] = context.getImageData(...dim[1]);
  setTimeout(() => {
    context.drawImage(s, ...dim[1])
    frameBuffer[1] = context.getImageData(...dim[1]);
    subtract(frameBuffer[0].data, frameBuffer[1]);
    setTimeout(() => {
      context.putImageData(frameBuffer[1], 0, 0);
      setTimeout(() => {
        context.drawImage(s, ...dim[1]);
        frameBuffer[1] = context.getImageData(...dim[1]);
        difference(frameBuffer[0].data, frameBuffer[1]);
        context.putImageData(frameBuffer[1], 0, 0);
        setTimeout(() => {
          context.drawImage(s, ...dim[1]);
          frameBuffer[1] = context.getImageData(...dim[1]);
          subtract(frameBuffer[1].data, frameBuffer[0]);
          context.putImageData(frameBuffer[0], 0, 0);
          setTimeout(() => {
            requestAnimationFrame(canvasdiff(m, s));
          }, 1000/fps);
        }, 1000/fps);
      }, 1000/fps);
    }, 1000/fps);
  }, 1000/fps);
}



function APNG() {
  this.width = 0;
  this.height = 0;
  this.frames = [];
}

function GIF() {
  this.width = 0;
  this.height = 0;
  this.frames = [];
};

function Frame() {
  this.width = 0;
  this.height = 0;
  this.left = 0;
  this.top = 0;
  this.numerator = 0;
  this.denominator = 0;
  this.disposeOp = 0;
  this.blendOp = 0;
  this.arri = [];
  this.IDATs = [];
}



const rechk = /^([<>])?(([1-9]\d*)?([xcbB?hHiIfdsp]))*$/
const refmt = /([1-9]\d*)?([xcbB?hHiIfdsp])/g
const str = (v,o,c) => String.fromCharCode(...new Uint8Array(v.buffer, v.byteOffset + o, c))
const rts = (v,o,c,s) => new Uint8Array(v.buffer, v.byteOffset + o, c).set(s.split('').map(str => str.charCodeAt(0)))
const pst = (v,o,c) => str(v, o + 1, Math.min(v.getUint8(o), c - 1))
const tsp = (v,o,c,s) => { v.setUint8(o, s.length); rts(v, o + 1, c - 1, s) }
const lut = le => ({
  x: c=>[1,c,0],
  c: c=>[c,1,o=>({u:v=>str(v, o, 1)      , p:(v,c)=>rts(v, o, 1, c)     })],
  '?': c=>[c,1,o=>({u:v=>Boolean(v.getUint8(o)),p:(v,B)=>v.setUint8(o,B)})],
  b: c=>[c,1,o=>({u:v=>v.getInt8(   o   ), p:(v,b)=>v.setInt8(   o,b   )})],
  B: c=>[c,1,o=>({u:v=>v.getUint8(  o   ), p:(v,B)=>v.setUint8(  o,B   )})],
  h: c=>[c,2,o=>({u:v=>v.getInt16(  o,le), p:(v,h)=>v.setInt16(  o,h,le)})],
  H: c=>[c,2,o=>({u:v=>v.getUint16( o,le), p:(v,H)=>v.setUint16( o,H,le)})],
  i: c=>[c,4,o=>({u:v=>v.getInt32(  o,le), p:(v,i)=>v.setInt32(  o,i,le)})],
  I: c=>[c,4,o=>({u:v=>v.getUint32( o,le), p:(v,I)=>v.setUint32( o,I,le)})],
  f: c=>[c,4,o=>({u:v=>v.getFloat32(o,le), p:(v,f)=>v.setFloat32(o,f,le)})],
  d: c=>[c,8,o=>({u:v=>v.getFloat64(o,le), p:(v,d)=>v.setFloat64(o,d,le)})],
  s: c=>[1,c,o=>({u:v=>str(v,o,c), p:(v,s)=>rts(v,o,c,s.slice(0,c    ) )})],
  p: c=>[1,c,o=>({u:v=>pst(v,o,c), p:(v,s)=>tsp(v,o,c,s.slice(0,c - 1) )})]
})
const errbuf = new RangeError('Structure larger than remaining buffer');
const errval = new RangeError('Not enough values for structure');
function struct(format) {
  const fns = [];
  let size = 0;
  let m = rechk.exec(format);

  if (!m) {
    throw new RangeError('Invalid format string');
  }

  const t = lut('<' === m[1]), lu = (n, c) => t[c](n ? parseInt(n, 10) : 1)

  while ((m = refmt.exec(format))) {
    ((r, s, f) => {
      for (let i = 0; i < r; ++i, size += s) {
        if (f) {
          fns.push(f(size));
        }
      }
    })(...lu(...m.slice(1)))
  }

  const unpack_from = (arrb, offs) => {
    if (arrb.byteLength < (offs|0) + size) {
      throw errbuf;
    }
    let v = new DataView(arrb, offs|0)
    return fns.map(f => f.u(v))
  }

  const pack_into = (arrb, offs, ...values) => {
    if (values.length < fns.length) {
      throw errval;
    }
    if (arrb.byteLength < offs + size) {
      throw errbuf;
    }

    const v = new DataView(arrb, offs);
    //new Uint8Array(arrb, offs, size).fill(0)
    for (const [f, i] of fns) {
      f.p(v, values[i]);
    };
  }

  const pack = (...values) => {
    let b = new ArrayBuffer(size);
    pack_into(b, 0, ...values);
    return b;
  }

  const unpack = (arrb) => {
    return unpack_from(arrb, 0);
  }

  function* iter_unpack(arrb) { 
    for (let offs = 0; offs + size <= arrb.byteLength; offs += size) {
      yield unpack_from(arrb, offs);
    }
  }

  return Object.freeze({
    unpack,
    pack,
    unpack_from,
    pack_into,
    iter_unpack,
    format,
    size,
  });
}

function mod(n, m) {
  return ((n % m) + m) % m;
}

const TMDIPack = struct("<7sxIII");
const PAC_MAX_NAME = 64;
const PAC_RESERVED = 48;
const TPackerHeader = struct(`<4sIIII${PAC_RESERVED}x${PAC_MAX_NAME}s`);
const HeaderStruct = struct("<IIII");
const PAC = struct('<I');
let layers = [];

function toCanvasMode(vaguemode) {
  switch (vaguemode) {
    // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
    case 'normal':
      return "source-over";
    case 'add':
      return "lighter";
    case 'mul':
      return "multiply";
    case 'screen':
      return "screen";
    case 'overlay':
      return "overlay";
    case 'dark':
      return "darken";
    case 'light':
      return "lighten";
    case 'dodge':
      return "color-dodge";
    case 'burn':
      return "color-burn";
    case 'hardlight':
      return "soft-light";
    case 'softlight':
      return "hard-light";
    case 'diff':
      return "difference";
    case 'idonthaveexclusion':
      return "exclusion";
    case 'hue':
      return "hue";
    case 'saturation':
      return "saturation";
    case 'color':
      return "color";
    case 'luminosity':
      return "luminosity";
    case 'div': //might that be synonymous with subtract?
    default:
      return "source-over";
  }
}

function readMDP(arri) {
  if (!pako) {
    echo('Please try again with <a href="https://github.com/nodeca/pako/blob/master/dist/" target="_blank">pako.min.js</a>, save next to HTML then reload this page');
    return;
  }

  const offset1 = TMDIPack.size;
  const offset2 = TPackerHeader.size;
  const offset3 = HeaderStruct.size;

  let part = arri.subarray(0, offset1);
  const [signature, version, mdiSize, mdibinSize] = TMDIPack.unpack(arri.buffer.slice(0, offset1));
  const mdiBytes = arri.subarray(offset1, offset1 + mdiSize);
  const El = readString(mdiBytes);
  //console.log(El);

  const parser = new DOMParser();
  const xmlDoc = parser.parseFromString(El, "text/xml");
  const Mdiapp = xmlDoc.getElementsByTagName("Mdiapp")[0];
  canvas.width = Mdiapp.getAttribute("width");
  canvas.height = Mdiapp.getAttribute("height");

  layers = [];
  const layerelements = Mdiapp.getElementsByTagName('Layers')[0].getElementsByTagName('Layer');
  for (const e of layerelements) {
    const layer = newCanvas(canvas.width, canvas.height); 
    layer.bin = e.getAttribute('bin');
    layer.type = e.getAttribute('masking') === 'true' ? 'mask' : e.getAttribute('type');
    layer.mode = e.getAttribute('mode');
    layer.color = e.getAttribute('color');
    layer.alpha = Math.ceil(e.getAttribute('alpha') / 255 * 100) / 100;
    layer.ofsx = e.getAttribute('ofsx');
    layer.ofsy = e.getAttribute('ofsy');
    layer.visible = e.getAttribute('visible') === 'true';
    layer.mode = toCanvasMode(e.getAttribute('mode'));
    layers.push(layer);
  }

  const mdp_mdibin = {};
  let dl = 0;
  let pos = offset1 + mdiSize;
  while (dl < mdibinSize) {
    let [chunkSignature, chunkSize, streamType, streamSize, archiveSize, archiveName] = TPackerHeader.unpack(arri.buffer.slice(pos, pos + offset2));
    pos += offset2;
    archiveName = archiveName.replace(/\0/g, '');

    if (streamType === 0) {
      // Will decompress later
      mdp_mdibin[archiveName] = pos;
    } else if (streamType === 1) {
      // A thumbnail, skipped, but it can be decompressed like so
      // data = pako.inflate(arri.slice(pos, pos + streamSize));
    } else {
      console.log(`Unknown streamType Code: ${streamType}`);
    }

    pos += streamSize;
    dl += chunkSize;
  }

  while (layerlist.firstChild) {
    layerlist.lastChild.remove()
  };

  const readLayer = (LayerN) => {
    if (LayerN >= layers.length) {
      updatebutton(echolayers, echoMDP);
      return;
    }

    const layer = layers[LayerN];
    //Fi.start = performance.now();

    if (layer.type === 'folder') {
      setTimeout(() => {readLayer(LayerN+1)}, 1000);
    };

    let pos = mdp_mdibin[layer.bin];
    const tileNum = PAC.unpack(arri.buffer.slice(pos, pos + 4))[0];
    pos += 4;

    if (!tileNum) {
      setTimeout(() => {readLayer(LayerN+1)}, 1000);
    }

    if (layer.type === 'mask') {
      layerlist.innerHTML += `${LayerN} ${layer.visible} ${layer.alpha} ${layer.type} ${layer.ofsx} ${layer.ofsy}\n`;
    } else {
      layerlist.innerHTML += `${LayerN} ${layer.visible} ${layer.alpha} ${layer.type} ${layer.ofsx} ${layer.ofsy} ${layer.mode}\n`;
    }

    const layerColor = layer.color;

    const dim = PAC.unpack(arri.buffer.slice(pos, pos + 4))[0];
    pos += 4;

    const tilemask = newCanvas(dim, dim);

    const dataToLayer = (data, callback, interTileN, x, y) => {
      if (false) {
        // BGRA to RGBA tilemap
        const tilemap = tilemask.createImageData(dim, dim);
        for (let n = 0; n < data.length; n += 4) {
          tilemap.data[n] = data[n+2];
          tilemap.data[n+1] = data[n+1];
          tilemap.data[n+2] = data[n];
          tilemap.data[n+3] = data[n+3];
        }
        tilemask.putImageData(tilemap, 0, 0);
      } else {
        // BGRA to RGBA then passthrough
        for (let n = 0; n < data.length; n += 4) {
          const r = data[n];
          data[n] = data[n + 2];
          data[n + 2] = r;
        }
        tilemask.putImageData(new ImageData(new Uint8ClampedArray(data), dim, dim), 0, 0);
      }

      layer.drawImage(tilemask.canvas, x*dim, y*dim, dim, dim);
      callback(interTileN + 1);
    }

    const tileReadStreams = (callback, interTileN, isMask) => {
      const header = arri.buffer.slice(pos, pos + offset3);
      pos += offset3;

      const [x, y, compression_type, size] = HeaderStruct.unpack(header);
      const clean_IDAT = arri.slice(pos, pos + size);
      pos += size + mod(4-size, 4);

      if (false) {
        // datastream (broken)
        const blob = new Blob(ABtoAB(clean_IDAT), {type: 'application/octet-stream'});
        const decompressor = new DecompressionStream('deflate-raw');
        const decompressedStream = blob.stream().pipeThrough(decompressor);
        const response = new Response(decompressedStream);
        response.blob().then((data) => {
          dataToLayer(data, callback, interTileN, x, y);
        });
      } else if (false) {
        // PNGifiedTile
        const data = pako.inflate(clean_IDAT);
        
        let IHDR = new Array(0);
        constPNG(
          IHDR,
          int32ToAB(dim),
          int32ToAB(dim),
          [0x08, 0x06, 0x00, 0x00, 0x00], // RGBA
        );
        IHDR = makeChunkBytes('IHDR', IHDR);
        
        const scanline = dim * 4;
        const fdata = new Array(scanline * dim + dim);
        for (const y of Array(dim).keys()) {
          const o = y * scanline;
          fdata[o + y] = 0; // filter-method scanline byte
          const x = o + y + 1;
          for (let n = 0; n < scanline; n += 4) {
            fdata[x + n] = data[o + n+2];
            fdata[x + n+1] = data[o + n+1];
            fdata[x + n+2] = data[o + n];
            fdata[x + n+3] = data[o + n+3];
          }
        }
        
        const ab = reconstPNG(IHDR, pako.deflate(new Uint8Array(fdata)));
        const listener = (e) => {
          layer.drawImage(e, x*dim, y*dim, dim, dim);

          callback(interTileN + 1);
          // echoIMG(e, name.split('.').slice(0, -1).join('.') + ' (tile).png');
        };
        ABtoIMG(ABtoAB(ab), listener);
      } else {
        // pako
        const data = pako.inflate(clean_IDAT);
        dataToLayer(data, callback, interTileN, x, y);
      }
    };

    const tileRead = (callback, interTileN, isMask) => {
      const header = arri.buffer.slice(pos, pos + offset3);
      pos += offset3;

      const [x, y, compression_type, size] = HeaderStruct.unpack(header);
      const clean_IDAT = arri.slice(pos, pos + size);
      pos += size + mod(4-size, 4);

      const data = pako.inflate(clean_IDAT);

      if (isMask) {
        const tilemap = tilemask.createImageData(dim, dim);
        for (let n = 0; n < data.length*4; n += 4) {
          tilemap.data[n] = 0;
          tilemap.data[n+1] = 0;
          tilemap.data[n+2] = 0;
          tilemap.data[n+3] = data[Math.ceil(n/4)];
        }

        tilemask.putImageData(tilemap, 0, 0);
        layer.drawImage(tilemask.canvas, x*dim, y*dim, dim, dim);
        callback(interTileN + 1);
      } else {
        dataToLayer(data, callback, interTileN, x, y);
      }
    };



    //Fi.inter = performance.now();
    const readTile = (TileN) => {
      if (TileN >= tileNum) {
        // Safari has tendency to lose canvas from large savefile, sometime crashing the webpage. How is Photopea able to get away with heavy layers?
        setTimeout(() => {
          readLayer(LayerN + 1);
        }, 0);
        return;
      }

      if (layerColor) {
        const [a, r, g, b] = [layerColor.substring(0, 2), layerColor.substring(2, 4), layerColor.substring(4, 6), layerColor.substring(6, 8)];
        tilemask.fillStyle = `#${r}${g}${b}${a}`;
        tilemask.fillRect(0, 0, dim, dim);
      }

      switch (layer.type) {
        case '32bpp':
          tileReadStreams(readTile, TileN);
          break;
        case '8bpp':
        case '1bpp':
        case 'mask':
          tileRead(readTile, TileN, true);
          break;
        default:
          console.log('Illegal');
      }
    }
    readTile(0);
    //echo(`${layer.getAttribute("name")} with ${tileNum} tiles took ${(performance.now()-Fi.inter)/1000} seconds`);
  }
  readLayer(0);
}

function echoMDP() {
  const ctx = newCanvas(canvas.width, canvas.height);

  let started = true;
  let visibleformask = false;
  let usemode = 'source-over';
  let usealpha = 1;

  for (const next of splitlines(layerlist)) {
    const seq = next.split(/ +/);
    if (seq[1] === 'false' || seq[3] === 'folder') {
      visibleformask = false;
      continue;
    }

    switch (seq[3]) {
      case 'mask':
        if (!visibleformask) {
          continue;
        }
        const mask = newCanvas(canvas.width, canvas.height);

        mask.drawImage(layers[parseInt(seq[0])].canvas, 0, 0, canvas.width, canvas.height);
        mask.globalCompositeOperation = 'source-out';
        mask.drawImage(ctx.canvas, 0, 0, ctx.width, ctx.height);
        mask.globalCompositeOperation = 'source-over';

        ctx.clearRect(0, 0, ctx.width, ctx.height);
        ctx.drawImage(mask.canvas, 0, 0, mask.width, mask.height);
        break;
      default:
        visibleformask = true;
        if (!started) {
          context.globalCompositeOperation = usemode;
          context.globalAlpha = usealpha;
          context.drawImage(ctx.canvas, 0, 0, ctx.width, ctx.height);
       
          // reset
          ctx.clearRect(0, 0, ctx.width, ctx.height);
          context.globalCompositeOperation = 'source-over';
          context.globalAlpha = 1;
        } else {
          started = false;
        }

        usealpha = parseFloat(seq[2]);
        usemode = seq[6];

        ctx.drawImage(layers[parseInt(seq[0])].canvas, seq[4], seq[5], canvas.width, canvas.height);
        break;
    }
  }

  context.globalCompositeOperation = usemode;
  context.globalAlpha = usealpha;
  context.drawImage(ctx.canvas, 0, 0, ctx.width, ctx.height);

  echoCanvas(canvas);

  updatebutton(makepng, echoIMGfromCanvas, [canvas, name.split('.').slice(0, -1).join('.') + '.png']);
}



function fromGIF(arri) {
  let GCe = false;
  const gif = new APNG();
  const fcTLbuffer = {};
  let pos = GIF89a_signature.length;

  const IHDR = [];
  for (const a of arri.slice(pos, pos + 7)) {
    IHDR.push(a);
  };

  gif.width = IHDR[0] + (IHDR[1] << 8);
  gif.height = IHDR[2] + (IHDR[3] << 8);
  //Fossil specification
 
  const packed_field = IHDR[4]; // Global Color Table, should read as binary
  // IHDR[5]: Background Color Index
  // IHDR[6]: Pixel Aspect Ratio

  pos += 7; // IHDR length
  let IHDRpos = 7;

  // console.log(packed_field.toString(16));
  const color_counter = 1 << ((packed_field & 0b00000111) + 1);

  if (packed_field & 0b10000000) {
    let colors = [];
    for (const n of Array(color_counter).keys()) {
      for (const a of arri.slice(pos, pos + 3)) {
        IHDR.push(a);
      };
      pos += 3;

      colors.push([IHDR[IHDRpos], IHDR[IHDRpos+1], IHDR[IHDRpos+2]]);
      IHDRpos += 3;
    }
  }

  const ingif = () => {
    const firstByte = arri[pos++];
    switch (firstByte) {
      case 0x2C: // ',' image separator
        frame = new Frame();
        gif.frames.push(frame);

        const fcTL = [];
        for (const a of arri.slice(pos, pos + 9)) {
          fcTL.push(a);
        };
        pos += 9;
        let fcTLpos = 9;

        frame.left = fcTL[0] + (fcTL[1] << 8);
        frame.top = fcTL[2] + (fcTL[3] << 8);
        frame.width = fcTL[4] + (fcTL[5] << 8);
        frame.height = fcTL[6] + (fcTL[7] << 8);

        const packed_field = fcTL[8];

        frame.numerator = fcTLbuffer.denominator;
        frame.denominator = 100;
        frame.disposeOp = fcTLbuffer.disposeOp;

        fcTLbuffer.localColorTable = packed_field & 0b10000000 ? true : false;
        const color_counter = 1 << ((packed_field & 0b00000111) + 1);

        if (fcTLbuffer.localColorTable) {
          let colors = [];
          for (const n of Array(color_counter).keys()) {
            for (const a of arri.slice(pos, pos + 3)) {
              fcTL.push(a);
            };
            pos += 3;

            colors.push([fcTL[fcTLpos], fcTL[fcTLpos+1], fcTL[fcTLpos+2]]);
            fcTLpos += 3;
          }
        }

        fcTL.push(arri[pos++]);

        let size = [];
        const clean_IDAT = [];
        while (size !== 0) {
          size = arri[pos++];
          clean_IDAT.push(size);
          for (const a of arri.slice(pos, pos + size)) {
            clean_IDAT.push(a);
          };
          pos += size;
        }

        if (pos >= arri.length) {
          console.log("I've read past the end of file!");
        }

        IHDR[0] = fcTL[4];
        IHDR[1] = fcTL[5];
        IHDR[2] = fcTL[6];
        IHDR[3] = fcTL[7];

        fcTL[0] = 0x00;
        fcTL[1] = 0x00;
        fcTL[2] = 0x00;
        fcTL[3] = 0x00;

        constPNG(
          frame.arri,
          GIF89a_signature,
          IHDR,
          [0x21, 0xFF, 0x0B],
          utf8ToAB(NETSCAPE_sig),
          [0x03, 0x01, 0x00, 0x00, 0x00],
        );

        if (GCe) {
          constPNG(
            frame.arri,
            [0x21, 0xF9],
            GCe,
          );
          GCe = false;
        };

        constPNG(
          frame.arri,
          [0x2C],
          fcTL,
          clean_IDAT,
          [0x3B],
        );

        break;
      case 0x3B: // ';' end of file
        return;
      case 0x21: // Extension Introducer
        const skipBytes = () => {
          let size = true;
          while (size) {
            size = arri[pos++];
            pos += size;
          }
        }

        const nextByte = arri[pos++];
        if (nextByte === 0xF9) { // Graphic Control Extension
          GCe = [];
          for (const a of arri.slice(pos, pos + 6)) {
            GCe.push(a);
          }
          pos += 6; // Assuming Graphic Control Extension size is always 4, then a terminator

          const packed_field = GCe[1]; // disposal method
          fcTLbuffer.denominator = (GCe[2]) + ((GCe[3]) << 8);
          fcTLbuffer.transparencyIndex = packed_field & 0b00000001 ? GCe[4] : 256;
          fcTLbuffer.disposeOp = ((packed_field & 0b00011100) >> 2) - 1;
        } else if (nextByte === 0xFF) { // Application Extension
          const size = arri[pos++];
          const s = readString(arri.slice(pos, pos + size));
          pos += size;
          if (s === NETSCAPE_sig) {
            skipBytes();
          } else {
            skipBytes();
          }
        } else if (nextByte === 0x01 || nextByte === 0xFE) { // Plain Text or Comment Extension
          skipBytes();
        }
        break;
      default:
        console.log(`Illegal byte ${firstByte}`, pos);
    }
    ingif();
  };
  ingif();
  return gif;
}



function fromAPNG(arri) {
  let IHDR = null;
  let frame = null;
  let frameNumber = 0;
  const apng = new APNG();

  const inapng = (type, arri, offset, length) => {
    const dv = new DataView(arri.buffer);
    switch (type) {
      case 'IHDR':
        IHDR = arri.subarray(offset + 8, offset + 8 + length);
        apng.width = dv.getUint32(offset + 8);
        apng.height = dv.getUint32(offset + 12);
        break;
      case 'fcTL':
        if (frame) {
          apng.frames.push(frame);
          frameNumber++;
        }
        frame = new Frame();
        frame.width = dv.getUint32(offset + 8 + 4);
        frame.height = dv.getUint32(offset + 8 + 8);
        frame.left = dv.getUint32(offset + 8 + 12);
        frame.top = dv.getUint32(offset + 8 + 16);
        frame.numerator = dv.getUint16(offset + 8 + 20);
        frame.denominator = dv.getUint16(offset + 8 + 22);
        frame.disposeOp = dv.getUint8(offset + 8 + 24);
        frame.blendOp = dv.getUint8(offset + 8 + 25);
        if (frame.width > maxres[2]){
          maxres[2] = frame.width;
        }
        if (frame.height > maxres[3]){
          maxres[3] = frame.height;
        }
        if (frameNumber === 0 && frame.disposeOp === 2) {
          frame.disposeOp = 1;
        }
        break;
      case 'fdAT':
        if (frame) {
          frame.IDATs.push(arri.subarray(offset + 8 + 4, offset + 8 + length));
        }
        break;
      case 'IDAT':
        if (frame) {
          frame.IDATs.push(arri.subarray(offset + 8, offset + 8 + length));
        }
        break;
    }
  }

  eachChunk(arri, inapng);
  apng.frames.push(frame);
  for (const frame of apng.frames) {
    IHDR.set(int32ToAB(frame.width), 0); // modify IHDR to have new width
    IHDR.set(int32ToAB(frame.height), 4); // modify IHDR to have new height

    constPNG(
      frame.arri,
      PNG_signature,
      makeChunkBytes('IHDR', IHDR), // recalc crc32
    );

    for (const IDAT of frame.IDATs) {
      constPNG(frame.arri, makeChunkBytes('IDAT', IDAT));
    };

    constPNG(frame.arri, IEND);

    frame.IDATs = [];
  };
  return apng;
}



function eachChunk(arri, callback) {
  const dv = new DataView(arri.buffer);
  let offset = 8;
  let type, arr;
  while (arr !== false && type !== 'IEND' && offset < arri.length) {
    const len = dv.getUint32(offset);
    type = readString(arri.subarray(offset + 4, offset + 8));
    arr = callback(type, arri, offset, len);
    offset += 12 + len;
  };
}

function readString(arri) {
  //return new TextDecoder().decode(arri);
  return String.fromCharCode.apply(String, Array.prototype.slice.call(arri));
}

function utf8ToAB(utf8) {
  const len = utf8.length;
  const arr = new Uint8Array(len);
  for (const i of Array(len).keys()) {
    arr[i] = utf8.charCodeAt(i);
  }
  return arr;
}

function makeChunkBytes(type, dataBytes) {
  const len = type.length + dataBytes.length;
  const bytes = new Uint8Array(len + 8);
  const dv = new DataView(bytes.buffer);

  dv.setUint32(0, dataBytes.length);
  bytes.set(utf8ToAB(type), 4);
  bytes.set(dataBytes, 8);
  dv.setUint32(len + 4, crc32(bytes, 4, len));
  return bytes;
};

function int32ToAB(int32) {
  return [int32 >>> 24 & 0xff, int32 >>> 16 & 0xff, int32 >>> 8 & 0xff, int32 & 0xff];
};

function ABtoInt32(ab) {
  return (ab[0] << 24) + (ab[1] << 12) + (ab[2] << 8) + ab[3];
}



var GIF89a_signature = [0x47, 0x49, 0x46, 0x38, 0x39, 0x61];
var NETSCAPE_sig = "NETSCAPE2.0";
var PNG_signature = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A];
var IEND = [0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82];
const newAPNG = [];
var newframe = new Frame();
var frame_counter = -1;
var sequence_number = -1;

function findPos(arri, type, any=true) {
  let offset = 8;
  const indexes = [];
  while (offset < arri.length) {
    const chunk = arri.slice(offset, offset + 4);
    let len = ABtoInt32(chunk);
    if (readString(arri.slice(offset + 4, offset + 8)) === type) {
      if (type === "IDAT" && (chunk[0] || chunk[1])) {
        len = arri.length - PNG_signature.length - 25 - 12 - IEND.length; //-IHDR -UNK
      }

      if (any) {
        return new Chunk(offset, len, type);
      } else {
        indexes.push(new Chunk(offset, len, type));
      }
    }
    offset += 4 + 4 + len + 4;
  }
  return indexes;
}

function Chunk(offset, len, type) {
  this.offset = offset;
  this.len = len;
  this.type = type;
}

function toFrame(fps, bp = [0, 1]) {
  Fi.inter = performance.now()
  frame_counter += 1;

  if (!frame_counter) {
    let IHDR = findPos(newframe.arri, "IHDR");
    IHDR = newframe.arri.slice(IHDR.offset, IHDR.offset + 12 + IHDR.len)

    newAPNG.push(new Uint8Array(PNG_signature));
    newAPNG.push(new Uint8Array(IHDR)); //IHDR inherited
    newAPNG.push([]); //acTL reserved
  }

  for (const [i, IDAT] of findPos(newframe.arri, "IDAT", false).entries()) {
    if (!i) {
      //echo(i + "th IDAT size: " + IDAT.len)
      sequence_number +=1;
      let fcTL = new Array(0);
      constPNG(
        fcTL,
        int32ToAB(26),
        [0x66, 0x63, 0x54, 0x4C], // fcTL
        int32ToAB(sequence_number),
        int32ToAB(dim[3][2]),
        int32ToAB(dim[3][3]),
        int32ToAB(dim[3][0]),
        int32ToAB(dim[3][1]),
        int32ToAB(fps[0]).slice(-2),
        int32ToAB(fps[1]).slice(-2),
        bp, //disposeOp and blendOp
        int32ToAB(crc32(fcTL.slice(4, 4+4+26))),
      );
      newAPNG.push(new Uint8Array(fcTL));
    }

    if (!frame_counter) {
      newAPNG.push(new Uint8Array(newframe.arri.slice(IDAT.offset, IDAT.offset + 12 + IDAT.len)))
    } else {
      const clean_IDAT = newframe.arri.slice(IDAT.offset + 8, IDAT.offset + 8 + IDAT.len);
      const len = IDAT.len + 4;

      sequence_number +=1;
      let fdAT = new Array(0);
      constPNG(
        fdAT,
        int32ToAB(len),
        [0x66, 0x64, 0x41, 0x54], // fdAT
        int32ToAB(sequence_number),
        clean_IDAT,
        int32ToAB(crc32(fdAT.slice(4, 4 + 4 + len))),
      );
      newAPNG.push(new Uint8Array(fdAT));
    };
  }
  Fi.end = performance.now();
  //echo((Fi.end - Fi.inter)/1000 + "s toFrame()")
  Fi.fin = performance.now();
  echo('in ' + (Fi.fin - Fi.start)/1000 + 's', ' ');
}

function makeAPNG(interFrameN, callback = false) {
  newAPNG.push(new Uint8Array(IEND));

  let acTL = new Array(0);
  constPNG(
    acTL,
    [0, 0, 0, 0x08, 0x61, 0x63, 0x54, 0x4C], // acTL
    int32ToAB(frame_counter + 1),
    [0, 0, 0, 0], //loop times, infinity
  );

  const crc = acTL.slice(4, 16);
  constPNG(acTL, int32ToAB(crc32(crc, crc.length)))
  newAPNG[2] = new Uint8Array(acTL);

  frame_counter = -1
  newframe = new Frame();
  sequence_number = -1

  //echoPalette();
  ABtoIMG(newAPNG, (e) => echoIMG(e, name.split('.').slice(0, -1).join('.') + ' (apng).png'));
  document.title = 'Make APNG';
  setfps(getfps.value);
  newAPNG.length = 0;
  if (callback) {
    callback(interFrameN - 1);
  }
}



var table = new Uint32Array(256);
for (const i of Array(256).keys()) {
  let x = i;
  for (const k of Array(8).keys()) {
    x = (x & 1) ? 0xEDB88320 ^ (x >>> 1) : x >>> 1;
  }
  table[i] = x;
}

function crc32(arri, start=0, len=0) {
  let crc = -1;
  for (const i of Array(len ? len : arri.length-start).keys()) {
    crc = crc >>> 8 ^ table[(crc ^ arri[i+start]) & 0xFF];
  }
  return crc ^ -1;
}

function crop() {
  if (dim[3][0] === undefined) {
    dim[3] = [0, 0, 1, 1];
    canvas.width = 1;
    canvas.height = 1;
    context.clearRect(...dim[3]);
  } else {
    let cropped = context.getImageData(...dim[3]);
    canvas.width = dim[3][2];
    canvas.height = dim[3][3];
    context.putImageData(cropped, 0, 0);
  }
}

function frameSaver(interFrameN, i) {
  Fi.inter = performance.now();
  if (interFrameN === 0) {
    frameBuffer[0] = context.getImageData(...dim[i]);
  } else {
    frameBuffer[1] = context.getImageData(...dim[i]);
    frame_diff(frameBuffer[0].data, frameBuffer[1].data, i);
    frameBuffer[0] = context.getImageData(...dim[i]);
    context.putImageData(frameBuffer[1], 0, 0);
    crop();
  }
  Fi.end = performance.now();
  //echo((Fi.end - Fi.inter)/1000 + "s frameSaver()")
}

function drawobj(x) {
  context.beginPath();
  for (const k of Array(x.length).keys()) {
    if (k === 0) {
      context.moveTo(x[0][0], x[0][1]);
    } else{
      context.lineTo(x[k][0], x[k][1]);
    }
  }
  context.closePath();
  context.stroke();
  context.fill();
}

function noise() {
  frameBuffer[3] = context.getImageData(...dim[1]);
  let a = frameBuffer[3].data;
  for (let i=0;i < a.length;i += 4) {
  	if (Math.random() < 0.5) {
      a[i] = 32;
      a[i+1] = 8;
      a[i+2] = 96;
      a[i+3] = 255;
    }
  }
  context.putImageData(frameBuffer[3], 0, 0);
}

function randobg() {
  let s = 800;
  let t = 80;
  canvas.width = dim[1][2];
  canvas.height = dim[1][3];

  context.fillStyle = "#006600";
  context.fillRect(...dim[1]);
  //noise();
  context.fillStyle = "#229922";
  context.strokeStyle = "#33cc33";

  //var r = [32, 64,  128, 160, 192, 224]
  //var g = [8,  16,  32,  64,  128, 192]
  //var b = [96, 128, 160, 192, 224, 240]
  context.fillStyle = "#401080";
  context.fillRect(...dim[1]);
  //noise();
  context.fillStyle = "#8020A0";
  context.strokeStyle = "#A040C0";

  context.lineWidth = 40;

  for (const i of Array(5).keys()) {
    for (const j of Array(4).keys()) {
      drawobj([[100+Math.floor(Math.random()*t)+j*s, 350+Math.floor(Math.random()*t)+i*s], [200+Math.floor(Math.random()*t)+j*s, 200+Math.floor(Math.random()*t)+i*s], [300+Math.floor(Math.random()*t)+j*s, 350+Math.floor(Math.random()*t)+i*s]]);
    }
  }
}

function staticAPNG(interFrameN, callback=false) {
  Fi.start = performance.now();
  Fi.inter = performance.now();

  dim[3] = [0, 0, 1, 1];
  canvas.width = 1;
  canvas.height = 1;
  //context.clearRect(...dim[3]);
  //randobg();
  canvasToFrame(makeAPNG, interFrameN-1, fpsm, callback, true);
}

var nextFrame = 1;
var firstFrame = true;
var fpsm = 1;

function compileframes(multi = true, deap = false) {
  newAPNG.length = 0;
  seqFrameN = splitlines(framelist);
  var lastFrameN;

  firstFrame = true;
  fpsm = 1;
  const updateFrame = (interFrameN, fpsm) => {
    if (interFrameN + 1 === seqFrameN.length) {
      if (seqFrameN.length === 1) {
        name = framearray[seqFrameN[interFrameN]-1][1];
        fps = 1;
        canvasToFrame(staticAPNG, 0, 1);
      } else {
        canvasToFrame(makeAPNG, interFrameN, fpsm);
      }
    } else {
      if (fps === 0) {
        echo('Bad fps');
      } else {
        canvasToFrame(delayFrame, interFrameN, fpsm);
      }
    }
    Fi.end = performance.now();
    //echo((Fi.end - Fi.inter)/1000 + "s canvasing")
  }

  const readFrame = (interFrameN, fpsm) => {
    Fi.start = performance.now();
    Fi.inter = performance.now();

    if (!multi && !bg) {
      get_dim(framearray[seqFrameN[interFrameN]-1][0], 1);
    }

    canvas.width = dim[1][2];
    canvas.height = dim[1][3];
    if(bg){
      context.drawImage(bg, ...dim[1]);
    } else if (createbg){
      context.fillRect(...dim[1]);
      randobg();
    }
    context.drawImage(framearray[seqFrameN[interFrameN]-1][0], ...dim[1]);
    //echoIMGfromCanvas(canvas);
    //return;

    dim[3] = [...dim[1]];
    if (multi && 1 < seqFrameN.length) {
      if (firstFrame) {
        frameSaver(0, 1);
        firstFrame = false;
      } else {
        frameSaver(interFrameN, 1);
      }
      updateFrame(interFrameN, fpsm);
    } else {
      name = framearray[seqFrameN[interFrameN]-1][1];
      fps = 1;
      if (interFrameN + 1 === seqFrameN.length) {
        canvasToFrame(deap ? undefined : staticAPNG, interFrameN, fpsm);
      } else {
        canvasToFrame(deap ? undefined : staticAPNG, interFrameN, fpsm, delayFrame);
      }
    }
  }

  const delayFrame = (interFrameN) => {
    if (interFrameN === seqFrameN.length) {
      readFrame(interFrameN-1, fpsm);
    } else {
      if (interFrameN === 0) {
        if (!bg) {
          get_dim(framearray[seqFrameN[interFrameN]-1][0], 1);
        }
        lastFrameN = seqFrameN[0];
        delayFrame(interFrameN+1);
      } else {
        if (lastFrameN === seqFrameN[interFrameN]) {
          fpsm += 1;
          echo('Frame ' + interFrameN + ' (delay)');
          delayFrame(interFrameN+1);
        } else {
          lastFrameN = seqFrameN[interFrameN];
          readFrame(interFrameN-1, fpsm);
          fpsm = 1;
        }
      }
    }
  }

  delayFrame(0);
  nextFrame = 2;
}

function compileapngs() {
  newAPNG.length = 0;
  seqAPNG = splitlines(apnglist);
  const reuse = [false, false, false]; // pos, dim, arri
  const readFile = (interAPNG) => {
    Fi.start = performance.now();
    Fi.inter = performance.now();

    if (interAPNG === seqAPNG.length) {
      makeAPNG();
      return;
    }

    const frames = apngarray[seqAPNG[interAPNG]-1].frames;
    const readFrame = (interFrameN) => {
      if (interFrameN === frames.length) {
        return;
      }
      const frame = frames[interFrameN];
      let bp = [frame.disposeOp, frame.blendOp];
      //echo((frame.denominator/frame.numerator) + "fps")
      dim[3] = [frame.left, frame.top, frame.width, frame.height];

      const next = 'Frame ' + interFrameN + ' of APNG ' + seqAPNG[interAPNG];
      const toAPNG = (arri) => {
        newframe.arri = arri;
        reuse[0] = seqAPNG[interAPNG];
        document.title = next;
        echo(next);
        if (interecho) {
          echoIMG(img, next + '.png');
        }
        toFrame([frame.numerator, frame.denominator], bp);
        if (interFrameN + 1 === frames.length) {
          readFile(interAPNG+1);
        } else {
          readFrame(interFrameN+1);
        }
      }

      arri = frame.arri;
      const listener = (img) => {
        Fi.start = performance.now();
        Fi.inter = performance.now();
        if (interFrameN === 0) {
          if (interAPNG === 0) {
            get_dim(img, 4);
            if (dim[4][2] < maxres[2] || dim[4][3] < maxres[3]) {
              echo("APNG " + seqAPNG[interAPNG] + " did not accommodate max dimension.<br>First APNG must have the highest dimension.");
              return;
            }
            canvas.width = dim[4][2];
            canvas.height = dim[4][3];
            context.drawImage(img, ...dim[4]);
            frameSaver(0, 4);
            toAPNG(arri);
          } else {
            if (reuse[0] === seqAPNG[interAPNG] && reuse[1]) {
              dim[3] = reuse[1];
              toAPNG(reuse[2]);
            } else {
              // optimize frame 1 for joining
              context.drawImage(img, ...dim[3]);
              frameSaver(1, 4);
              const promise = new Promise(canvasToAB(canvas, 'png', true));
              promise.then((arri) => {
                arri = Array.from(arri);
                if (reuse[0] === seqAPNG[interAPNG]) {
                  reuse[1] = dim[3];
                  reuse[2] = arri;
                } else {
                  reuse[1] = false;
                }
                canvas.width = dim[4][2];
                canvas.height = dim[4][3];
                context.putImageData(frameBuffer[0], 0, 0);
                bp = [0, 1];
                toAPNG(arri);
              });
            }
          }
        } else {
          context.drawImage(img, ...dim[3]);
          frameSaver(0, 4);
          toAPNG(arri);
        }
      }
      ABtoIMG(ABtoAB(arri), listener);
    }
    readFrame(0);
  }
  readFile(0);
}

function echoAPNG() {
  const frames = [];
  seqAPNG = splitlines(apnglist);

  const readFile = (interAPNG, resolve) => {
    if (interAPNG === seqAPNG.length) {
      return resolve(true);
    }

    const raw_frames = apngarray[seqAPNG[interAPNG]-1].frames;
    const readFrame = (interFrameN) => {
      const frame = raw_frames[interFrameN];
      dim[3] = [frame.left, frame.top, frame.width, frame.height];
      const listener = (img) => {
        if (interFrameN === 0) {
          if (interAPNG === 0) {
            get_dim(img, 4);
            canvas.width = dim[4][2];
            canvas.height = dim[4][3];
            context.drawImage(img, ...dim[4]);
            echoCanvas(canvas);
            frames.push([img, [...dim[4]], [frame.disposeOp, frame.denominator, frame.numerator]]);
          } else {
            frames.push([img, [...dim[3]], [frame.disposeOp, frame.denominator, frame.numerator]]);
          }
        } else {
          frames.push([img, [...dim[3]], [frame.disposeOp, frame.denominator, frame.numerator]]);
        }

        if (interFrameN + 1 === raw_frames.length) {
          readFile(interAPNG + 1, resolve);
        } else {
          readFrame(interFrameN + 1);
        }
      }
      ABtoIMG(ABtoAB(frame.arri), listener);
    }
    readFrame(0);
  };

  const promise = new Promise((resolve) => {
    readFile(0, resolve);
  });

  promise.then(() => {
    let n = 0;
    let historical_timeStamp = [];
    let vfps = 0;

    let lastOp = 0;
    const ctx = newCanvas(canvas.width, canvas.height);

    const update = (timeStamp) => {
      if (timeStamp) {
        historical_timeStamp.unshift(timeStamp);
      }

      if (historical_timeStamp.length > 10) {
        const last_fps = historical_timeStamp.pop();
        const fps = Math.floor(1000 * 10 / (timeStamp - last_fps));
        //stdout.innerHTML = `${timeStamp.toFixed(2).padStart(3, '0')} ${fps} fps`;

        vfps += frames[n][2][1]/frames[n][2][2];
        if (vfps >= fps) {
          vfps = vfps-fps;
          if (n > frames.length-2) {
            n = 0;
          } else {
            n++;
          }

          if (lastOp === 0) {
            ctx.drawImage(canvas, 0, 0, canvas.width, canvas.height);
          } else if (lastOp === 1) {
            context.drawImage(ctx.canvas, 0, 0, ctx.width, ctx.height);
            ctx.clearRect(0, 0, ctx.width, ctx.height);
          } else if (lastOp === 2) {
            context.drawImage(ctx.canvas, 0, 0, ctx.width, ctx.height);
          }
          lastOp = frames[n][2][0];

          context.drawImage(frames[n][0], ...frames[n][1]);
        }
      }
      requestAnimationFrame(update);
    }
    requestAnimationFrame(update);
  })
}

function editframelist() {
  framelist.textContent = [...Array(framearray.length).keys()].map((n) => n + 1).join('\n');

  updatebutton(makeapng, compileframes);
  updatebutton(emphdiff, detect);
  updatebutton(resave, compileframes, [false]);
  updatebutton(deapng, compileframes, [false, true]);
}

function editapnglist() {
  apnglist.textContent = [...Array(apngarray.length).keys()].map((n) => n + 1).join('\n');

  updatebutton(mergeapng, compileapngs);
  updatebutton(echoapng, echoAPNG);
}

function readframes(filelist) {
  filelist = Array.from(filelist).sort((a,b) => a.name > b.name);

  const readFile = (i) => {
    if (i === filelist.length) {
      return;
    }

    const fr = new FileReader();
    fr.readAsArrayBuffer(filelist[i]);
    fr.onload = () => {
      const listener = (img) => {
        if (i === 0 && !framearray.length){
          get_dim(img, 0);
          if (!bg) {
            bigres(0);
          }
          name = filelist[0].name;
        }
        framearray.push([img, filelist[i].name]);
        if (i + 1 === filelist.length) {
          editframelist();
        } else {
          readFile(i + 1);
        }
      }
      ABtoIMG(ABtoAB(fr.result), listener);
    }
  }

  readFile(0);
}

function readapng(filelist) {
  filelist = Array.from(filelist).sort((a,b) => a.name > b.name);
  name = filelist[0].name;

  const readFile = (i) => {
    const fr = new FileReader();
    fr.readAsArrayBuffer(filelist[i]);
    fr.onload = () => {
      arri = new Uint8Array(fr.result);
      const listener = (img) => {
        let isAPNG = false;
        const isGIF = false;
        if (Array.prototype.some.call(PNG_signature, (b, i) => {
          return b !== arri[i];
        })) {
          if (Array.prototype.some.call(GIF89a_signature, (b, i) => {
            return b !== arri[i];
          })) {
            echo(" &gt; File excluded: " + filelist[i].name + " is not a PNG or GIF");
          } else {
            apngarray.push(fromGIF(arri));
          }
        } else {
          eachChunk(arri, (type) => {
            return !(isAPNG = type === 'acTL');
          });

          if (!isAPNG) {
            echo(" &gt; File excluded: " + filelist[i].name + " is not an APNG");
          } else {
            apngarray.push(fromAPNG(arri));
          }
        }

        if (i + 1 === filelist.length) {
          editapnglist();
        } else {
          readFile(i+1);
        }
      }
      ABtoIMG([arri], listener);
    }
  }
  readFile(0);
}

var addbg, rbg, removebg;
var bg = false;
function changebg(f){
  bg = new Image();
  bg.src = window.URL.createObjectURL(f);
  bg.onload = () => {
    get_dim(bg, 2);
    bigres(2);
    echo("Success loading background");
    addbg.style.display = "none";
    removebg.style.display = "block";
  };
  bg.onerror = () => {
    echo("Failed to load background");
    bg = false;
  };
}



function loaded() {
  if (!framelist.isContentEditable) {
    const pasta = (e) => {
      plaintext(e);
    }
    framelist.addEventListener("paste", pasta);
    framelist.setAttribute("contenteditable", true);
    apnglist.addEventListener("paste", pasta);
    apnglist.setAttribute("contenteditable", true);
    layerlist.addEventListener("paste", pasta);
    layerlist.setAttribute("contenteditable", true);
  }

  viewer.addEventListener('change', (event) => {
    stdout.insertAdjacentHTML("beforeend", "<br>");
    var f = event.target.files[0];
    name = f.name;
    if (get_ext(f) === "mdp") {
      var fr = new FileReader();
      fr.readAsArrayBuffer(f);
      fr.onload = () => {
        const arri = new Uint8Array(fr.result);
        readMDP(arri);
      }
    } else if (isUTF8(get_ext(f))) {
      var fr = new FileReader();
      fr.readAsArrayBuffer(f);
      fr.onload = () => {
        const arri = new Uint8Array(fr.result);
        const sq = Math.sqrt(arri.length/4);
        const [w, h] = [parseInt(sq), 1 + parseInt(sq) + (sq%1 ? 1 : 0)];

        let IHDR = new Array(0);
        constPNG(
          IHDR,
          int32ToAB(w),
          int32ToAB(h),
          [0x08, 0x06, 0x00, 0x00, 0x00], // RGBA
        );
        IHDR = makeChunkBytes('IHDR', IHDR);

        let fdata = new Array(0);
        for (const i of Array((w)*4).keys()) {
          constPNG(
            fdata,
            [0x00],
            arri.slice(i*w*4, (i+1)*w*4),
          );
        }

        const ab = reconstPNG(IHDR, pako.deflate(new Uint8Array(fdata)));
        const listener = (e) => {
          echoIMG(e, name.split('.').slice(0, -1).join('.') + ' (steg).png');
        }
        ABtoIMG(ABtoAB(ab), listener);
      }
    } else if (isVideo(get_ext(f))) {
      const v = document.createElement('VIDEO');
      v.style.maxHeight = '400px';
      v.setAttribute('controls', '');
      v.setAttribute('playsinline', '');
      v.src = window.URL.createObjectURL(f);
      stdout.appendChild(v);
      v.play();
    } else if (isImage(get_ext(f))) {
      const img = document.createElement('IMG');
      const src = window.URL.createObjectURL(f);
      img.src = src;
      img.style.maxHeight = '400px';
      const dl = document.createElement('A');
      dl.download = f.name;
      dl.href = src;
      dl.appendChild(img);
      stdout.appendChild(dl);
    } else if (get_ext(f).toLowerCase() === 'swf') {
      try {
        const ruffle = window.RufflePlayer.newest();
        const player = ruffle.createPlayer();
        stdout.appendChild(player);
        const src = window.URL.createObjectURL(f);
        player.load(src);
      } catch {
        echo("Please update <a href='https://github.com/ruffle-rs/ruffle/releases' target='_blank'>Ruffle</a> (choose self-hosted version)");
      }
    } else {
      echo("Maybe try another program.");
    }
  });

  debug.addEventListener('click', (e) => {
    if (debug.classList.contains("reverse")){
      debug.classList = "inverse";
      debug.innerHTML = "Debug";
      interecho = true;
    } else {
      debug.classList = "reverse";
      debug.innerHTML = "Production";
      interecho = false;
    }
  });

  loadframes.addEventListener('change', (e) => {
    framearray = [];
    readframes(e.target.files);
  });

  moreframes.addEventListener('change', (e) => {
    readframes(e.target.files);
  });

  background.addEventListener('change', (e) => {
    changebg(e.target.files[0]);
  });

  recompress.addEventListener('click', (e) => {
    if (recompress.classList.contains("reverse")) {
      if (!optipng) {
        echo('Optimize frames with <a href="https://github.com/LI-NA/optipng.js/tree/master/demo/js" target="_blank">optipng.min.js</a>, save next to HTML then reload this page and try again');
        return;
      }
      recompress.classList = "inverse";
      recompress.innerHTML = "Recompress";
      decompress = true;
    } else {
      recompress.classList = "reverse";
      recompress.innerHTML = "No optimization";
      decompress = false;
    }
  });

  getfps.addEventListener('keyup', () => {
    setfps(getfps.value);
  });

  loadapng.addEventListener('change', (e) => {
    apngarray = [];
    maxres = [0, 0, 1, 1];
    readapng(e.target.files);
  });

  moreapng.addEventListener('change', (e) => {
    readapng(e.target.files);
  });

  document.addEventListener("dragover", (e) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'copy';
  });

  document.addEventListener("drop", (e) => {
    e.preventDefault();
    framearray = [];
    readframes(e.dataTransfer.files);
  });

  const addScript = (B) => {
    const s = document.createElement("SCRIPT");
    s.src = B + Date.now();
    document.body.appendChild(s);
    return s;
  }

  let s = addScript("optipng.min.js?");
  s.onerror = () => {
    optipng = false;
  }
  s = addScript("pako.min.js?");
  s.onerror = () => {
    pako = false;
  };
  addScript("ruffle.js?");
}

var filel = ["File", "Diff", "File 1", "File 2", "🦊"];
var ut = 0;

const thisurl = new URLSearchParams(window.location.search);
for (const [v, k] of thisurl) {
  if (!v) {
    if (Number(k)) {
      ut = k;
    } else if (k === "🦦") {
      filel = ["❨'▾'❩", "❨ ꊱ ❩", "❨ 1 ❩", "❨ 2 ❩", "🦦"];
    } else {
      filel[4] = k;
    }
  }
};

function newtip(y, z){
  const d = document.createElement("div");
  d.innerHTML = y;
  d.dataset.tooltip = z;
  d.classList.add("local_tooltip");
  local_backtip.appendChild(d);
  local_backtip.style.display = "inline-block";
}

var fps = 0;
var framearray = [];
var apngarray = [];
var decompress = false;
const Fi = {
  start: 0,
  inter: 0,
  end: 0,
  fin: 0,
};
var canvas = document.createElement('canvas');
var context = canvas.getContext('2d'); // { willReadFrequently: true }
var frameBuffer = [false, false, false, false];
var dim = [false, false, false, false, false]; // framearray[0]'s dim, main_dim, bg_dim, make_dim, compileapngs()
var maxres = [0, 0, 1, 1];
var createbg = false;
var interecho = false;
var DOMwriter, arri, seqFrameN, seqAPNG, seqLayerN, img, Module, name, recompress, dimension, framelist, loadframes, moreframes, echolayers, makepng, background, viewer, pload, getfps;



const newcell = (B, w) => {
  const d = document.createElement("DIV");
  d.classList = "backtip cell";
  if (w) {
    d.style.width = w;
  }

  div = document.createElement("DIV");
  div.classList = "backtip label";
  div.innerHTML = B;
  d.append(div);
  document.body.append(d);
  return d;
}

const fileup = (B, gimme=false) => {
  const l = document.createElement("LABEL");
  l.classList = "next";

  const b = document.createElement("INPUT");
  b.type = "file";
  b.setAttribute("multiple", true);
  l.append(b);
  l.insertAdjacentHTML("beforeend", B);

  if (gimme) {
    return [l, b];
  }

  DOMwriter.append(l);
  return b;
};

const editcell = (B, w = '260px') => {
  const div = document.createElement("DIV");
  div.style.display = "flex";
  div.style.verticalAlign = "top";
  div.style.width = w;

  let d = document.createElement("DIV");

  const e = document.createElement("DIV");
  e.classList = "stdout";
  e.style = "color:#fd6; cursor:text;";
  e.setAttribute("contenteditable", "plaintext-only");
  e.spellcheck = false;
  e.innerHTML = "<br>";

  d.append(e);
  div.append(d);

  d = document.createElement("DIV");
  d.style.margin = "12px";
  d.innerHTML = B;
  div.append(d);  

  DOMwriter.append(div);
  return e;
};

const inputcell = (B, w = '86px') => {
  const d = document.createElement('INPUT');
  d.classList = 'next';
  d.type = 'text';
  d.style.width = w;
  d.placeholder = B;
  DOMwriter.append(d);
  return d;
}

const button = (c, B, callback=echo, args=[]) => {
  const d = document.createElement("DIV");
  d.classList = c;
  d.innerHTML = B;
  const left = () => {
    callback(...args);
  }
  d.addEventListener("click", left);

  if (!d.listeners) {
    d.listeners = [];
  }

  d.listeners.push(left);
  DOMwriter.append(d);
  return d;
};

const updatebutton = (e, callback, args = []) => {
  e.removeEventListener('click', e.listeners[0]);
  e.classList = 'next';
  const listener = () => {
    callback(...args);
  }
  e.listeners[0] = listener;
  e.addEventListener('click', listener);
};

const new_stdout = () => {
  DOMwriter = document.createElement('DIV');
  stdout = document.createElement('DIV');
  stdout.classList = 'stdout';
  stdout.style.whiteSpace = 'initial';
  stdout.innerHTML = '🦦 -(Output)';
  debug = document.createElement('DIV');
  debug.classList = 'reverse';
  debug.innerHTML = 'Production';
  stdout.append(debug);
  DOMwriter.append(stdout);
  document.body.append(DOMwriter);
}



window.onload = () => {
  document.title = 'Make APNG';
  if (isTouch) {
    canvas.addEventListener('touchstart', (e_) => {
      FFdown(e_);
      if (busyclick) {
        clearTimeout(busyclick);
        busyclick = false;
      } else {
        busyclick = setTimeout(() => {rightc(e_)}, 500);
      }
    });
    canvas.addEventListener('touchend', (e_) => {
      FFup(e_);
      clearTimeout(busyclick);
      busyclick = false;
    });
    canvas.addEventListener('touchmove', (e_) => {
      FFmove(e_);
      clearTimeout(busyclick);
      busyclick = false;
    });
    canvas.addEventListener('contextmenu', (e_) => {
      e_.preventDefault();
    });
  } else {
    document.addEventListener('mousedown', FFdown);
    document.addEventListener('mouseup', FFup);
    document.addEventListener('mousemove', FFmove);
    document.addEventListener('contextmenu', (e_) => {
      rightc(e_);
    });
  }



  document.body.innerHTML = "";



  DOMwriter = document.createElement("DIV");
  DOMwriter.style.marginBottom = "12px";
  DOMwriter.style.background = "inherit";
  viewer = fileup("🦦 -(Echo file)");
  const butte = document.createElement("DIV");
  butte.classList = "backtip butt";
  butte.dataset.tooltip = "APNG production:<br>&nbsp;&gt; Use same lossless image with updated changes to update frame with these changes, unchanges are easy task for the frame optimizations to dispose of.<br>&nbsp;&gt; Recommend saving APNG as short clips to merge later when making long APNG series.<br><br>Resaving as single-frame APNG may appear larger in file size due to:<br>&nbsp;&gt; Converted to PNG<br>&nbsp;&gt; 32-bit color (has alpha channel)<br>&nbsp;&gt; Full color profile<br>Image viewers behave differently for PNG resaved as single-frame APNG. You can always discard it and keep original.<br><br>Frame optimization standby:<br>&nbsp;&gt; 4000 max dimension, integer downscale when exceeded<br>&nbsp;&gt; Duplicated interframe pixels will become transparent<br>&nbsp;&gt; Crop frame to fit where pixel changes";
  butte.innerHTML = "🦦 -(Production advices)";
  DOMwriter.append(butte);
  recompress = document.createElement("DIV");
  recompress.classList = "reverse";
  recompress.innerHTML = "No optimization";
  DOMwriter.append(recompress);
  document.body.append(DOMwriter);



  DOMwriter = document.createElement("DIV");
  DOMwriter.classList = "tooltip";
  DOMwriter.id = "tooltip";
  document.body.append(DOMwriter);



  let stderr = ['Filelist is empty!'];
  DOMwriter = newcell("🦦 -(Make)");
  loadframes = fileup("Load Frames");
  moreframes = fileup("Load more");
  [addbg, background] = fileup("Load background", true);
  addbg.style.position = "absolute";
  addbg.style.right = "2px";
  addbg.style.top = "2px";
  DOMwriter.append(addbg);
  rbg = document.createElement("DIV");
  rbg.classList = "reverse";
  rbg.innerHTML = "Random background";
  rbg.addEventListener('click', (e) => {
    if (rbg.classList.contains("reverse")){
      rbg.classList = "inverse";
      rbg.innerHTML = "Alpha background";
      createbg = true;
    } else {
      rbg.classList = "reverse";
      rbg.innerHTML = "Random background";
      createbg = false;
    }
  });
  DOMwriter.append(rbg);
  removebg = document.createElement("DIV");
  removebg.classList = "reverse";
  removebg.style.position = "absolute";
  removebg.style.right = "2px";
  removebg.style.top = "2px";
  removebg.style.display = "none";
  removebg.innerHTML = "Remove background";
  removebg.addEventListener('click', () => {
    bg = false;
    bigres(0);
    echo("Unloaded background");
    removebg.style.display = "none";
    addbg.style.display = "block";
  });
  DOMwriter.append(removebg);
  framelist = editcell("Edit list to rearrange, repeat, or skip a frame by number associated to filelist order, please do not exceed current max number.", "350px");
  DOMwriter.insertAdjacentHTML("beforeend", "Make:");
  makeapng = button("previous", "APNG", echo, stderr);
  emphdiff = button("inverse", "emphasizing diffs", echo, stderr);
  DOMwriter.insertAdjacentHTML("beforeend", "at");
  getfps = inputcell("Bad", "22px");
  DOMwriter.insertAdjacentHTML("beforeend", "fps in dimension: ");
  dimension = document.createElement("SPAN");
  dimension.style.background = "inherit";
  dimension.innerHTML = "0 &times; 0";
  DOMwriter.append(dimension);
  DOMwriter.insertAdjacentHTML("beforeend", "<br>Resave:");
  resave = button("previous", "Single-frame APNG", echo, stderr);
  deapng = button("previous", "Non-APNG", echo, stderr);



  stderr = ["APNG list is empty!"];
  DOMwriter = newcell("🦦 -(Merge)", "250px");
  loadapng = fileup("Load APNG or GIF");
  moreapng = fileup("Load more");
  apnglist = editcell("Edit list to rearrange, repeat, or skip APNG series.");
  mergeapng = button("previous", "Merge APNG", echo, stderr);
  echoapng = button("previous", "APNG to Canvas", echo, stderr);



  DOMwriter = newcell("🦦 -(Layers)", "250px");
  layerlist = editcell("Edit list to rearrange, repeat, or skip layers.");
  echolayers = button("previous", "Layers to Canvas", echo, ["Layer list is empty!"]);
  makepng = button("previous", "Make PNG", echo, ["No suitable canvas found!"]);



  new_stdout();



  loaded();
  lazyload();
  //document.addEventListener("click", Expander);
  if (sharp[1]) {
    newtip(filel[4] + " -(Uninitiated CSS)", "Download and extract \"" + sharp[0] + "\" (if that's spelled correctly) from <a href='https://highlightjs.org/download/' target='_blank'>highlight.js download page</a> directly next to HTML then reload this page");
  }
}

</script></head><body class="exitmenu">1. Set up and run Schande.bat for its HTTP server from <a href="https://github.com/Rukario/Schande">https://github.com/Rukario/Schande</a><br>
2. Take me to Schande.bat, then launch <a href="http://127.0.0.1:8886/APNG Maker.html">http://127.0.0.1:8886/APNG Maker.html</a></body></html>
