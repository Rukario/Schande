<!DOCTYPE html>
<html>
<meta charset="UTF-8">
<meta name="format-detection" content="telephone=no">
<title>Make APNG</title>
<head><style>
html,body {caret-color:#ff8228; font-family:courier; font-size:14px; margin-bottom:-2px; padding-top:2px; padding:2px;}
[contenteditable]:focus {outline: none;}
#getfps:focus {outline:none;}
a {color:#ff9449;}
a:visited {color:#ffc66d;}
.frame{display:inline-block; vertical-align:top; position:relative;}
input[type="file"] {display:none;}
::placeholder{color:#3cb;}
.next{background-color:#066; color:#6fe; border:1px solid #033}
.previous{background-color:#4bb; color:#133; border:1px solid #033}
.reverse{background-color:#428; color:#d9f; border:1px solid #214}
.inverse{background-color:#d9f; color:#428; border:1px solid #214}
.aczo {font-family:courier; font-size:12px; border:none; border-top:1px solid #033; border-bottom:1px solid #033; margin:-4px 2px; bottom:4px; padding:8px 5px 9px; text-align:center; width:34px; display:inline-block;
  clip-path: polygon(
14% 12%,
50% 0%,
86% 12%,
100% 68%,
82% 100%,
18% 100%,
0% 68%
);
}
.aczo28 {bottom:5px; padding:10px 7px 11px; width:44px;}
.tooltip {display:none; position:absolute; margin-top:37px; white-space:initial; background-color:inherit; padding:2px 8px; font-family:sans-serif; font-size:90%; max-width:calc(100% - 36px); line-height:1.1; z-index:9999999; left:0px; top:0px; right:initial;}
.menu {color:#9b859d; background-color:#110c13;}
.exitmenu {color:#f45; background-color:#2d0710;}
.cursor_tooltip{position:absolute; left:0px; top:0px; right:initial; display:none;}
.backtip {cursor:default; position:relative; display:inline-block; line-height:1.1; font-size:12px; padding:5px 12px;}
.backtip::before {content:''; position:absolute; left:0; top:0; z-index:1; border:1px solid #ffffff; background:transparent; mix-blend-mode:overlay; width:calc(100% - 2px); height:calc(100% - 2px); pointer-events:none;}
.backtip {background:inherit; z-index:1;}
.local_tooltip {z-index:2; display:inline-block; color:inherit; cursor:default; padding:6px 11px 4px; margin:1px;}
.previous, .reverse, .inverse, .next {border-radius:0px; cursor:pointer; font-size:12px; padding:4px 11px; font-family:Arial; margin:6px 0px;}
.cell {width:352px; vertical-align:text-top; font-size:14px;}
.cell::before {border:2px solid rgba(255, 255, 255, 0.75); width:calc(100% - 4px); height:calc(100% - 4px);}
.stdout {white-space:pre; line-height:1.1; color:#9b859d; background-color:#110c13; border:2px solid #221926; display:inline-block; padding:6px; margin-top:12px;}

input[type="range"] {
  position:relative;
  top:6px;
  -webkit-appearance: none;
  appearance: none;
  height: 4px;
  background: #066;
  outline: none;
  border:8px solid transparent;
  background-clip: padding-box; box-shadow:inset 0 0 0 4px #066;
  opacity: 0.7;
  -webkit-transition: .2s;
  transition: opacity .2s;
  cursor: pointer;
}

input[type="range"]:hover {
  opacity: 1;
}

input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 12px;
  border-radius: 0px;
  height: 12px;
  background: #4bb;
  border:none;
}

input[type="range"]::-moz-range-thumb {
  border-radius: 0px;
  width: 12px;
  height: 12px;
  background: #4bb;
  border:none;
}

.ogv-current{position:relative;display:inline-block;text-align:center;min-height:16px}
.ogv-current:not(.ogv-detached)::before{content:'Loading…';position:absolute;top:8px;left:0;font-weight:700}
.ogv-current.ogv-loaded::before{display:none}
.ogv-current>ogvjs{position:initial!important}
.ogv-ctrl{position:absolute;bottom:0;z-index:2;background:rgba(0,0,0,.65);width:100%;height:32px;gap:0;display:none}
.ogv-btn{cursor: pointer;width:32px;height:32px;line-height:32px;text-align:center;color:#fff}
.ogv-btn div{vertical-align:middle}
.ogv-btn div:last-child{display:none}
.ogv-btn.ogv-toggled div:first-child{display:none}
.ogv-btn.ogv-toggled div:last-child{display:inline}
.ogv-ts{font-family:sans-serif;font-size:10px;text-align:center;line-height:32px;width:70px;color:#fff;overflow:hidden}
.ogv-vol{width:50px;margin:0}
.ogv-seek{width:0;margin:0;flex-grow:1}
</style>
<script>
function getfontcolor(c, v){
  if(c[0] >= "cc" && c[1] >= "cc" && c[2] >= "cc"){
    return ".exitmenu{background-color:#" + v + "; color:#586e75;}"
  } else if(c[0] >= "99" || c[1] >= "99" || c[2] >= "99"){
    return ".exitmenu{background-color:#" + v + "; color:#000;}"
  } else if(c[0] >= "20" && c[1] >= "10" && c[2] >= "10"){
    return ".exitmenu{background-color:#" + v + "; color:#93a1a1;}"
  } else if(c[0] >= "20" && c[1] >= "07" && c[2] >= "07"){/* red */
    return ".exitmenu{background-color:#" + v + "; color:#f45;}"
  } else {
    return ".exitmenu{background-color:#" + v + "; color:#fff;}"
  }
}
var sharp = [false, false];
if(window.location.href.includes("#")){
  sharp[0] = window.location.href.split('#')[1]
}
if (sharp[0]){
  if(sharp[0].endsWith(".css")){
    var link = document.createElement("link");
    link.href = sharp[0];
    link.rel = "stylesheet"
    document.getElementsByTagName("head")[0].appendChild(link);
    link.onerror = () => {
      sharp[1] = true;
    }
  } else {
    var s = document.createElement("style")
    s.innerHTML = getfontcolor(sharp[0].match(/.{1,2}/g), sharp[0]);
    document.getElementsByTagName("head")[0].appendChild(s)
  }
} else {
  var a = document.createElement("a");
  a.href = "#2d0710";
  a.click()
}
var FFdown = function(e) {
  var t = e.target;
  var a = t.parentNode;
  if (t.hasAttribute("data-tooltip")) {
    tooltip.style.display = "inline-block";
    tooltip.innerHTML = t.getAttribute("data-tooltip");
    let left = () => {
      setTimeout(function(){
        tooltip.style.display = "none";
      }, 1250)
      a.removeEventListener("mouseleave", left);
    }
    a.addEventListener("mouseleave", left);
  }
}

document.addEventListener("click", FFdown);

function plaintext(elem, e) {
  e.preventDefault();
  var text = e.clipboardData.getData('text/plain').replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  document.execCommand('insertHTML', false, text);
}

function quicklook(e) {
  if(e.target.classList.contains("lazy")) {
    e.preventDefault();
    var t = e.target;
    var c = {};

    var m = new Image();
    m.src = t.parentNode.getAttribute("href");
    var s = new Image();
    s.src = t.parentNode.parentNode.parentNode.childNodes[1].childNodes[0].getAttribute("href");

    c = document.createElement("canvas");
    get_dim(m, 3);
    context = c.getContext("2d");
    c.width = dim[3][2];
    c.height = dim[3][3];

    if(s.src == m.src) {
      context.fillRect(...dim[3]);
    } else {
      m.onload = function () {
        fps = 1
        //s.onload = apngdiff(m, s);
        s.onload = canvasdiff(m, s);
      }
    }

    //c = document.createElement("img");
    //c.setAttribute("src", t.parentNode.getAttribute("href"));

    c.style = cs;
    c.setAttribute("id", "quicklook");
    t.parentNode.appendChild(c);

    let listener = () => {
      setTimeout(function(){t.parentNode.removeChild(c);}, 40);
      t.removeEventListener("mouseleave", listener);
    }
    t.addEventListener("mouseleave", listener);
  }
}

document.addEventListener("mouseover", quicklook);

var co = "position:fixed; right:0; top:0; z-index:1; pointer-events:none;"
var cf = co + "max-height: 100vh; max-width: 100vw;";
var cs = cf

function lazyload() {
  var lazyloadImages;

  lazyloadImages = document.querySelectorAll(".lazy");
  var imageObserver = new IntersectionObserver(function(entries, observer) {
    entries.forEach(function(entry) {
      if (entry.isIntersecting) {
        var image = entry.target;
        image.src = image.dataset.src;
        imageObserver.unobserve(image);
      }
    });
  });

  lazyloadImages.forEach(function(image) {
    image.style.height = "200px"
    image.style.width = "auto"
    imageObserver.observe(image);
  });
}

var Expand = function(c, t) {
  if(!c.naturalWidth)
  {
    return setTimeout(Expand, 10, c, t);
  }
  c.style.maxWidth = "100%";
  c.style.display = "";
  t.style.display = "none";
  t.style.opacity = "";
};

var Expander = function(e) {
  var t = e.target;
  if(t.parentNode.classList.contains("fileThumb")) {
    e.preventDefault();
    if(t.hasAttribute("data-src")) {
      var c = document.createElement("img");
      c.setAttribute("src", t.parentNode.getAttribute("href"));
      c.style.display = "none";
      t.parentNode.appendChild(c);
      t.style.opacity = "0.75";
      setTimeout(Expand, 10, c, t);
    } else {
      var a = t.parentNode;
      a.firstChild.style.display = "";
      a.removeChild(t);
      a.offsetTop < window.pageYOffset && a.scrollIntoView({top: 0, behavior: "smooth"});
    }
  }
};

function get_ext(f) {
  var fp = f.name.split('.');
  return fp[fp.length - 1];
}

function isImage(ext) {
  switch (ext.toLowerCase()) {
    case 'jpg':
    case 'jpeg':
    case 'gif':
    case 'bmp':
    case 'png':
      return true;
    case 'heic':
      return 'heic';
  }
  return false;
}

function isVideo(ext) {
  switch (ext.toLowerCase()) {
    case 'm4v':
    case 'avi':
    case 'mpg':
    case 'mp4':
      return true;
    case 'webm':
      return 'webm';
  }
  return false;
}

function setfps(text) {
  if(isNaN(text)){
    getfps.style.backgroundColor = "#399"
    fps = 0;
  } else {
    if(0<text && text<=120){
      getfps.style.backgroundColor = "#066"
      fps = Number(text);
    } else {
      getfps.style.backgroundColor = "#399"
      fps = 0;
    }
  }
  if(!text){
    getfps.style.backgroundColor = "#066"
    fps = 0;
  }
}

function echo(B, b) {
  if (!b) B = "<br>" + B
  if (b) B = " " + B
  stdout.insertAdjacentHTML("beforeend", B);
}

function ABtoURL(ab){
  return URL.createObjectURL(new Blob(ab, {type: 'application/octet-stream'}));
}

function ABtoIMG(ab){
  img = document.createElement("img");
  img.src = ABtoURL(ab);
  return img;
}

function ABtoAB(ab){
  return [new Uint8Array(ab)]
}

function echoIMG(img, B){
  img.style = "max-height:400px;"
  const dl = document.createElement("a");
  dl.download = B;
  dl.href = img.src;
  dl.appendChild(img);
  stdout.insertAdjacentHTML("beforeend", "<br>");
  stdout.appendChild(dl);
}

function echoCanvas(){
  c.style = "max-height:400px;";
  stdout.insertAdjacentHTML("beforeend", "<br>");
  stdout.appendChild(c);
}

function echoABtoDL(ab, B){
  const dl = document.createElement("a");
  dl.href = ABtoURL(ABtoAB(ab));
  dl.download = B;
  dl.innerHTML = "<br>" + B;
  stdout.appendChild(dl);
}

function echoIMGfromCanvas(c, B=undefined, ext='png') {
  var promise = new Promise(canvasToAB(c, ext))
  promise.then(function(arri){
    echoIMG(ABtoIMG(ABtoAB(arri)), B)
  })
}

function echoHEIC(image, B) {
  c = document.createElement("canvas");
  c.width = image.get_width();
  c.height = image.get_height();
  context = c.getContext("2d");
  image.display(context.createImageData(c.width, c.height), function(display_image_data) {
    context.putImageData(display_image_data, 0, 0);
    echoIMGfromCanvas(c, B, 'jpeg');
  });
};

function echoPalette(h=8, s=1){
  palette.sort();
  var c2 = document.createElement("canvas");
  var context2 = c2.getContext("2d");
  var w = Math.ceil(palette.length/h)
  c2.width = w*s;
  c2.height = h*s;

  img = context2.createImageData(w, h);
  var d = img.data;
  for(var i=0;i<palette.length;i++){
    d[i*4] = parseInt(palette[i].slice(0, 2), 16);
    d[i*4+1] = parseInt(palette[i].slice(2, 4), 16);
    d[i*4+2] = parseInt(palette[i].slice(4, 6), 16);
    d[i*4+3] = 255;
  }
  context2.putImageData(img, 0, 0);

  var c3 = document.createElement("canvas");
  var context3 = c3.getContext("2d");
  c3.width = c2.width;
  c3.height = c2.height;

  context3.imageSmoothingEnabled = false;
  context3.scale(s, s)
  context3.drawImage(c2, 0, 0, c3.width, c3.height, 0, 0, c2.width, c2.height);
  echoIMGfromCanvas(c3);
  palette = [];
}

function canvasToAB(c, ext="png", callback=false){
  return function(resolve) {
    c.toBlob((blob0) => {
      var fr = new FileReader();
      fr.readAsArrayBuffer(blob0);
      fr.onload = () => {
        arri = new Uint8Array(fr.result);
        Module = {};
        ti[2] = performance.now()
        //echo((ti[2] - ti[1])/1000 + "s canvasToAB(c)")
        ti[1] = performance.now()
        if(ext == "png" && optimize){
          //https://manpages.debian.org/stretch/optipng/optipng.1.en.html
          if(callback){
            //Ideal settings for apng production
            arri = optipng(arri, ['-force', '-zw', '32k', '-f', '0', '-zs', '0', '-zm', '8', '-zc', '9', '-nx', '-strip', 'all']).data;
          } else {
            arri = optipng(arri, ['-force', '-zw', '32k', '-f', '0', '-zs', '0', '-zm', '8', '-zc', '9', '-strip', 'all']).data;
          }
        }
        ti[2] = performance.now()
        //echo((ti[2] - ti[1])/1000 + "s OptiPNG")
        resolve(arri);
      };
    }, 'image/' + ext);
  }
}

function fullres(i) {
  dim[1] = [...dim[i]];
  dimension.innerHTML = dim[1][2] + " &times; " + dim[1][3];
}

function bigres(i) {
  //sets max dimension, divide by 2 when exceeded, increment division times when 2 isn't enough
  var len = Math.ceil(dim[i][2] / 4000)
  var leny = Math.ceil(dim[i][3] / 4000)
  if (leny > len) len = leny;
  dim[1] = [0, 0, Math.floor(dim[i][2] / len), Math.floor(dim[i][3] / len)]
  dimension.innerHTML = dim[1][2] + " &times; " + dim[1][3];
  if (len > 1){
    dimension.innerHTML += " <div class='backtip' onclick='fullres(" + i + ")'>use original</div>"
  }
}

function get_dim(image, i) {
  dim[i] = [0, 0, image.width, image.height];
}

function ABtoFrame(arri, callback, interFrameN, fpsm=1, callback2=false, filler=false){
  ti[1] = performance.now()
  arri = Array.from(arri);
  newframe.arri = arri;
  ti[2] = performance.now()
  //echo((ti[2] - ti[1])/1000 + "s ArrayBuffer")
  if(callback == undefined){
    ti[3] = performance.now()
    echo("Frame " + (interFrameN+1) + " in " + (ti[3] - ti[0])/1000 + "s")
    document.title = "Frame " + (interFrameN+1);
    echoIMG(ABtoIMG(ABtoAB(arri)), name)
    if (callback2){
      callback2(interFrameN + nextFrame)
    } else {
      document.title = "Make APNG";
      setfps(getfps.value);
    }
  } else if(interFrameN == undefined){
    document.title = "Make APNG";
    //echoIMG(ABtoIMG(ABtoAB(arri)), "Resave as" + ".png");
    toFrame([1000, 1000]);
    callback(0, callback2);
  } else {
    if (filler){
      echo("APNGified")
    } else {
      echo("Frame " + (interFrameN+1));
      document.title = "Frame " + (interFrameN+1);
      if(interecho){
        echoIMG(ABtoIMG(ABtoAB(arri)), "Frame " + (interFrameN+1) + ".png");
      }
    }
    toFrame([1000/(fps/fpsm), 1000]);
    callback(interFrameN + nextFrame, callback2);
  }
}

function canvasToFrame(callback, interFrameN, fpsm=1, callback2=false, filler=false){
  ti[1] = performance.now()
  let promise = new Promise(canvasToAB(c, 'png', callback))
  promise.then(function(arri){
    ABtoFrame(arri, callback, interFrameN, fpsm, callback2, filler)
  })
}

function Convolute(pixels, weights) {
  var side = Math.round(Math.sqrt(weights.length));
  var halfSide = Math.floor(side/2);

  var src = pixels.data;
  var sw = pixels.width;
  var sh = pixels.height;

  var w = sw;
  var h = sh;
  var f = document.createElement('canvas').getContext('2d');
  var output = f.createImageData(w, h);
  var dst = output.data;

  for (var y=0; y<h; y++) {
    for (var x=0; x<w; x++) {
      var sy = y;
      var sx = x;
      var dstOff = (y*w+x)*4;
      var r=0, g=0, b=0, a=0;
      for (var cy=0; cy<side; cy++) {
        for (var cx=0; cx<side; cx++) {
          var scy = Math.min(sh-1, Math.max(0, sy + cy - halfSide));
          var scx = Math.min(sw-1, Math.max(0, sx + cx - halfSide));
          var srcOff = (scy*sw+scx)*4;
          var wt = weights[cy*side+cx];
          r += src[srcOff] * wt;
          g += src[srcOff+1] * wt;
          b += src[srcOff+2] * wt;
          a += src[srcOff+3] * wt;
        }
      }
      dst[dstOff] = r;
      dst[dstOff+1] = g;
      dst[dstOff+2] = b;
      dst[dstOff+3] = 255;
    }
  }
  return output;
}

function edge(m) {
  ti[0] = performance.now();
  ti[1] = performance.now();
  if(bg){
    context.drawImage(bg, ...dim[1]);
  }
  context.drawImage(m, ...dim[1]);
  context.putImageData(Convolute(context.getImageData(...dim[1]), [-1, -1, -1, -1,  8, -1, -1, -1, -1]), 0, 0);
  fps = 1;
  canvasToFrame(staticAPNG, -2, 1)
}

function contour(a) {
  var r = [32, 64, 128, 160, 192, 224]
  var g = [8, 16, 32, 64, 128, 192]
  var b = [96, 128, 160, 192, 224, 240]
  /*var r = [32, 64, 112, 144, 176, 208]*/

  /*for (var i = 0; i < 6; i++) {
    var rgba = (00 + r[i].toString(16)).slice(-2) + (00 + g[i].toString(16)).slice(-2) + (00 + b[i].toString(16)).slice(-2);
    palette.push(rgba);
  }
  echoPalette(6, 4)*/

  for (var i = 0; i < a.length; i += 4) {
    a[i+3] = 255;
    if(a[i] == 0 && a[i+1] == 0 && a[i+2] == 0){
      a[i] = 0;
      a[i+1] = 0;
      a[i+2] = 0;
    } else if(a[i] > 12 || a[i+1] > 12 || a[i+2] > 12){
      a[i] = 255;
      a[i+1] = 255;
      a[i+2] = 255;
    } else if(a[i] > 10 || a[i+1] > 10 || a[i+2] > 10){
      a[i] = r[5];
      a[i+1] = g[5];
      a[i+2] = b[5];
    } else if(a[i] > 8 || a[i+1] > 8 || a[i+2] > 8){
      a[i] = r[4];
      a[i+1] = g[4];
      a[i+2] = b[4];
    } else if(a[i] > 6 || a[i+1] > 6 || a[i+2] > 6){
      a[i] = r[3];
      a[i+1] = g[3];
      a[i+2] = b[3];
    } else if(a[i] > 4 || a[i+1] > 4 || a[i+2] > 4){
      a[i] = r[2];
      a[i+1] = g[2];
      a[i+2] = b[2];
    } else if(a[i] > 2 || a[i+1] > 2 || a[i+2] > 2){
      a[i] = r[1];
      a[i+1] = g[1];
      a[i+2] = b[1];
    } else if(a[i] > 0 || a[i+1] > 0 || a[i+2] > 0){
      a[i] = r[0];
      a[i+1] = g[0];
      a[i+2] = b[0];
    };
  }
}

function detect() {
  seqFrameN = framelist.innerHTML.split("\n").filter(function(el) { return el; })
  c.width = dim[1][2];
  c.height = dim[1][3];
  dim[3] = [...dim[1]]
  if(seqFrameN.length > 1) {
    if(fps == 0){
      echo("Bad FPS")
    } else {
      apngdiff(framearray[seqFrameN[0]-1][0], framearray[seqFrameN[1]-1][0], ((3==seqFrameN.length)?framearray[seqFrameN[2]-1][0]:false));
    }
  } else {
    edge(framearray[seqFrameN[0]-1][0]);
  }
}

var palette = [];
function frame_diff(a, b, i) {
  var d = {x:[], y:[]};
  for(var y=0;y<dim[i][3];y++){
    var o = (y+1)*dim[i][2]
    for(var x=(o-dim[i][2])*4;x<o*4;x+=4){
      if(b[x+3] !== 0 && a[x+3] == 255 && a[x] == b[x] && a[x+1] == b[x+1] && a[x+2] == b[x+2]){
        b[x+3] = 0;
      } else {
        d.x.push((x/4)+dim[i][2]-o);
        d.y.push(y);
        //var rgba = (00 + b[x].toString(16)).slice(-2) + (00 + b[x+1].toString(16)).slice(-2) + (00 + b[x+2].toString(16)).slice(-2);
        //if(palette.indexOf(rgba)<0){palette.push(rgba);}
        //evil: indexOf, toString(16), pad zeros
        //reverse with parseInt(hexString, 16)
      }
    }
  }
  d.x.sort((a,b) => a-b);
  d.y.sort((a,b) => a-b);
  dim[3] = [d.x[0], d.y[0], d.x[d.x.length-1]-d.x[0]+1, d.y[d.y.length-1]-d.y[0]+1];
}

function draw(x, i) {
  ti[0] = performance.now()
  ti[1] = performance.now()
  c.width = dim[1][2];
  c.height = dim[1][3];
  if(bg){
    context.drawImage(bg, ...dim[1]);
  }
  context.drawImage(x, ...dim[1]);
  frameBuffer[i] = context.getImageData(...dim[1]);
}

function difference(a, b) {
  let d = frameBuffer[b].data;
  let e = frameBuffer[a].data;
  for (let i = 0; i < d.length; i += 4) {
    d[i] = Math.abs(d[i] - e[i]);
    d[i+1] = Math.abs(d[i+1] - e[i+1]);
    d[i+2] = Math.abs(d[i+2] - e[i+2]);
  }
  contour(d);
  context.putImageData(frameBuffer[b], 0, 0);
}

function subtract(a, b) {
  let d = frameBuffer[b].data;
  let e = frameBuffer[a].data;
  for (let i = 0; i < d.length; i += 4) {
    d[i] -= e[i];
    d[i+1] -= e[i+1];
    d[i+2] -= e[i+2];
  }
  contour(d);
  context.putImageData(frameBuffer[b], 0, 0);
}

function cropdiff(a, b, end){
  frame_diff(frameBuffer[a].data, frameBuffer[b].data, 1)
  if(!end){
    frameBuffer[0] = context.getImageData(...dim[1]);
  }
  context.putImageData(frameBuffer[b], 0, 0);
  crop()
}

function apngdiff(m, s, s2=false) {
  draw(m, 1);
  canvasToFrame(f2, 0);
  let reuse = [false, false, false, false];

  function f1(){
    if(s2){
      reuse[1] = newframe.arri
      reuse[3] = dim[3]
    } else {
      reuse[0] = newframe.arri
      reuse[2] = dim[3]
    }
    draw(m, 2);
    cropdiff(0, 2, true);
    canvasToFrame(r2, 0);
  }

  function f2(){
    draw(s, 2);
    cropdiff(1, 2);
    canvasToFrame((s2?f3:f1), 1);
  }

  function f3(){
    reuse[0] = newframe.arri
    reuse[2] = dim[3]
    draw(s2, 2);
    cropdiff(0, 2);
    canvasToFrame(f1, 2);
  }

  function r2(){
    ti[0] = performance.now()
    ti[1] = performance.now()
    dim[3] = reuse[2]
    ABtoFrame(reuse[0], (s2?r3:d1), 1)
  }

  function r3(){
    ti[0] = performance.now()
    ti[1] = performance.now()
    dim[3] = reuse[3]
    ABtoFrame(reuse[1], d1, 2)
  }

  function d1(){
    draw(s, 2);
    subtract(1, 2);
    cropdiff(0, 2);
    canvasToFrame(d2, -2);
  }
  
  function d2(){
    draw(s, 2);
    difference(1, 2);
    cropdiff(0, 2);
    canvasToFrame((s2?d3:d6), -2.5);
  }

  function d3(){
    draw(s, 2);
    draw(s2, 3);
    subtract(2, 3);
    cropdiff(0, 3);
    canvasToFrame(d4, -3);
  }

  function d4(){
    draw(s2, 3);
    difference(2, 3);
    cropdiff(0, 3);
    canvasToFrame(d5, -3.5);
  }

  function d5(){
    draw(s2, 3);
    subtract(1, 3);
    cropdiff(0, 3);
    canvasToFrame(d6, -4);
  }

  function d6(){
    if(s2){
      draw(s2, 3);
      difference(3, 1);
    } else {
      draw(s, 2);
      subtract(2, 1);
    }
    cropdiff(0, 1, true)
    canvasToFrame(makeAPNG, (s2?-4.5:-3));
  }
}

function canvasdiff(m, s) {
  context.drawImage(m, ...dim[1])
  frameBuffer[0] = context.getImageData(...dim[1]);
  setTimeout(function() {
    context.drawImage(s, ...dim[1])
    frameBuffer[1] = context.getImageData(...dim[1]);
    subtract(frameBuffer[0].data, frameBuffer[1]);
    setTimeout(function() {
      context.putImageData(frameBuffer[1], 0, 0);
      setTimeout(function() {
        context.drawImage(s, ...dim[1]);
        frameBuffer[1] = context.getImageData(...dim[1]);
        difference(frameBuffer[0].data, frameBuffer[1]);
        context.putImageData(frameBuffer[1], 0, 0);
        setTimeout(function() {
          context.drawImage(s, ...dim[1]);
          frameBuffer[1] = context.getImageData(...dim[1]);
          subtract(frameBuffer[1].data, frameBuffer[0]);
          context.putImageData(frameBuffer[0], 0, 0);
          setTimeout(function() {
            requestAnimationFrame(canvasdiff(m, s));
          }, 1000/fps);
        }, 1000/fps);
      }, 1000/fps);
    }, 1000/fps);
  }, 1000/fps);
}



function APNG() {
  this.width = 0;
  this.height = 0;
  this.numPlays = 0;
  this.playTime = 0;
  this.frames = [];
  this.arri = new Array(0);
}

function Frame() {
  this.left = 0;
  this.top = 0;
  this.width = 0;
  this.height = 0;
  this.numerator = 0;
  this.denominator = 0;
  this.disposeOp = 0;
  this.blendOp = 0;
  this.arri = new Array(0);
  this.IDATs = [];
}

function findPos(ab, type) {
  let offset = 8;
  while (offset < ab.length) {
    let len = ABtoInt32(ab.slice(offset, offset + 4));
    if (readString(ab.slice(offset + 4, offset + 8)) === type) {
      return new Chunk(offset, len, type);
    }
    offset += 4 + 4 + len + 4;
  }
}

function Chunk(offset, len, type) {
  this.offset = offset;
  this.len = len;
  this.type = type;
}



const rechk = /^([<>])?(([1-9]\d*)?([xcbB?hHiIfdsp]))*$/
const refmt = /([1-9]\d*)?([xcbB?hHiIfdsp])/g
const str = (v,o,c) => String.fromCharCode(...new Uint8Array(v.buffer, v.byteOffset + o, c))
const rts = (v,o,c,s) => new Uint8Array(v.buffer, v.byteOffset + o, c).set(s.split('').map(str => str.charCodeAt(0)))
const pst = (v,o,c) => str(v, o + 1, Math.min(v.getUint8(o), c - 1))
const tsp = (v,o,c,s) => { v.setUint8(o, s.length); rts(v, o + 1, c - 1, s) }
const lut = le => ({
  x: c=>[1,c,0],
  c: c=>[c,1,o=>({u:v=>str(v, o, 1)      , p:(v,c)=>rts(v, o, 1, c)     })],
  '?': c=>[c,1,o=>({u:v=>Boolean(v.getUint8(o)),p:(v,B)=>v.setUint8(o,B)})],
  b: c=>[c,1,o=>({u:v=>v.getInt8(   o   ), p:(v,b)=>v.setInt8(   o,b   )})],
  B: c=>[c,1,o=>({u:v=>v.getUint8(  o   ), p:(v,B)=>v.setUint8(  o,B   )})],
  h: c=>[c,2,o=>({u:v=>v.getInt16(  o,le), p:(v,h)=>v.setInt16(  o,h,le)})],
  H: c=>[c,2,o=>({u:v=>v.getUint16( o,le), p:(v,H)=>v.setUint16( o,H,le)})],
  i: c=>[c,4,o=>({u:v=>v.getInt32(  o,le), p:(v,i)=>v.setInt32(  o,i,le)})],
  I: c=>[c,4,o=>({u:v=>v.getUint32( o,le), p:(v,I)=>v.setUint32( o,I,le)})],
  f: c=>[c,4,o=>({u:v=>v.getFloat32(o,le), p:(v,f)=>v.setFloat32(o,f,le)})],
  d: c=>[c,8,o=>({u:v=>v.getFloat64(o,le), p:(v,d)=>v.setFloat64(o,d,le)})],
  s: c=>[1,c,o=>({u:v=>str(v,o,c), p:(v,s)=>rts(v,o,c,s.slice(0,c    ) )})],
  p: c=>[1,c,o=>({u:v=>pst(v,o,c), p:(v,s)=>tsp(v,o,c,s.slice(0,c - 1) )})]
})
const errbuf = new RangeError("Structure larger than remaining buffer")
const errval = new RangeError("Not enough values for structure")
function struct(format) {
  let fns = [], size = 0, m = rechk.exec(format)
  if (!m) { throw new RangeError("Invalid format string") }
  const t = lut('<' === m[1]), lu = (n, c) => t[c](n ? parseInt(n, 10) : 1)
  while ((m = refmt.exec(format))) { ((r, s, f) => {
    for (let i = 0; i < r; ++i, size += s) { if (f) {fns.push(f(size))} }
  })(...lu(...m.slice(1)))}
  const unpack_from = (arrb, offs) => {
    if (arrb.byteLength < (offs|0) + size) { throw errbuf }
    let v = new DataView(arrb, offs|0)
    return fns.map(f => f.u(v))
  }
  const pack_into = (arrb, offs, ...values) => {
    if (values.length < fns.length) { throw errval }
    if (arrb.byteLength < offs + size) { throw errbuf }
    const v = new DataView(arrb, offs)
    new Uint8Array(arrb, offs, size).fill(0)
    fns.forEach((f, i) => f.p(v, values[i]))
  }
  const pack = (...values) => {
    let b = new ArrayBuffer(size)
    pack_into(b, 0, ...values)
    return b
  }
  const unpack = arrb => unpack_from(arrb, 0)
  function* iter_unpack(arrb) { 
    for (let offs = 0; offs + size <= arrb.byteLength; offs += size) {
      yield unpack_from(arrb, offs);
    }
  }
  return Object.freeze({
    unpack, pack, unpack_from, pack_into, iter_unpack, format, size})
}

function mod(n, m) {
  return ((n % m) + m) % m;
}

const TMDIPack = struct("<7sxIII");
const PAC_MAX_NAME = 64;
const PAC_RESERVED = 48;
const TPackerHeader = struct(`<4sIIII${PAC_RESERVED}x${PAC_MAX_NAME}s`);
const HeaderStruct = struct("<IIII");
const PAC = struct('<I');

function echoMDP(arri) {
  if (!decompress) {
    stdout.insertAdjacentHTML("beforeend", 'Please try again with <a href="https://github.com/nodeca/pako/blob/master/dist/" target="_blank">pako_inflate.min.js</a>, save next to HTML then reload this page');
    return;
  }

  const offset1 = TMDIPack.size;
  const offset2 = TPackerHeader.size;
  const offset3 = HeaderStruct.size;

  let part = arri.subarray(0, offset1);
  const [signature, version, mdiSize, mdibinSize] = TMDIPack.unpack(arri.buffer.slice(0, offset1));
  const mdiBytes = arri.subarray(offset1, offset1 + mdiSize);
  const El = readString(mdiBytes);
  //console.log(El);

  const parser = new DOMParser();
  const xmlDoc = parser.parseFromString(El, "text/xml");
  const Mdiapp = xmlDoc.getElementsByTagName("Mdiapp")[0];
  const w = Mdiapp.getAttribute("width");
  const h = Mdiapp.getAttribute("height");

  const layers = [];
  const e = Mdiapp.getElementsByTagName("Layers")[0].getElementsByTagName("Layer");
  for (const layer of e) {
    layers.push(layer);
  }

  const mdp_mdibin = {};
  let dl = 0;
  let pos = offset1 + mdiSize;
  while (dl < mdibinSize) {
    let [signature, chunkSize, streamType, streamSize, archiveSize, archiveName] = TPackerHeader.unpack(arri.buffer.slice(pos, pos + offset2));
    pos += offset2;
    archiveName = archiveName.replace(/\0/g, '');
    // console.log(streamType, archiveName);

    let archiveData = new Uint8Array(arri.buffer.slice(pos, pos + streamSize));
    pos += streamSize;

    if (streamType === 0) { // nude
      //Will decompress later
    } else if (streamType === 1) { // zlib
      //A thumbnail, decompress now
      archiveData = pako.inflate(archiveData);
      //bufsize=archiveSize
    } else {
      console.log(`Unknown streamType Code: ${streamType}`);
    }
    mdp_mdibin[archiveName] = archiveData;
    dl += chunkSize;
  }

  for (const layer of layers) {
    pos = 0;
    const archiveData = mdp_mdibin[layer.getAttribute("bin")];
    const tileNum = PAC.unpack(archiveData.buffer.slice(pos, pos + 4))[0];
    pos += 4;

    if (!tileNum) {
      continue;
    }

    const dim = PAC.unpack(archiveData.buffer.slice(pos, pos + 4))[0];
    pos += 4;

    layer.tiles = [];
    for (const n of Array(tileNum).keys()) {
      const header = archiveData.buffer.slice(pos, pos + offset3);
      pos += offset3;
      const [x, y, ctype, size] = HeaderStruct.unpack(header);
      const data = archiveData.buffer.slice(pos, pos + size);
      pos += size;

      // Byte Alignment
      // archiveData.seek((4-size)%4, 1);
      pos += mod(4-size, 4);

      //console.log(x, y, ctype, size, Math.abs((4-size)%4));

      if (ctype) {
        console.log("Unknown Tile Compression Type:", ctype);
      }
      layer.tiles.push({"data":pako.inflate(data), "x":x*dim, "y":y*dim, "dim":dim});
    }
  }

  c.width = w;
  c.height = h;
  //echoCanvas();
  optimize = false;
  const tilemask = document.createElement("canvas");
  const tilemaskc = tilemask.getContext("2d");
  const canvas2 = document.createElement("canvas");
  const ctx2 = canvas2.getContext("2d");
  const mask = document.createElement("canvas");
  const maskcontext = mask.getContext("2d");
  canvas2.width = w;
  canvas2.height = h;
  mask.width = w;
  mask.height = h;
  let started = true;
  let usemode = "source-over";
  let usealpha = 1;
  for (const layer of layers) {
    const visible = layer.getAttribute('visible') == 'true' ? true : false;
    if (!visible) {
      continue;
    }

    const type = layer.getAttribute('type');
    if (type == '32bpp') {
      if (!started) {
        context.globalCompositeOperation = usemode;
        context.globalAlpha = usealpha;
        context.drawImage(canvas2, 0, 0, canvas2.width, canvas2.height);

        // reset
        ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
        context.globalCompositeOperation = "source-over";
        context.globalAlpha = 1;
      } else {
        started = false;
      }

      const mode = layer.getAttribute('mode');
      switch (mode) {
        case 'normal':
          usemode = "source-over";
          break;
        case 'mul':
          usemode = "multiply";
          break;
      }

      const alpha = layer.getAttribute('alpha');
      if (alpha) {
        usealpha = alpha/255;
      } else {
        usealpha = 1;
      }
    }

    for (const tile of layer.tiles) {
      tilemask.width = tile.dim;
      tilemask.height = tile.dim;
      const tilemap = tilemaskc.createImageData(tilemask.width, tilemask.height);
      const layerColor = layer.getAttribute('color');
      if (layerColor) {
        const [a, r, g, b] = [layerColor.substring(0, 2), layerColor.substring(2, 4), layerColor.substring(4, 6), layerColor.substring(6, 8)];
        tilemaskc.fillStyle = `#${r}${g}${b}${a}`;
        tilemaskc.fillRect(0, 0, tilemask.width, tilemask.height);
      }
      switch (type) {
        case '32bpp':
          for (let n = 0; n < tile.data.length; n += 4) {
            tilemap.data[n] = tile.data[n+2];
            tilemap.data[n+1] = tile.data[n+1];
            tilemap.data[n+2] = tile.data[n];
            tilemap.data[n+3] = tile.data[n+3];
          }
          tilemaskc.putImageData(tilemap, 0, 0);
          ctx2.drawImage(tilemask, tile.x, tile.y, tilemask.width, tilemask.height);
          break;
        case '8bpp':
        case '1bpp':
          for (let n = 0; n < tile.data.length*4; n += 4) {
            tilemap.data[n] = 0;
            tilemap.data[n+1] = 0;
            tilemap.data[n+2] = 0;
            tilemap.data[n+3] = tile.data[Math.ceil(n/4)];
          }
          tilemaskc.putImageData(tilemap, 0, 0);
          maskcontext.drawImage(tilemask, tile.x, tile.y, tilemask.width, tilemask.height);
          break;
      }
    }
    if (type == '8bpp') {
      maskcontext.globalCompositeOperation = "source-out";
      maskcontext.drawImage(canvas2, 0, 0, canvas2.width, canvas2.height);
      maskcontext.globalCompositeOperation = "source-over";
      ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
      ctx2.drawImage(mask, 0, 0, mask.width, mask.height);
      maskcontext.clearRect(0, 0, mask.width, mask.height);
    }
  }

  context.drawImage(canvas2, 0, 0, canvas2.width, canvas2.height);
  echoIMGfromCanvas(c, name.split('.').slice(0, -1).join('.') + ".png");
  return;
}



function fromAPNG(arri){
  let IHDR = null;
  let frame = null;
  let frameNumber = 0;
  const apng = new APNG();

  function inapng(type, arri, offset, length) {
    const dv = new DataView(arri.buffer);
    switch (type) {
      case 'IHDR':
        IHDR = arri.subarray(offset + 8, offset + 8 + length);
        apng.width = dv.getUint32(offset + 8);
        apng.height = dv.getUint32(offset + 12);
        break;
      case 'acTL':
        apng.numPlays = dv.getUint32(offset + 8 + 4);
        break;
      case 'fcTL':
        if (frame) {
          apng.frames.push(frame);
          frameNumber++;
        }
        frame = new Frame();
        frame.width = dv.getUint32(offset + 8 + 4);
        frame.height = dv.getUint32(offset + 8 + 8);
        frame.left = dv.getUint32(offset + 8 + 12);
        frame.top = dv.getUint32(offset + 8 + 16);
        frame.numerator = dv.getUint16(offset + 8 + 20);
        frame.denominator = dv.getUint16(offset + 8 + 22);
        apng.playTime += frame.delay;
        frame.disposeOp = dv.getUint8(offset + 8 + 24);
        frame.blendOp = dv.getUint8(offset + 8 + 25);
        if (frame.width > maxres[2]){
          maxres[2] = frame.width;
        }
        if (frame.height > maxres[3]){
          maxres[3] = frame.height;
        }
        if (frameNumber === 0 && frame.disposeOp === 2) {
          frame.disposeOp = 1;
        }
        break;
      case 'fdAT':
        if (frame) {
          frame.IDATs.push(arri.subarray(offset + 8 + 4, offset + 8 + length));
        }
        break;
      case 'IDAT':
        if (frame) {
          frame.IDATs.push(arri.subarray(offset + 8, offset + 8 + length));
        }
        break;
    }
  }

  eachChunk(arri, inapng)
  apng.frames.push(frame);

  apng.frames.forEach(function (frame) {
    var data = [];
    data.push(PNG_signature);
    IHDR.set(int32ToAB(frame.width), 0);
    IHDR.set(int32ToAB(frame.height), 4);
    data.push(makeChunkBytes('IHDR', IHDR));
    frame.IDATs.forEach(function (IDAT) {
        data.push(makeChunkBytes('IDAT', IDAT));
    });
    data.push(IEND);
    data.forEach(function (u){
       frame.arri = frame.arri.concat(Array.from(u))
    })
    frame.IDATs = [];
    data = [];
  });
  return apng;
}



function eachChunk(arri, callback) {
  const dv = new DataView(arri.buffer);
  let offset = 8;
  let type, arr;
  while (arr !== false && type != 'IEND' && offset < arri.length) {
    const len = dv.getUint32(offset);
    type = readString(arri.subarray(offset + 4, offset + 8));
    arr = callback(type, arri, offset, len);
    offset += 12 + len;
  };
}

function readString(arri) {
    //return new TextDecoder().decode(arri);
    return String.fromCharCode.apply(String, Array.prototype.slice.call(arri));
}

function utf8ToAB(utf8) {
  const len = utf8.length;
  const arr = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    arr[i] = utf8.charCodeAt(i);
  }
  return arr;
}

function makeChunkBytes(type, dataBytes) {
    const crc = type.length + dataBytes.length;
    const bytes = new Uint8Array(crc + 8);
    const dv = new DataView(bytes.buffer);

    dv.setUint32(0, dataBytes.length);
    bytes.set(utf8ToAB(type), 4);
    bytes.set(dataBytes, 8);
    dv.setUint32(crc + 4, crc32(bytes, 4, crc));
    return bytes;
};

function int32ToAB(int32) {
    return [int32 >>> 24 & 0xff, int32 >>> 16 & 0xff, int32 >>> 8 & 0xff, int32 & 0xff];
};

function ABtoInt32(ab) {
   return (ab[0] << 24) + (ab[1] << 12) + (ab[2] << 8) + ab[3];
}



var PNG_signature = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A];
var IEND = [0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82];
var newAPNG = [];
var newframe = new Frame();
var frame_counter = -1;
var sequence_number = -1;

function toFrame(fps, bp=[0, 1]) {
  ti[1] = performance.now()
  frame_counter += 1;

  if (!frame_counter) {
    let IHDR = findPos(newframe.arri, "IHDR");
    IHDR = newframe.arri.slice(IHDR.offset, IHDR.offset + 12 + IHDR.len)

    newAPNG.push(new Uint8Array(PNG_signature));
    newAPNG.push(new Uint8Array(IHDR)); //IHDR inherited
    newAPNG.push([]); //acTL reserved
  }

  var offset = 8;
  var IDATs = [];
  while (offset < newframe.arri.length) {
    var chunk = newframe.arri.slice(offset, offset + 4);
    var len = ABtoInt32(chunk);
    if (readString(newframe.arri.slice(offset + 4, offset + 8)) === "IDAT") {
      if(chunk[0]||chunk[1]){
        len = newframe.arri.length-8-25-12-12; //-PNG signature -IHDR -UNK -IEND
      }
      IDATs.push(new Chunk(offset, len, "IDAT"));
    }
    offset += 4 + 4 + len + 4;
  }
  //echo("IDATs: " + IDATs.length)

  for (var i = 0; i < IDATs.length; i++) {
    if (!i) {
      //echo(i + "th IDAT size: " + IDATs[i].len)
      sequence_number +=1;
      var fcTL = new Array(0);
      fcTL = fcTL.concat( int32ToAB(26) );
      fcTL = fcTL.concat([0x66, 0x63, 0x54, 0x4C]);
      fcTL = fcTL.concat( int32ToAB(sequence_number) );
      fcTL = fcTL.concat( int32ToAB(dim[3][2]) );
      fcTL = fcTL.concat( int32ToAB(dim[3][3]) );
      fcTL = fcTL.concat( int32ToAB(dim[3][0]) );
      fcTL = fcTL.concat( int32ToAB(dim[3][1]) );
      fcTL = fcTL.concat( int32ToAB(fps[0]).slice(-2) );
      fcTL = fcTL.concat( int32ToAB(fps[1]).slice(-2) );
      fcTL = fcTL.concat( bp ); //disposeOp and blendOp
      fcTL = fcTL.concat( int32ToAB(crc32(fcTL.slice(4, 4+4+26))) );
      newAPNG.push(new Uint8Array(fcTL));
    }

    var IDAT = IDATs[i];
    if (!frame_counter) {
      newAPNG.push(new Uint8Array(newframe.arri.slice(IDAT.offset, IDAT.offset + 12 + IDAT.len)))
    } else {
      var clean_IDAT = newframe.arri.slice(IDAT.offset + 8, IDAT.offset + 8 + IDAT.len);
      var len = IDAT.len + 4;

      sequence_number +=1;
      var fdAT = new Array(0);
      fdAT = fdAT.concat( int32ToAB(len) );
      fdAT = fdAT.concat( [0x66, 0x64, 0x41, 0x54] );
      fdAT = fdAT.concat( int32ToAB(sequence_number) );
      fdAT = fdAT.concat( clean_IDAT );
      fdAT = fdAT.concat( int32ToAB(crc32(fdAT.slice(4, 4 + 4 + len))) );
      newAPNG.push(new Uint8Array(fdAT));
    };
  }
  ti[2] = performance.now();
  //echo((ti[2] - ti[1])/1000 + "s toFrame()")
  ti[3] = performance.now();
  echo("in " + (ti[3] - ti[0])/1000 + "s", 1)
}

function makeAPNG(interFrameN, callback=false) {
  newAPNG.push(new Uint8Array(IEND));

  let acTL = new Array(0);
  acTL = acTL.concat([0, 0, 0, 0x08, 0x61, 0x63, 0x54, 0x4C])
  acTL = acTL.concat(int32ToAB(frame_counter + 1));
  acTL = acTL.concat([0, 0, 0, 0]) //loop times, infinity

  const crc = acTL.slice(4, 16);
  acTL = acTL.concat(int32ToAB(crc32(crc, crc.length)))
  newAPNG[2] = new Uint8Array(acTL);

  frame_counter = -1
  newframe = new Frame();
  sequence_number = -1

  //echoPalette();
  echoIMG(ABtoIMG(newAPNG), name.split('.').slice(0, -1).join('.') + " (apng).png");
  document.title = "Make APNG";
  setfps(getfps.value);
  newAPNG = [];
  if (callback){
    callback(interFrameN-1)
  }
}



var table = new Uint32Array(256);
for (let i = 0; i < 256; i++) {
  let x = i;
  for (let k = 0; k < 8; k++) {
    x = (x & 1) ? 0xEDB88320 ^ (x >>> 1) : x >>> 1;
  }
  table[i] = x;
}

function crc32(ab, start=0, len=0) {
  if (!len) {
    len = ab.length - start
  }

  let crc = -1;
  for (let i=start, l = start + len; i < l; i++) {
    crc = crc >>> 8 ^ table[(crc ^ ab[i]) & 0xFF];
  }
  return crc ^ -1;
}

function crop() {
  if(dim[3][0] == undefined){
    dim[3] = [0, 0, 1, 1];
    c.width = 1;
    c.height = 1;
    context.clearRect(...dim[3]);
  } else {
    let cropped = context.getImageData(...dim[3]);
    c.width = dim[3][2];
    c.height = dim[3][3];
    context.putImageData(cropped, 0, 0);
  }
}

function frameSaver(interFrameN, i) {
  ti[1] = performance.now()
  if(interFrameN == 0){
    frameBuffer[0] = context.getImageData(...dim[i]);
  } else {
    frameBuffer[1] = context.getImageData(...dim[i]);
    frame_diff(frameBuffer[0].data, frameBuffer[1].data, i)
    frameBuffer[0] = context.getImageData(...dim[i]);
    context.putImageData(frameBuffer[1], 0, 0);
    crop()
  }
  ti[2] = performance.now()
  //echo((ti[2] - ti[1])/1000 + "s frameSaver()")
}

function drawobj(x) {
  context.beginPath();
  for(let k=0;k < x.length;k++){
    if(k==0){
      context.moveTo(x[0][0], x[0][1]);
    } else{
      context.lineTo(x[k][0], x[k][1]);
    }
  }
  context.closePath();
  context.stroke();
  context.fill();
}

function noise() {
  frameBuffer[3] = context.getImageData(...dim[1]);
  let a = frameBuffer[3].data;
  for(let i=0;i < a.length;i += 4){
  	if (Math.random() < 0.5){
      a[i] = 32;
      a[i+1] = 8;
      a[i+2] = 96;
      a[i+3] = 255;
    }
  }
  context.putImageData(frameBuffer[3], 0, 0);
}

function randobg() {
  let s = 800;
  let t = 80;
  c.width = dim[1][2];
  c.height = dim[1][3];

  context.fillStyle = "#006600";
  context.fillRect(...dim[1]);
  //noise();
  context.fillStyle = "#229922";
  context.strokeStyle = "#33cc33";

  //var r = [32, 64,  128, 160, 192, 224]
  //var g = [8,  16,  32,  64,  128, 192]
  //var b = [96, 128, 160, 192, 224, 240]
  context.fillStyle = "#401080";
  context.fillRect(...dim[1]);
  //noise();
  context.fillStyle = "#8020A0";
  context.strokeStyle = "#A040C0";

  context.lineWidth = 40;

  for(let i=0;i < 5;i++){
    for(let j=0;j < 4;j++){
      drawobj([[100+Math.floor(Math.random()*t)+j*s, 350+Math.floor(Math.random()*t)+i*s], [200+Math.floor(Math.random()*t)+j*s, 200+Math.floor(Math.random()*t)+i*s], [300+Math.floor(Math.random()*t)+j*s, 350+Math.floor(Math.random()*t)+i*s]]);
    }
  }
}

function staticAPNG(interFrameN, callback=false) {
  ti[0] = performance.now()
  ti[1] = performance.now()

  dim[3] = [0, 0, 1, 1]
  c.width = 1;
  c.height = 1;
  //context.clearRect(...dim[3]);
  //randobg();
  canvasToFrame(makeAPNG, interFrameN-1, fpsm, callback, true);
}

var nextFrame = 1;
var firstFrame = true;
var fpsm = 1;
function compileframes(multi=true, dea=false) {
  newAPNG = [];
  seqFrameN = framelist.innerHTML.replace(/\<br\>/g, "\n").split("\n").filter(function(e){return e;})
  var lastFrameN;

  firstFrame = true;
  fpsm = 1;
  function updateFrame(interFrameN, fpsm){
    if(interFrameN+1 == seqFrameN.length){
      if(1 == seqFrameN.length){
        name = framearray[seqFrameN[interFrameN]-1][1];
        fps = 1;
        canvasToFrame(staticAPNG, 0, 1);
      } else {
        canvasToFrame(makeAPNG, interFrameN, fpsm);
      }
    } else {
      if(fps == 0){
        echo("Bad fps")
      } else {
        canvasToFrame(delayFrame, interFrameN, fpsm);
      }
    }
    ti[2] = performance.now()
    //echo((ti[2] - ti[1])/1000 + "s canvasing")
  }

  function readFrame(interFrameN, fpsm) {
    ti[0] = performance.now()
    ti[1] = performance.now()
//
    if (!multi&&!bg){
      get_dim(framearray[seqFrameN[interFrameN]-1][0], 1)
    }
//
    c.width = dim[1][2];
    c.height = dim[1][3];
    if(bg){
      context.drawImage(bg, ...dim[1]);
    } else if (createbg){
      context.fillRect(...dim[1]);
      randobg();
    }
    context.drawImage(framearray[seqFrameN[interFrameN]-1][0], ...dim[1]);
    //echoIMGfromCanvas(c);
    //return;

    dim[3] = [...dim[1]];
    if(multi && 1 < seqFrameN.length){
      if (firstFrame) {
        frameSaver(0, 1);
        firstFrame = false;
      } else {
        frameSaver(interFrameN, 1);
      }
      updateFrame(interFrameN, fpsm)
    } else {
      name = framearray[seqFrameN[interFrameN]-1][1];
      fps = 1;
      if(interFrameN+1 == seqFrameN.length){
        canvasToFrame(dea?undefined:staticAPNG, interFrameN, fpsm)
      } else {
        canvasToFrame(dea?undefined:staticAPNG, interFrameN, fpsm, delayFrame)
      }
    }
  }

  function delayFrame(interFrameN){
    if(interFrameN == seqFrameN.length){
      readFrame(interFrameN-1, fpsm);
    } else {
      if (interFrameN == 0){
        if (!bg){
          get_dim(framearray[seqFrameN[interFrameN]-1][0], 1)
        }
        lastFrameN = seqFrameN[0]
        delayFrame(interFrameN+1)
      } else {
        if (lastFrameN == seqFrameN[interFrameN]){
          fpsm += 1;
          echo("Frame " + interFrameN + " (delay)")
          delayFrame(interFrameN+1)
        } else {
          lastFrameN = seqFrameN[interFrameN]
          readFrame(interFrameN-1, fpsm);
          fpsm = 1;
        }
      }
    }
  }
  delayFrame(0);
  nextFrame = 2
}

function compileapngs() {
  newAPNG = [];
  seqAPNG = apnglist.innerHTML.replace(/\<br\>/g, "\n").split("\n").filter(function(e){return e;})
  let reuse = [false, false, false];//pos, dim, arri
  function readFile(interAPNG){
    ti[0] = performance.now();
    ti[1] = performance.now();
    if(interAPNG == seqAPNG.length){
      makeAPNG();
      return;
    }
    let frames = apngarray[seqAPNG[interAPNG]-1].frames
    function readFrame(interFrameN){
      if (interFrameN == frames.length) {
        return;
      }
      let frame = frames[interFrameN];
      let bp = [frame.disposeOp, frame.blendOp];
      //echo((frame.denominator/frame.numerator) + "fps")
      dim[3] = [frame.left, frame.top, frame.width, frame.height];

      function toAPNG(arri) {
        newframe.arri = arri;
        reuse[0] = seqAPNG[interAPNG];
        document.title = next;
        echo(next);
        if (interecho) {
          echoIMG(img, next + ".png");
        }
        toFrame([frame.numerator, frame.denominator], bp);
        if (interFrameN+1 == frames.length) {
          readFile(interAPNG+1);
        } else {
          readFrame(interFrameN+1);
        }
      }

      let next = "Frame " + interFrameN + " of APNG " + seqAPNG[interAPNG]
      arri = frame.arri;
      img = ABtoIMG(ABtoAB(arri));
      img.onload = () => {
        ti[0] = performance.now();
        ti[1] = performance.now();
        if (interFrameN == 0) {
          if (interAPNG == 0) {
            get_dim(img, 4);
            if (dim[4][2] < maxres[2] || dim[4][3] < maxres[3]) {
              echo("APNG " + seqAPNG[interAPNG] + " did not accommodate max dimension.<br>First APNG must have the highest dimension.");
              return
            }
            c.width = dim[4][2];
            c.height = dim[4][3];
            context.drawImage(img, ...dim[4]);
            frameSaver(0, 4);
            toAPNG(arri);
          } else {
            if (reuse[0] == seqAPNG[interAPNG] && reuse[1]) {
              dim[3] = reuse[1];
              toAPNG(reuse[2]);
            } else {
              // optimize frame 1 for joining
              context.drawImage(img, ...dim[3]);
              frameSaver(1, 4);
              const promise = new Promise(canvasToAB(c, 'png', true));
              promise.then(function(arri){
                arri = Array.from(arri);
                if (reuse[0] == seqAPNG[interAPNG]) {
                  reuse[1] = dim[3];
                  reuse[2] = arri;
                } else {
                  reuse[1] = false;
                }
                img = ABtoIMG(ABtoAB(arri))
                c.width = dim[4][2];
                c.height = dim[4][3];
                context.putImageData(frameBuffer[0], 0, 0);
                bp = [0, 1];
                toAPNG(arri);
              });
            }
          }
        } else {
          context.drawImage(img, ...dim[3]);
          frameSaver(0, 4);
          toAPNG(arri);
        }
      }
    }
    readFrame(0);
  }
  readFile(0);
}

function echoAPNG() {
  echoCanvas();
  const frames = [];
  seqAPNG = apnglist.innerHTML.replace(/\<br\>/g, "\n").split("\n").filter(function(e){return e;})
  function readFile(interAPNG, resolve) {
    if (interAPNG == seqAPNG.length) {
      //readFile(0);
      return resolve(true);
    }
    let raw_frames = apngarray[seqAPNG[interAPNG]-1].frames
    function readFrame(interFrameN) {
      let frame = raw_frames[interFrameN];
      //echo((frame.denominator/frame.numerator) + "fps")
      dim[3] = [frame.left, frame.top, frame.width, frame.height];
      img = ABtoIMG(ABtoAB(frame.arri))
      img.onload = () => {
        if (interFrameN == 0) {
          if (interAPNG == 0) {
            get_dim(img, 4);
            c.width = dim[4][2];
            c.height = dim[4][3];
            //context.drawImage(img, ...dim[4]);
            frames.push([img, [...dim[4]], [frame.numerator, frame.denominator]]);
          } else {
            //context.drawImage(img, ...dim[3]);
            frames.push([img, [...dim[3]], [frame.numerator, frame.denominator]]);
          }
        } else {
          frames.push([img, [...dim[3]], [frame.numerator, frame.denominator]]);
          //context.drawImage(img, ...dim[3]);
        }
        if (interFrameN+1 == raw_frames.length) {
          readFile(interAPNG+1, resolve);
        } else {
          readFrame(interFrameN+1);
        }
      }
    }
    readFrame(0);
  }
  const promise = new Promise((resolve) => {
    readFile(0, resolve);
  })
  promise.then(() => {
    let n = 0;
    let historical_timeStamp = [];
    let vfps = 0;
    const update = (timeStamp) => {
      if (timeStamp) {
        historical_timeStamp.unshift(timeStamp);
      }
      if (historical_timeStamp.length > 10) {
        const last_fps = historical_timeStamp.pop();
        const fps = Math.floor(1000 * 10 / (timeStamp - last_fps));
        //stdout.innerHTML = `${timeStamp.toFixed(2).padStart(3, '0')} ${fps} fps`;

        vfps += frames[n][2][1]/frames[n][2][0];
        if (vfps >= fps) {
          vfps = vfps-fps;
          if (n > frames.length-2) {
            n = 0;
          } else {
            n++;
          }
          context.drawImage(frames[n][0], ...frames[n][1]);
        }
      }
      requestAnimationFrame(update);
    }
    requestAnimationFrame(update);
  })
}

function editframelist(){
  framelist.innerHTML = ""
  for(var i=1; i<framearray.length+1; i++){
    framelist.innerHTML += i + "\n"
  }

  let e = document.getElementById("makeapng");
  e.setAttribute("onclick", "compileframes();")
  e.classList = "next";

  e = document.getElementById("detect");
  e.setAttribute("onclick", "detect();")
  e.classList = "reverse";

  e = document.getElementById("resave")
  e.classList = "next";
  e.setAttribute("onclick", "compileframes(false);")

  e = document.getElementById("deapng")
  e.classList = "next";
  e.setAttribute("onclick", "compileframes(false, true);")
}

function editapnglist(){
  apnglist.innerHTML = ""
  for(var i=1;i<apngarray.length+1;i++){
    apnglist.innerHTML += i + "\n"
  }

  let e = document.getElementById("mergeapng");
  e.setAttribute("onclick", "compileapngs();")
  e.classList = "next";

  e = document.getElementById("echoapng");
  e.setAttribute("onclick", "echoAPNG();")
  e.classList = "next";
}

function readframes(filelist){
  filelist = Array.from(filelist).sort((a,b) => a.name > b.name);
  function readFile(i){
    if(i == filelist.length) return;
    var fr = new FileReader();
    fr.readAsArrayBuffer(filelist[i]);
    fr.onload = () => {
      arri = new Uint8Array(fr.result);
      img = ABtoIMG([arri])
      img.onload = () => {
        if (i == 0 && !framearray.length){
          get_dim(img, 0);
          if(!bg){
            bigres(0);
          }
          name = filelist[0].name;
        }
        framearray.push([img, filelist[i].name]);
        if(i+1 == filelist.length){
          editframelist();
        } else {
          readFile(i+1);
        }
      }
    }
  }
  readFile(0);
}

function readapng(filelist){
  filelist = Array.from(filelist).sort((a,b) => a.name > b.name);
  name = filelist[0].name;
  function readFile(i){
    let fr = new FileReader();
    fr.readAsArrayBuffer(filelist[i]);
    fr.onload = () => {
      arri = new Uint8Array(fr.result);
      img = ABtoIMG([arri])
      img.onload = () => {
        let isAPNG = false;
        if (Array.prototype.some.call(PNG_signature, function (b, i) {
          return b !== arri[i];
        })) {
          echo(" &gt; File excluded: " + filelist[i].name + " is not a PNG");
        } else {
          eachChunk(arri, function (type) {
            return !(isAPNG = type === 'acTL');
          });
          if (!isAPNG) {
            echo(" &gt; File excluded: " + filelist[i].name + " is not an APNG");
          } else {
            apngarray.push(fromAPNG(arri));
          }
        }
        if(i+1 == filelist.length){
          editapnglist();
        } else {
          readFile(i+1);
        }
      }
    }
  }
  readFile(0);
}

function changebg(f){
  bg = new Image();
  bg.src = window.URL.createObjectURL(f);
  bg.onload = () => {
    get_dim(bg, 2);
    bigres(2);
    echo("Success loading background")
    addbg.style.display = "none";
    removebg.style.display = "block";
  };
  bg.onerror = () => {
    echo("Failed to load background")
    bg = false;
  };
}



var OgvCtrl = {
  ogv:null,
  current:null,
  ctrl:{},
  seeking:!1,
  visible:!1,
  tick:null,
  init:function(){

let e = document.createElement("div");
e.className="ogv-ctrl";

let t = document.createElement("div");
t.className="ogv-btn"
t.innerHTML='<div>▶</div><div>||</div>'
t.addEventListener("click", this.togglePlay)
this.ctrl.play = t
e.appendChild(t)

t = document.createElement("input")
t.className="ogv-seek"
t.type="range"
t.min=0
t.value=0
t.max=100
t.step=.1
t.addEventListener("change", this.onSeek)
t.addEventListener("mousedown", this.toggleSeek)
t.addEventListener("mouseup", this.toggleSeek)
this.ctrl.seek=t
e.appendChild(t)

t = document.createElement("div");
t.className = "ogv-ts";
t.textContent = "0:00 / 0:00";
this.ctrl.ts = t;
e.appendChild(t);

t = document.createElement("div");
t.className = "ogv-btn";
t.innerHTML = '<div>A</div><div>M</div>';
t.addEventListener("click", this.toggleMute);
this.ctrl.mute = t;
e.appendChild(t);

t = document.createElement("div");
t.className = "ogv-btn";
t.innerHTML = '⛶';

t.addEventListener("click", this.toggleFullscreen);
this.ctrl.fs = t;
e.appendChild(t);

this.current = e;
},
  onPlayEnd:function(){
OgvCtrl.ogv.seekable.length?OgvCtrl.ogv.currentTime=0:OgvCtrl.ogv.stop(),
OgvCtrl.ogv.play()
},
  toggleCtrl:function(){
OgvCtrl.visible?OgvCtrl.hideCtrl():(OgvCtrl.current.style.display="flex",
OgvCtrl.setTickTimeout(),
OgvCtrl.updateTimes(),
OgvCtrl.visible=!0)
},
  hideCtrl:function(){
OgvCtrl.current.style.display="none",
OgvCtrl.clearTickTimeout(),
OgvCtrl.visible=!1
},
  toggleSeek:function(){
OgvCtrl.seeking=!OgvCtrl.seeking
},
  seekTick:function(){
OgvCtrl.setTickTimeout(),
OgvCtrl.updateTimes()
},
  setTickTimeout:function(){
OgvCtrl.tick=setTimeout(OgvCtrl.seekTick,250)
},
  clearTickTimeout:function(){
clearTimeout(OgvCtrl.tick),
OgvCtrl.tick=null
},
  updateTimes:function(){
if(!OgvCtrl.ogv.duration){
  return;
}
OgvCtrl.seeking||(OgvCtrl.ctrl.seek.value=(OgvCtrl.ogv.currentTime/OgvCtrl.ogv.duration*100).toFixed(2));
let e=Math.floor(OgvCtrl.ogv.duration/60);
t=Math.floor(OgvCtrl.ogv.duration-60*e);
a=Math.floor(OgvCtrl.ogv.currentTime/60);
i=Math.floor(OgvCtrl.ogv.currentTime-60*a);
OgvCtrl.ctrl.ts.textContent=`${a}:${i.toString().padStart(2,"0")} / ${e}:${t.toString().padStart(2,"0")}`
},
  togglePlay:function(){
OgvCtrl.ogv.paused?OgvCtrl.ogv.play():OgvCtrl.ogv.pause(),
OgvCtrl.ctrl.play.classList.toggle("ogv-toggled")
},
  onSeek:function(){
OgvCtrl.ogv.currentTime=this.value/100*OgvCtrl.ogv.duration
},
  toggleMute:function(){
OgvCtrl.ogv.muted=!OgvCtrl.ogv.muted,
OgvCtrl.ctrl.mute.classList.toggle("ogv-toggled")
},
  toggleFullscreen:function(){
document.fullscreenElement?document.exitFullscreen():OgvCtrl.ogv.parentNode.requestFullscreen()
}}



var currentvideo = null;
function getogvplayer(){
  stdout.insertAdjacentHTML("beforeend", "<br>");
  pload.style.display = "none";
  OgvCtrl.init()
  let t = document.createElement("script");
  t.id = "js-ogv-scr"
  t.src = "ogv.js";
  document.body.appendChild(t)
  t.onload = () => {webmplayer()}
  t.onerror = () => {
    stdout.insertAdjacentHTML("beforeend", "<br>Download and extract from <a href='https://github.com/brion/ogv.js/releases' target='_blank'>ogv.js release</a> directly next to HTML then reload this page:<br> &gt; ogv.js<br> &gt; ogv-decoder-video-vp8-wasm.js<br> &gt; ogv-decoder-video-vp8-wasm.wasm<br> &gt; ogv-decoder-video-vp9-wasm.js<br> &gt; ogv-decoder-video-vp9-wasm.wasm<br> &gt; ogv-demuxer-webm-wasm.js<br> &gt; ogv-demuxer-webm-wasm.wasm<br> &gt; ogv-worker-video.js");
  }
}

function webmplayer(){
  let v = stdout.getElementsByClassName("ogv-current");
  while(v.length>0){
    v[0].outerHTML = "Finished/interrupted WEBM playback";
    //unless I find way to control older WEBMs
  }
  let s = document.createElement("div");
  s.className = "ogv-current"
  t = new OGVPlayer({wasm:!0,threading:!1,simd:!1})
  s.appendChild(t)
  t.onloadedmetadata = () => {
    let h = t.videoHeight;
    let a = t.videoWidth/h;
    if (h>400){
      h = 400;
    }
    t.width = h*a + "px";
    t.height = h + "px";
  }
  stdout.appendChild(s)
  t.src = currentvideo;
  t.parentNode.appendChild(OgvCtrl.current)
  t.addEventListener("mouseup", OgvCtrl.toggleCtrl)
  OgvCtrl.ogv = t;
  OgvCtrl.togglePlay()
}

function loaded(){
  if(!framelist.isContentEditable){
    framelist.setAttribute("onpaste", "plaintext(this, event)");
    framelist.setAttribute("contenteditable", "true");
    apnglist.setAttribute("onpaste", "plaintext(this, event)");
    apnglist.setAttribute("contenteditable", "true");
  }

  document.getElementById("viewer").addEventListener('change', (event) => {
    stdout.insertAdjacentHTML("beforeend", "<br>");
    var f = event.target.files[0];
    name = f.name;
    if (get_ext(f) === "mdp") {
      var fr = new FileReader();
      fr.readAsArrayBuffer(f);
      fr.onload = () => {
        const arri = new Uint8Array(fr.result);
        echoMDP(arri);
      }
      return;
    } else if (isVideo(get_ext(f))) {
      if (isVideo(get_ext(f)) == "webm" && window.OGVPlayer == undefined){
        currentvideo = window.URL.createObjectURL(f);
        if (/iPhone|iPad/.test(navigator.userAgent)){
          getogvplayer()
          return;
        } else {
          pload.style.display = "inline-block";
          window.OGVPlayer = false;
        }
      }
      if (isVideo(get_ext(f)) == "webm" && window.OGVPlayer){
        currentvideo = window.URL.createObjectURL(f);
        webmplayer();
      } else {
        var v = document.createElement("video");
        if(isVideo(get_ext(f)) == "webm"){
          v.classList = "ogv-current";
        }
        v.style = "max-height:400px;"
        v.setAttribute("controls", "");
        v.setAttribute("playsinline", "");
        v.src = window.URL.createObjectURL(f);
        stdout.appendChild(v);
        v.play();
      }
    } else if (isImage(get_ext(f))) {
      img = document.createElement("img")
      if (isImage(get_ext(f)) == "heic"){
        if (convert){
          var fr = new FileReader();
          fr.readAsArrayBuffer(f);
          fr.onload = () => {
            echoHEIC(decoder.decode(fr.result)[0], f.name.replace(/.HEIC/gi, ".jpg"));
          }
        } else {
          stdout.insertAdjacentHTML("beforeend", "libheif.js is required to view.");
        }
      } else {
        var src = window.URL.createObjectURL(f);
        img.src = src;
        img.style = "max-height:400px;"
        const dl = document.createElement("a");
        dl.download = f.name;
        dl.href = src;
        dl.appendChild(img);
        stdout.appendChild(dl);
      }
    } else if (get_ext(f).toLowerCase()=="swf") {
      try {
        const ruffle = window.RufflePlayer.newest();
        const player = ruffle.createPlayer();
        stdout.appendChild(player);
        var src = window.URL.createObjectURL(f);
        player.load(src);
      } catch {
        stdout.insertAdjacentHTML("beforeend", "Please update <a href='https://github.com/ruffle-rs/ruffle/releases' target='_blank'>Ruffle</a> (choose self-hosted version)");
      }
    } else {
      stdout.insertAdjacentHTML("beforeend", "Maybe try another program.");
    }
  });

  debug.addEventListener('click', (e) => {
    if (debug.classList.contains("reverse")){
      debug.classList = "inverse";
      debug.innerHTML = "Debug";
      interecho = true;
    } else {
      debug.classList = "reverse";
      debug.innerHTML = "Production";
      interecho = false;
    }
  });

  loadframes.addEventListener('change', (e) => {
    framearray = [];
    readframes(e.target.files);
  });

  moreframes.addEventListener('change', (e) => {
    readframes(e.target.files);
  });

  background.addEventListener('change', (e) => {
    changebg(e.target.files[0]);
  });

  removebg.addEventListener('click', () => {
    bg = false;
    bigres(0);
    echo("Unloaded background")
    removebg.style.display = "none";
    addbg.style.display = "block";
  });

  rbg.addEventListener('click', (e) => {
    if (rbg.classList.contains("reverse")){
      rbg.classList = "inverse";
      rbg.innerHTML = "Random background";
      createbg = true;
    } else {
      rbg.classList = "reverse";
      rbg.innerHTML = "Random background";
      createbg = false;
    }
  });

  getfps.addEventListener('keyup', () => {
    setfps(getfps.value);
  });

  loadapng.addEventListener('change', (e) => {
    apngarray = [];
    maxres = [0, 0, 1, 1];
    readapng(e.target.files);
  });

  moreapng.addEventListener('change', (e) => {
    readapng(e.target.files);
  });

  document.addEventListener("dragover", (e) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'copy';
  });

  document.addEventListener("drop", (e) => {
    e.preventDefault();
    framearray = [];
    readframes(e.dataTransfer.files);
  });

  var s = document.createElement("script");
  s.src = "optipng.min.js?" + Date.now();
  document.body.appendChild(s);
  s.onload = () => {
    optimize = true;
  }
  s.onerror = () => {
    document.getElementById("oload").style.display = "inline-block";
  }

  s = document.createElement("script");
  s.src = "pako_inflate.min.js?" + Date.now();
  document.body.appendChild(s);
  s.onload = () => {
    decompress = true;
  }

  s = document.createElement("script");
  s.src = "libheif.js?" + Date.now();
  document.body.appendChild(s);
  s.onload = () => {
    convert = true;
    decoder = new libheif.HeifDecoder();
  }
  s.onerror = () => {
    document.getElementById("lload").style.display = "inline-block";
  }

  s = document.createElement("script");
  s.src = "ruffle.js?" + Date.now();
  document.body.appendChild(s);
}

var filel = ["File", "Diff", "File 1", "File 2", "🦊"]
var ut = 0

new URLSearchParams(window.location.search).forEach(function (val, key) {
  if (!val){
    if (Number(key)){
      ut = key
    } else if (key == "🦦"){
      filel = ["❨'▾'❩", "❨ ꊱ ❩", "❨ 1 ❩", "❨ 2 ❩", "🦦"]
    } else {
      filel[4] = key
    }
  }
});

function newtip(y, z){
  let x = document.createElement("div");
  x.innerHTML = y;
  x.setAttribute("data-tooltip", z)
  x.classList.add("local_tooltip");
  local_backtip.appendChild(x);
  local_backtip.style.display = "inline-block";
}

var fps = 0;
var framearray = [];
var apngarray = [];
var optimize = false;
var decompress = false;
var convert = false;
var ti = [0, 0, 0, 0];
var c = document.createElement("canvas");
var context = c.getContext("2d");
var frameBuffer = [false, false, false, false];
var dim = [false, false, false, false, false];//framearray[0]'s dim, main_dim, bg_dim, make_dim, compileapngs()
var maxres = [0, 0, 1, 1];
var bg = false;
var createbg = false;
var interecho = false;
var arri, seqFrameN, seqAPNG, img, Module, name, decoder;

window.onload = () => {
  document.body.innerHTML = `<div style="margin-bottom:12px; background:inherit;">
<label class="next"><input id="viewer" type="file"></input>🦦 -(Echo file)</label>
<div class="backtip" style="display:inline-block;" data-tooltip='APNG production:<br>&nbsp;&gt; Use same lossless image with updated changes to update frame with these changes, unchanges are easy task for the frame optimizations to dispose of.<br>&nbsp;&gt; Recommend saving APNG as short clips to merge later when making long APNG series.<br><br>Resaving as single-frame APNG may appear larger in file size due to:<br>&nbsp;&gt; Converted to PNG<br>&nbsp;&gt; 32-bit color (has alpha channel)<br>&nbsp;&gt; Full color profile<br>Image viewers behave differently for PNG resaved as single-frame APNG. You can always discard it and keep original.<br><br>Frame optimization standby:<br>&nbsp;&gt; 4000 max dimension, integer downscale when exceeded<br>&nbsp;&gt; Duplicated interframe pixels will become transparent<br>&nbsp;&gt; Crop frame to fit where pixel changes<br>')">🦦 -(Production advices)</div>
<div class="backtip" id="oload" style="display:none;" data-tooltip='Optimize frames with <a href="https://github.com/LI-NA/optipng.js/tree/master/demo/js" target="_blank">optipng.min.js</a>, save next to HTML then reload this page'>🦦 -(Optimize frames)</div>
<div class="backtip" id="lload" style="display:none;" data-tooltip='Read HEIC files with <a href="https://github.com/alexcorvi/heic2any/raw/master/src" target="_blank">libheif.js</a>, save next to HTML then reload this page'>🦦 -(HEICide)</div>
<button class="next" id="pload" style="display:none; margin:0px; padding:3px 11px 4px; line-height:1.1;" onclick="getogvplayer()">🦦 -(Launch WEBM player for iPad/iPhone)</button>
</div>
<div id="tooltip" class="tooltip"></div>
</div>



<div class="backtip cell">
<div class="backtip" style="top:-11px; display:table;">🦦 -(Make)</div>
<label class="next"><input id="loadframes" type="file" multiple></input>Load Frames</label>
<label class="next"><input id="moreframes" type="file" multiple></input>Load more</label>
<label class="next" id="addbg" style="position:absolute; right:10px; top:10px;"><input id="background" type="file"></input>Load background</label>
<button class="reverse" id="rbg">Random background</button>
<button class="reverse" id="removebg" style="display:none; position:absolute; right:10px; top:10px;">Remove background</button>
<div></div>

<div style="width:350px; vertical-align:top; display:flex;">
<div><div id="framelist" class="stdout" style="color:#fd6; cursor:text;" contenteditable="plaintext-only" spellcheck=false><br></div></div>
<div style="margin:12px;">Edit list to rearrange, repeat, or skip a frame by number associated to filelist order, please do not exceed current max number.</div>
</div>
<div></div>

Make: <button class="previous" onclick="echo('Filelist is empty!')" id="makeapng">APNG</button> <button class="inverse" onclick="echo('Filelist is empty!')" id="detect">emphasizing diffs</button> at <input id="getfps" class="next" type="text" style="padding: 3px 11px; width:22px; cursor:text;" placeholder="Bad"> fps in dimension: <span id="dimension" style="background:inherit;">0 &times; 0</span><br>
Resave: <button class="previous" onclick="echo('Filelist is empty!')" id="resave">Single-frame APNG</button> <button class="previous" onclick="echo('Filelist is empty!')" id="deapng">Non-APNG</button>
</div>



<div class="backtip cell">
<div class="backtip" style="top:-11px; display:table;">🦦 -(Merge)</div>
<label class="next"><input id="loadapng" type="file" multiple></input>Load APNG</label>
<label class="next"><input id="moreapng" type="file" multiple></input>Load more</label>
<div></div>

<div style="display:flex; width:350px; vertical-align:top;">
<div><div id="apnglist" class="stdout" style="color:#fd6; cursor:text;" contenteditable="plaintext-only" spellcheck=false><br></div></div>
<div style="margin:12px;">Edit list to rearrange, repeat, or skip APNG series.</div>
</div>
<div></div>

<button class="previous" onclick="echo('APNG list is empty!')" id="mergeapng">Merge APNG</button>
<button class="previous" onclick="echo('APNG list is empty!')" id="echoapng">APNG to Canvas</button>
</div>
<div></div>



<div class="stdout" id="stdout" style="white-space:initial;">🦦 -(Output) <button class="reverse" id="debug" style="margin:0px; padding:3px 11px 4px;">Production</button></div>`
  loaded();
  lazyload();
  //document.addEventListener("click", Expander);
  if(sharp[1]){
    newtip(filel[4] + " -(Uninitiated CSS)", `Download and extract "` + sharp[0] + `" (if that's spelled correctly) from <a href="https://highlightjs.org/download/" target="_blank">highlight.js download page</a> directly next to HTML then reload this page`);
  }
}
</script></head><body class="exitmenu">1. Set up and run Schande.bat for its HTTP server from <a href="https://github.com/Rukario/Schande">https://github.com/Rukario/Schande</a><br>
2. Take me to Schande.bat, then launch <a href="http://127.0.0.1:8886/APNG Maker.html">http://127.0.0.1:8886/APNG Maker.html</a></body></html>
