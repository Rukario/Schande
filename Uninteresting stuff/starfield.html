<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="white">
<style>

:root {
  --color-keyboard: #fff;
  --color-keysocket: #6c7074;
  --color-keyborder: color-mix(in srgb, var(--color-keyboard), var(--color-keysocket));
}

body {
  background-color: #000;
  margin: 0;
  font-family: Helvetica, Arial, Sans-Serif;
  -webkit-user-select: none;
  overflow: hidden;
}

canvas {
  position: absolute;
  image-rendering: pixelated;
}

#fgbg {
  display: none;
  width: 100%;
  height: 100%;
  position: absolute;
  background-image: url("bg.png");
  image-rendering: pixelated;
  mix-blend-mode: multiply;
  z-index: 2;
  pointer-events: none;
}

#keyboard {
  display: none;
  position: absolute;
  bottom: 0px;
  z-index: 2;
  background: var(--color-keyboard);
  border-radius: 4px;
  padding: 8px;
  vertical-align: text-top;
}

.plate {
  background-color: var(--color-keyboard);
  width: 52px;
  height: 51px;
  top: -9px;

  background-clip: padding-box;
  display: inline-block;
  position: relative;
  margin: -10px -1px;
  border: 2px solid var(--color-keyborder);
  border-top: 0;

  &::before, &::after {
    content: '';
    position: absolute;
    background-color: var(--color-keysocket);
    border-top: 2px solid var(--color-keyborder);
    width: 4px;
    height: 4px;
  }

  &.left {
    border-radius: 0 0 0 4px;
    border-right: 0;
    right: -2px;
    margin-right: -2px;

    &::before, &::after {
      box-shadow: 5px 0 0 0 var(--color-keyboard), 3px -3px 0 0 var(--color-keyboard), 0 -5px 0 0 var(--color-keyboard);
      border-radius: 0 6px 0 0;
      border-right: 2px solid var(--color-keyborder);
    }

    &::before {
      top: 1px;
      left: -6px;
    }

    &::after {
      right: 1px;
      bottom: -6px;
    }
  }

  &.right {
    border-radius: 0 0 4px 0;
    border-left: 0;
    left: -2px;
    margin-left: -2px;

    &::before, &::after {
      box-shadow: -5px 0 0 0 var(--color-keyboard), -3px -3px 0 0 var(--color-keyboard), 0 -5px 0 0 var(--color-keyboard);
      border-radius: 6px 0 0 0;
      border-left: 2px solid var(--color-keyborder);
    }

    &::before {
      top: 1px;
      right: -6px;
    }

    &::after {
      left: 1px;
      bottom: -6px;
    }
  }
}

.keysocket {
  font-size: 11px;
  background: var(--color-keysocket);
  border: 2px solid var(--color-keyborder);
  border-radius: 6px;
  padding: 1px;
  display: inline-block;
}

.keysocketrow {
  display: flex;
}

.keycap {
  flex: auto;
  z-index: 2;
  position: relative;
  display: inline-block;
  background: #c4c2bb;
  margin: 1px;
  border-radius: 3px;
  border-top: 5px solid #c4c2bb;
  border-left: 10px solid #a4a29b;
  border-right: 10px solid #a4a29b;
  border-bottom: 11px solid #989692;

  &.pressed {
    border-top: 5px solid #25b;
    border-left: 10px solid #14a;
    border-right: 10px solid #14a;
    border-bottom: 11px solid #039;
  }

  .face {
    background: #dddad7;
    min-width: 20px;
    width: 31px;
    height: 34px;
    color: #088;
    margin: -3px;
    padding: 2px;
    border-radius: 4px;
    pointer-events: none;
  
    &.pressed {
      color: #fff;
      background: #36c;
    }
  }
}

.keycap2 {
  display: inline-block;
  background: #9d9ba0;
  margin: 1px;
  border-top: 5px solid #a4a2a0;
  border-left: 10px solid #8d8b90;
  border-right: 10px solid #8d8b90;
  border-bottom: 11px solid #817e84;
  border-radius: 3px;

  &.pressed {
    border-top: 5px solid #55b;
    border-left: 10px solid #44a;
    border-right: 10px solid #44a;
    border-bottom: 11px solid #339;
  }

  .face {
    background: #b6b4b9;
    min-width: 20px;
    width: 31px;
    height: 34px;
    color: #088;
    margin: -3px;
    padding: 2px;
    border-radius: 4px;
  
    &.pressed {
      color: #fff;
      background: #66c;
    }
  }
}

.hintscreen {
  position: absolute;
  pointer-events:none;
  width: 100% /*738px*/;
  height: 100% /*400px*/;
  z-index: 1;
}

.hint {
  display: none;
  background: repeating-linear-gradient(
    45deg,
    #f0f,
    #f0f 10px,
    #0f0 10px,
    #0f0 20px
  );
  width: 100%;
  height: 100%;
}

#hint2 {
  background: repeating-linear-gradient(
    45deg,
    #00f,
    #00f 10px,
    #ff0 10px,
    #ff0 20px
  );
}

#hint3 {
  background: repeating-linear-gradient(
    45deg,
    #700,
    #700 10px,
    #f00 10px,
    #f00 20px
  );
}

#hint4 {
  background: repeating-linear-gradient(
    45deg,
    #fff,
    #fff 10px,
    #000 10px,
    #000 20px
  );
}

#qixscr2 {
  background: repeating-linear-gradient(
    45deg,
    #50a,
    #50a 10px,
    #80f 10px,
    #80f 20px
  );
}

#result, #stdout, #glyphscr {
  white-space: pre;
  display: none;
  color: #0f0;
  font-family: courier;
  font-size: 24px;
  z-index: 1;
  pointer-events: none;
  position: absolute;
}

#stdout {
  top: 400px;
  font-size: 14px;
}

.poppy {
  background: #c0c0c0;
  position:absolute;
  display:none;
  z-index: 3;
  padding: 0px 4px;
  line-height:1.5;
  white-space: nowrap;
  box-shadow: inset -1px -1px #000, inset 1px 1px #c0c0c0, inset -2px -2px #848484, inset 2px 2px #fff;
  cursor: default;

  .left {
    position: relative;
    display: block;
    animation: left 200ms linear 1;
  }

  .right {
    position: relative;
    display: block;
    animation: right 200ms linear 1;
  }
}

@keyframes left {
  0% {
    transform: translateX(100%);
  }
  100% {
    transform: translateX(0%);
  }
}

@keyframes right {
  0% {
    transform: translateX(-100%);
  }
  100% {
    transform: translateX(0%);
  }
}

.poppyarrow {
  border-top: 4px solid transparent;
  border-bottom: 4px solid transparent;
  border-left: 4px solid #000;
  pointer-events: none;
  position: relative;
  left: 15px;
  top: 8px;
  float: right;
}

#touchloc, #touchlocm {
  display: none;
  pointer-events: none;
  z-index: 4;
  position: absolute;
  animation: fade 1000ms linear 1;
  //animation: fade 1000ms steps(2, end);
  mix-blend-mode: difference;
}

@keyframes fade {
  50% {
    opacity: 100%;
  }
  100% {
    opacity: 0%;
  }
}

#touchloc {
  border-color: #ffffff;
  border-style: solid;
}

#touchlocm {
  background-color: #ffffff;
}

#glyphscr {
  left: 8px;
  top: 8px;
  display: none;
}

.graph {
  position: relative;
  top: 7px;
  margin: 0 4px 14px;
  width: 201px;
  height: 201px;
  border-top: 2px solid #848484;
  border-left: 2px solid #848484;
  border-right: 2px solid #fff;
  border-bottom: 2px solid #fff;
  background-size: 10px 10px;
  background-image:
    linear-gradient(to right, #000 1px, transparent 1px),
    linear-gradient(to bottom, #000 1px, transparent 1px);
}

.graphdot {
  background: #00f;
  position: relative;
  width: 5px;
  height: 5px;
  pointer-events: none;
}

.leverdot {
  background: #fff;
  border-top: 6px solid #fff;
  border-left: 6px solid #fff;
  border-right: 6px solid #848484;
  height: 18px;
  top: 243px;
  left: 4px;

  &::before {
    content: '';
    top: -4px;
    left: -4px;
    background: #c0c0c0;
    width: 8px;
    height: 20px;
  }
}

.leverdot, .leverdot:before {
  pointer-events: none;
  position: absolute;
  clip-path: polygon(0 0, 100% 0, 100% 80%, 50% 100%, 0 80%);
}

.leverbar {
  border-top: 2px solid #848484;
  border-left: 2px solid #848484;
  border-bottom: 2px solid #fff;
  border-right: 2px solid #fff;
  width: 208px;
  pointer-events: none;
}

.poppywin {
  pointer-events: auto;
  margin: 0 3px;
  top: -12px;
  position: absolute;
  display: none;
  //border: 1px solid #f00;
  //background: rgba(255, 0, 0, 0.2);
  overflow: hidden;
}

#dialogbox {
  display: none;
  position: absolute;
  background-color: #000;
  color: #0f0;
  border-radius: 4px;
  border: 1px solid #C07820;
  z-index: 1;
  top: 64px;
  left: 64px;
  padding: 10px;
}

#close {
  cursor: pointer;
  top: -6px;
  left: -2px;
  width: 20px;
  height: 20px;
  text-align: center;
  position: relative;
  font-size: 20px;
  color: #C07820;
  display: inline-block;
}

</style>
<script>
const fps = {
  throttle: true,
  vfps: 15,
  hz: 120,
  msec: 1000 / 15,
  display: false,
  avg_slots: 10,
  avg: [],
};

const star = {
  speed: 60,
  accelerate: 4,
  life: 1, // per second
  x: 95,
  y: 95,
  r: 95/95,
};

const scr = {
  density: 75,
  frustum: 0.8 + 0.4,
  color: 2,
  fly: false,
  glide: false,
  levitate: 1,
  drift: 1, //0.66
  friction: {x: 2, y: 2},
}

var solitaire = false;
var glyph = false;
var qix = false;
var scale = 1;

var dim = {x:0, y:0};
var mousepos = {x:0, y:0};
var rubbermouse = {x:0, y:0};

const isTouch = 'ontouchstart' in window;
var busyclick = false;

var alpha = new Image();
var ccolor = '#000';
var lastcolor = '#000';

var useimg = true;


function echo(B, b) {
  if (!b) {
    B = '<br />' + B;
  } else {
    B = ' ' + B;
  }
  stdout.insertAdjacentHTML('beforeend', B);
  stdout.style.display = 'inline-block';
}

function speaker(B) {
  dialogbox.style.display = 'inline-block';
  dialog.innerHTML = B;
}

function ABtoURL(ab) {
  return URL.createObjectURL(new Blob(ab, {type: 'application/octet-stream'}));
}

function ABtoIMG(ab) {
  const img = document.createElement('img');
  img.src = ABtoURL(ab);
  return img;
}

function ABtoAB(ab) {
  return [new Uint8Array(ab)];
}

function canvasToAB(c, ext = 'png') {
  return function(resolve) {
    c.toBlob((blob0) => {
      var fr = new FileReader();
      fr.readAsArrayBuffer(blob0);
      fr.onload = () => {
        arri = new Uint8Array(fr.result);
        resolve(arri);
      };
    }, 'image/' + ext);
  }
}

function canvasToFrame(mask, callback, interFrameN) {
  let promise = new Promise(canvasToAB(mask, 'png'));
  promise.then(function(arri) {
    callback(interFrameN + 1, ABtoIMG(ABtoAB(arri)));
  });
}

var canvas = document.createElement('canvas');
canvas.width = document.documentElement.clientWidth;
canvas.height = document.documentElement.clientHeight;

var context = canvas.getContext('2d');
context.imageSmoothingEnabled = false;

var idlecursor = false;
var idlescreensaver = false;
var busyscreensaver = false;
var stopscreensaver = false;
var sideways = false;
var stars = [];
var frameCount = 0;
var startTime;



function newstar(ishtar) {
  const speli = star.speed * star.life;
  const age = Math.random() * speli % (0.66 * speli);
  const x = ((Math.random() - 0.5) * canvas.width * scr.frustum / speli) * (speli - age);
  const y = ((Math.random() - 0.5) * canvas.height * scr.frustum / speli) * (speli - age);
  stars.push([age, x, y, ishtar]);
}



function starry(vmsec) {
  if (vmsec > (1000 / star.delay) + 60/fps.vfps) {
    startTime = performance.now();
    frameCount = 0;
    if (!star.accelerate) {
      star.delay = fps.vfps;
    } else if (isFinite(star.delay)) {
      star.delay = star.delay / (1 + fps.msec / (star.accelerate*200));
    } else {
      star.delay = 60*fps.vfps;
    }
  } else {
    star.delay = (1000 / vmsec).toFixed(2);
  }

  const driftx = (mousepos.x-dim.x)/(200/scr.levitate)/(fps.vfps/60)/star.life-(mousepos.x-rubbermouse.x)/scr.friction.x*scr.drift;
  const drifty = (mousepos.y-dim.y)/(200/scr.levitate)/(fps.vfps/60)/star.life-(mousepos.y-rubbermouse.y)/scr.friction.y*scr.drift;

  context.fillStyle = ccolor;
  context.fillRect(0, 0, canvas.width, canvas.height);

  for (const ishtar of stars) {
    if (ishtar[0] === 0) {
      ishtar[1] = (Math.random()-0.5)*canvas.width*scr.frustum + (scr.glide ? (mousepos.x-dim.x)/scr.friction.x : 0);
      ishtar[2] = (Math.random()-0.5)*canvas.height*scr.frustum + (scr.glide ? (mousepos.y-dim.y)/scr.friction.y : 0);
      //ishtar[1] = Math.floor(canvas.width/6) + Math.floor(Math.random()*canvas.width/1.5);
      //ishtar[2] = Math.floor(canvas.height/6) + Math.floor(Math.random()*canvas.height/1.5);
      //ishtar[3] = scr.color ? `rgb(${Math.floor(Math.random()*256)},${Math.floor(Math.random()*256)},${Math.floor(Math.random()*256)})` : '#fff';
    }
    if (scr.glide) {
      ishtar[1] -= driftx;
      ishtar[2] -= drifty;
    }
    const speli = star.speed * star.life;
    const dot = {
      x: Math.ceil(ishtar[0]/(speli/star.x)),
      y: Math.ceil(ishtar[0]/(speli/star.y)),
    };
    const sx = (ishtar[1]+(scr.fly?(mousepos.x-dim.x)/6:0))/(speli-ishtar[0])*speli + (scr.glide?ishtar[0]*star.speed/star.life*(-(mousepos.x-dim.x)/(900*scr.friction.x)):0);
    const sy = (ishtar[2]+(scr.fly?(mousepos.y-dim.x)/6:0))/(speli-ishtar[0])*speli + (scr.glide?ishtar[0]*star.speed/star.life*(-(mousepos.y-dim.y)/(900*scr.friction.y)):0);

    if (
      sx < (scr.glide?Math.min(mousepos.x-canvas.width,-dim.x):-dim.x)-star.x/2 ||
      sy < (scr.glide?Math.min(mousepos.y-canvas.height,-dim.y):-dim.y)-star.y/2 ||
      sx > (scr.glide?Math.max(mousepos.x,dim.x):dim.x)+star.x/2 ||
      sy > (scr.glide?Math.max(mousepos.y,dim.y):dim.y)+star.y/2 ||
      ishtar[0] > speli
    ) {
      ishtar[0] = 0;
    } else {
      ishtar[0] += star.speed / star.delay;

      //if (ishtar[1] < dim.x) {
      //  ishtar[1] -= ((dim.x/ishtar[1])-1)*(1+ishtar[0]/5);
      //} else {
      //  ishtar[1] += ((dim.x/(canvas.width-ishtar[1]))-1)*(1+ishtar[0]/5);
      //}
      //
      //if (ishtar[2] < dim.y) {
      //  ishtar[2] -= ((dim.y/ishtar[2])-1)*(1+ishtar[0]/5);
      //} else {
      //  ishtar[2] += ((dim.y/(canvas.height-ishtar[2]))-1)*(1+ishtar[0]/5);
      //}
      //
      //context.fillRect(Math.ceil(ishtar[1]), Math.ceil(ishtar[2]), dot.x, dot.y);
      //
      //if (
      //  ishtar[1] < 0 ||
      //  ishtar[2] < 0 ||
      //  ishtar[1] > canvas.width ||
      //  ishtar[2] > canvas.height ||
      //  ishtar[0] > speli
      //) {
      //  ishtar[0] = 0;
      //} else {
      //  ishtar[0] += 1;
      //}

      const dot_pos = [Math.ceil(sx + dim.x - dot.x/2), Math.ceil(sy + dim.y - dot.y/2), dot.x, dot.y];
      if (useimg) {
        //maskcontext.fillStyle = ishtar[3];
        //maskcontext.drawImage(alpha, 0, 0);
        //maskcontext.globalCompositeOperation = "source-in";
        //maskcontext.fillRect(0, 0, star.x, star.y);
        //context.drawImage(mask, Math.ceil(sx + dim.x - dot.x/2), Math.ceil(sy + dim.y - dot.y/2), dot.x, dot.y);
      
        //context.fillStyle = ishtar[3];
        //context.fillRect(Math.ceil(sx + dim.x - dot.x/2), Math.ceil(sy + dim.y - dot.y/2), dot.x, dot.y);
        //context.drawImage(alpha, Math.ceil(sx + dim.x - dot.x/2), Math.ceil(sy + dim.y - dot.y/2), dot.x, dot.y);
        context.drawImage(ishtar[3], ...dot_pos);
      } else {
        context.fillStyle = ishtar[3];
        context.fillRect(...dot_pos);
      }
    }
  }
  rubbermouse.x = mousepos.x;
  rubbermouse.y = mousepos.y;
}

var currentFrame = 0;
var movingflower = new Image();
var silhouette = new Image();
var reveal = new Image();

function movingphoto() {
  //context.fillStyle = "#000";
  //context.fillRect(0, 0, qixmask.width*qixsc, qixmask.height*qixsc);
  //context.drawImage(reveal,
  //  // Selection
  //  (reveal.width-canvas.width) * ((Math.floor(currentFrame) % 120)/120),
  //  600, // sy
  //  canvas.width, // sWidth
  //  canvas.height, // sHeight
  //  // Drawing
  //  0, // dx
  //  0, // dy
  //  canvas.width, // dWidth
  //  canvas.height // dHeight
  //);

  for (let y = 0; y < canvas.height; y += movingflower.height) {
    for (let x = currentFrame; x < canvas.width; x += movingflower.width) {
      context.drawImage(movingflower, x, y);
    }
  }

  currentFrame = currentFrame + 960/fps.vfps;
  if (currentFrame > 0) {
    currentFrame = currentFrame - movingflower.width;
  }
}

function screensaver(resolve) {
  let frameThen = then = performance.now();
  let fps_increase = 0;
  const update = () => {
    if (stopscreensaver) {
      return resolve(true);
    }
    requestAnimationFrame(update);
    fps_increase++;

    const frameNow = now = performance.now();
    const sinceStart = now - startTime;
    if (frameNow >= frameThen) {
      frameThen = frameNow + 1000;
      fps.hz = fps_increase > 70 ? 120 : 60;
      const sec = (Math.round(sinceStart / 1000 * 100) / 100).toFixed(2).padStart(3, '0');
      const simfps = fps_increase.toFixed(2).padStart(3, '0');
      result.innerHTML = `Uninterrupted for ${sec} seconds @ ${simfps} fps`;
      fps_increase = 0;
    }

    const elapsed = now - then;
    if (!fps.throttle || elapsed > fps.msec) {
      then = now - (elapsed % fps.msec);
      const vmsec = (sinceStart || fps.msec) / ++frameCount;
      if (sideways) {
        movingphoto(vmsec);
      } else {
        starry(vmsec);
      }
    }
  };
  startTime = performance.now();
  if (!sideways) {
    star.delay = 60*fps.vfps;
  }
  frameCount = 0;
  result.style.display = fps.display ? 'block' : 'none';
  update();
}

function new_screensaver() {
  keyboard.style.display = 'none';
  glyphscr.style.display = 'none';
  winanim = false;
  hint.style.display = 'none';
  hint2.style.display = 'none';
  hint3.style.display = 'none';
  hint4.style.display = 'none';
  hintb.style.display = 'none';

  Promise.all([busyscreensaver]).then(() => {
    stopscreensaver = false;
    busyscreensaver = new Promise((resolve) => {
      screensaver(resolve);
    });
  });
}

const xlight = ['#f00', '#f90', '#390', '#06f', '#90c'];
const wincolor = ['#000000', '#00FF00', '#008080', '#808080', '#A6CAF0', '#C0DCC0', '#800000', '#F60000', '#800080', '#00007F', '#808000', '#FFFBF0', '#C0C0C0', '#710071', '#008000'];
const winpride = ['#e00', '#f80', '#840', '#ff0', '#0b0', '#0bf', '#00f', '#80b', '#000', '#fff', '#f8b'];

function starcolor() {
  let hex = null;
  switch (scr.color) {
    case 4:
      hex = [
        Math.floor(Math.random()*16).toString(16),
        Math.floor(Math.random()*16).toString(16),
        Math.floor(Math.random()*16).toString(16),
      ];
      return '#' + hex.join('');
    case 4:
      hex = [
        Math.floor(4 + Math.random()*12).toString(16),
        Math.floor(4 + Math.random()*12).toString(16),
        Math.floor(4 + Math.random()*12).toString(16),
      ];
      return '#' + hex.join('');
    case 3:
      return winpride[Math.floor(Math.random() * winpride.length)];
    case 2:
      return wincolor[Math.floor(Math.random() * wincolor.length)];
    case 'xmas':
      return xlight[Math.floor(Math.random() * xlight.length)];
    default:
      return '#fff';
  }
}

function starmask(color, img) {
  const mask = document.createElement('canvas');
  mask.width = alpha.width;
  mask.height = alpha.height;
  const maskcontext = mask.getContext('2d');

  if (img) {
    maskcontext.drawImage(img, 0, 0);
  } else {
    maskcontext.drawImage(alpha, 0, 0);
    maskcontext.globalCompositeOperation = "source-in";
    maskcontext.fillStyle = color || starcolor();
    maskcontext.fillRect(0, 0, mask.width, mask.height);
  }

  return mask;
}

function new_stars() {
  stars = [];
  if (scr.color === 'xmas') {
    const variant = (i, img) => {
      for (const n of Array(parseInt(i)).keys()) {
        newstar(img);
      }
    }

    const foliage = new Image();
    foliage.src = 'spruce.png';
    foliage.onload = () => {
      canvasToFrame(starmask(false, foliage), variant, scr.density/xlight.length*(xlight.length-1));
    }

    for (const color of xlight) {
      canvasToFrame(starmask(color), variant, scr.density/xlight.length/xlight.length);
    }

    new_screensaver();
  } else if (scr.color === 'card') {
    const variant = (i, img) => {
      if (img) {
        newstar(img);
      }

      if (i === scr.density) {
        new_screensaver();
        return;
      }

      readcard(variant, i);
    }
    variant(0);
  } else if (useimg) {
    const variant = (i, img) => {
      if (img) {
        newstar(img);
      }

      if (i === scr.density) {
        new_screensaver();
        return;
      }

      canvasToFrame(starmask(), variant, i);
    }
    variant(0);
  } else {
    for (const n of Array(scr.density).keys()) {
      newstar(starcolor());
    }
    new_screensaver();
  }
}



var deck = [];
var cards = {};
var slots = [];
var cheatslots = 5;
var ncard = 52;
var drawn = 1;
var draw = {};
var rev = -1;
var slothistory = [];
var solcomputer = false;
var debugcomputer = false;
var readycomputer = false;
var computerspeed = 30;
var winanim = false;
var won = false;
var winid = false;
var cardsize = [71 * scale, 96 * scale];
var gap = {
  x: 11 * scale,
  y: 5 * scale,
};
var solsize = [
  ((gap.x + 1) * scale + cardsize[0]) * (7 + cheatslots),
  400 * scale,
];

var snapshot = () => {
  dragcard = false;
  returncard = false;
  rev ++;
  if (rev < slothistory.length){
    slothistory.splice(rev);
  }
  slothistory.push(JSON.parse(JSON.stringify([deck, draw, slots])));
}

var drawx = () => {
  if (draw.draw < slots[0][1].length-1) {
    const dd = Math.min(drawn, slots[0][1].length-deck.length);
    draw.draw += dd;
    for (const i of [...Array(dd).keys()]) {
      deck.push(slots[0][1][draw.draw-dd+1+i]);
    }
  } else {
    draw.draw = -1;
    draw.cycle = false;
    deck = [];
  }
}

var cardsym = ['Clover', 'Diamond', 'Spade', 'Heart'];
var cardname = [0, 'A', 2, 3, 4, 5, 6, 7, 8, 9, 10, 'J', 'Q', 'K'];
function newloc(l=0, r=26) {
  const sym = [
    [9],
    [1,16],
    [1,9,16],
    [0,2,15,17],
    [0,2,9,15,17],
    [0,2,8,10,15,17],
    [0,2,4,8,10,15,17],
    [0,2,5,7,11,13,15,17],
    [0,2,5,7,9,11,13,15,17],
    [0,2,3,5,7,11,13,14,15,17],
  ];
  const symloc = [
    [l,0],  [13,0],  [r,0],
            [13,10],
            [13,16],
    [l,21], [13,21], [r,21],
    [l,31], [13,31], [r,31],
    [l,40], [13,40], [r,40],
            [13,50],
    [l,61], [13,61], [r,61],
  ];
  const arri = [];
  for (const index of sym) {
    const loc = [];
    for (const i of index) {
      loc.push(symloc[i]);
    }
    arri.push(loc);
  }
  return arri;
}

var cloverloc = newloc();
var diamondloc = newloc(-1, 27);
var spadeloc = newloc();
var heartloc = newloc();

// Fine-tuning symbol locations
cloverloc[6][2][1] += 1;
cloverloc[8][4][1] -= 2;
cloverloc[9][2][1] += 1;

diamondloc[8][2][1] -= 1;
diamondloc[8][3][1] -= 1;
diamondloc[8][5][1] += 1;
diamondloc[8][6][1] += 1;
diamondloc[7][2] = [13,16];
diamondloc[7][3] = [-1,31];
diamondloc[7][4] = [27,31];
diamondloc[7][5] = [13,45];
diamondloc[9][2][1] += 1;
diamondloc[9][3][1] -= 1;
diamondloc[9][4][1] -= 1;
diamondloc[9][5][1] += 1;
diamondloc[9][6][1] += 1;

spadeloc[5][2][1] -= 2;
spadeloc[5][3][1] -= 2;
spadeloc[6][2][1] += 1;
spadeloc[8][2][1] -= 1;
spadeloc[8][3][1] -= 1;
spadeloc[8][4][1] -= 2;
spadeloc[8][5][1] += 2;
spadeloc[8][6][1] += 2;
spadeloc[9][7][1] += 1;

heartloc[6][2][1] -= 1;
heartloc[8][4][1] += 2;
heartloc[9][7][1] += 1;

function new_card(next, suit) {
  let flip = false;

  const acard = document.createElement("canvas");
  const acardc = acard.getContext('2d');
  acard.width = 71;
  acard.height = 96;

  const sym = document.createElement("canvas");
  const symc = sym.getContext('2d');

  acardc.drawImage(cards['card0'], 0, 0, acard.width, acard.height);
  if (next === 0 && suit === 2) {
    // Spade A
    sym.width = 39;
    sym.height = 39;
    symc.clearRect(0, 0, sym.width, sym.height);
    symc.drawImage(cards['sym'], -132, 0, 171, 60);
    acardc.drawImage(sym, 17, 25, 39, 39);
  } else if (next >= 10) {
    sym.width = 47;
    sym.height = 74;
    symc.clearRect(0, 0, sym.width, sym.height);
    symc.drawImage(cards['mon'], -47*suit, -74*(next-10), 188, 222);
    acardc.drawImage(sym, 12, 11, 47, 74);
  } else {
    sym.width = 15;
    sym.height = 15;
    symc.clearRect(0, 0, sym.width, sym.height);
    symc.drawImage(cards['sym'], -22, -15*suit, 171, 60);
    for (const symloc of [cloverloc, diamondloc, spadeloc, heartloc][suit][next]) {
      if (symloc[1] > 33 && !flip) {
        symc.clearRect(0, 0, sym.width, sym.height);
        symc.translate(sym.width, sym.height);
        symc.scale(-1, -1);
        symc.drawImage(cards['sym'], -22, -15*suit, 171, 60);
        flip = true;
      }
      acardc.drawImage(sym, symloc[0]+15, symloc[1]+10, 15, 15);
    }
  }
  symc.setTransform(1,0,0,1,0,0);
  flip = false;

  const x = 37 + 12*(next%8);
  const y = 15*Math.floor(next/8) + 30*(suit%2);

  sym.width = 12;
  sym.height = 14;
  symc.clearRect(0, 0, sym.width, sym.height);
  symc.drawImage(cards['sym'], -x, -y, 171, 60);
  acardc.drawImage(sym, 2, 4, 12, 14);
  symc.clearRect(0, 0, sym.width, sym.height);
  symc.translate(sym.width, sym.height);
  symc.scale(-1, -1);
  symc.drawImage(cards['sym'], -x, -y, 171, 60);
  acardc.drawImage(sym, 57, 78, 12, 14);
  symc.setTransform(1,0,0,1,0,0);

  sym.width = 11;
  sym.height = 11;
  symc.clearRect(0, 0, sym.width, sym.height);
  symc.drawImage(cards['sym'], -11*(next >= 10 ? 1 : 0), -15*suit, 171, 60);
  const ms = {'x':3, 'y':18};
  if (suit === 1) {
    // Diamond
    ms.x = 2;
    ms.y = 17;
  } else if (next >= 10 && suit === 0) {
    // Spade mon
    ms.x = 1;
    ms.y = 17;
  } else if (next === 11 && suit === 3) {
    // Heart Queen
    ms.x = 2;
    ms.y = 18;
  } else if (next >= 10) {
    ms.x = 2;
    ms.y = 17;
  }
  acardc.drawImage(sym, ms.x, ms.y, 11, 11);
  symc.clearRect(0, 0, sym.width, sym.height);
  symc.translate(sym.width, sym.height);
  symc.scale(-1, -1);
  symc.drawImage(cards['sym'], -11*(next >= 10 ? 1: 0), -15*suit, 171, 60);
  symc.setTransform(1,0,0,1,0,0);
  acardc.drawImage(sym, 60-ms.x, 85-ms.y, 11, 11);

  return acard;
}

function splitmix32(a) {
  return function() {
    a |= 0; a = a + 0x9e3779b9 | 0;
    var t = a ^ a >>> 16; t = Math.imul(t, 0x21f0aaad);
        t = t ^ t >>> 15; t = Math.imul(t, 0x735a2d97);
    return ((t = t ^ t >>> 15) >>> 0) / 4294967296;
  }
}

function crapndom() {
  return crypto.getRandomValues(new Uint32Array(1))[0].toString(36);
}

function new_deck() {
  draw = {'draw':-1, 'last':-1, 'cycle':true};
  rev = -1;
  deck = [];
  won = false;
  winanim = false;
  clearTimeout(winid);
  winid = false;
  give_hint = false;
  var breakseal = [...factorysealed];
  ncard = breakseal.length;

  const alphaseed = seed.value !== '' ? seed.value.replace(/\W/g, '') : crapndom();
  seednow.value = alphaseed;
  const s = parseInt(alphaseed, 36) / Math.pow(36, alphaseed.length).toString(10).slice(2);
  const rand = splitmix32(s);
  while (breakseal.length) {
    const pick = Math.floor(rand() * breakseal.length);
    deck.push(breakseal[pick]);
    breakseal.splice(pick, 1);
  }

  slots = Array(12+cheatslots);
  for (const pos of [...Array(13+cheatslots).keys()]){
    slots[pos] = [[], []];
  };

  let used = 0;
  for (const pos of [...Array(7).keys()]) {
    used += pos-1;
    slots[pos+5][1].push(deck[pos+ncard-7]);
    for (const p of [...Array(pos).keys()]){
      slots[pos+5][0].push(deck[used+ncard-27+p]);
    }
  }
  slots[0][1] = deck.slice(0, ncard-28);
  deck = [];
  slothistory = [];
  snapshot();
}

var factorysealed = [];
function readcard(callback, interFrameN) {
  const is_star = !isNaN(interFrameN);
  if (factorysealed.length) {
    if (is_star) {
      for (const card of factorysealed) {
        newstar(cards[card]);
      };
    } else {
      new_deck();
    }
    callback(interFrameN + 1);
    return;
  };

  for (const card of ['card0', 'card1', 'card2', 'deck', 'undo', 'undo3', 'slot', 'computer', 'mon', 'sym']) {
    cards[card] = new Image();
    cards[card].src = `SOL/${card}.png`;
  }

  let promiseCards = [];

  for (const card of Object.keys(cards)) {
    promiseCards.push(new Promise((resolve, reject) => {
      setTimeout(() => {
        reject(cards[card]);
      }, 1000);

      cards[card].onload = () => {
        resolve();
      };
    }))
  }

  Promise.all(promiseCards).then(() => {
    // optional hue
    for (const [pos, card] of Object.keys(cards).entries()) {
      break;
      const hue = document.createElement("canvas");
      hue.width = cardsize[0];
      hue.height = cardsize[1];
      const huec = hue.getContext('2d');
      huec.filter = "brightness(0.6) contrast(3) saturate(2.5) hue-rotate(130deg)";
      if (['deck', 'undo', 'undo3', 'slot', 'computer'].includes(card)) {
        huec.clearRect(0, 0 , ...cardsize);
        huec.drawImage(cards[card], 0, 0, ...cardsize);
        cards[card] = hue;
        //context.drawImage(cards[card], pos*100, 0, ...cardsize);
      }
    }

    for (const [n, cs] of cardname.entries()){
      if (n) {
        for (const [s, suit] of cardsym.entries()){
          card = `${s}${n.toString(16)}`;
          //cards[card] = new Image();
          //cards[card].src = `SOL/${cs}${suit[0]}.png`;
          cards[card] = new_card(n-1, s);
          factorysealed.push(card);
        }
      }
    }

    if (is_star) {
      for (const card of factorysealed) {
        newstar(cards[card]);
      };
    } else {
      new_deck();
    }

    callback(interFrameN + 1);
  }).catch((reason) => {
    console.log(reason);
  })
}

function winsol() {
  solcomputer = false;
  winanim = true;
  const flycards = [];
  const gravity = {'x':0, 'y':1};
  const kinecticloss = 0.85;
  let i = 0;

  for (const card of [...Array(ncard/4).keys()]){
    for (const pos of [...Array(4).keys()]){
      const falldir = Math.floor(Math.random()*14-7)+1;
      const dep = Math.ceil((12-card)/4)*scale;
      flycards.push({'card':slots[pos+1][1][12-card], 'x':gap.x*4 + gap.x*pos + cardsize[0]*(pos+3) + dep*2, 'y':gap.y + dep, 'xdir':scale, 'ydir':scale, 'xvel':falldir ? falldir : -2, 'yvel':-Math.ceil(Math.random()*18)});
    }
  }

  hint.style.display = 'none';
  hintb.style.display = 'none';

  const update = () => {
    const flycard = flycards[i];
    for (const nth of Array(Math.round(240/fps.hz)).keys()) {
      if (!winanim) {
        resize();
        return;
      }
      flycard.xvel += gravity.x;
      flycard.yvel += gravity.y;
      flycard.x += (flycard.xvel * flycard.xdir);
      flycard.y += (flycard.yvel * flycard.ydir);
      if (flycard.x < -cardsize[0] || flycard.x > canvas.width) {
        break;
        //flycard.xvel = -flycard.xvel;
      }
      if (flycard.y + cardsize[1] > solsize[1]) {
        flycard.y = solsize[1] - cardsize[1];
        flycard.yvel = -flycard.yvel*kinecticloss;
      }
      context.drawImage(cards[flycard["card"]], flycard.x, flycard.y, ...cardsize);
    }
    if (flycard.x < -cardsize[0] || flycard.x > canvas.width) {
      clearTimeout(idlescreensaver);
      i++;
    }
    if (i === ncard) {
      setTimeout(resize, 1000);
      idlescreensaver = setTimeout(() => {
        new_screensaver();
      }, 10000);
      return;
    }
    requestAnimationFrame(update);
  }

  winid = setTimeout(update, 1000);
}

var invert = document.createElement('canvas');
invert.width = cardsize[0];
invert.height = Math.floor(cardsize[1]/2);

var ice = invert.getContext('2d');
ice.imageSmoothingEnabled = false;

function drawcross(x, y) {
  context.strokeStyle = "#00FF00";
  context.lineWidth = 2;
  context.beginPath();
  context.arc(x, y, 8, 0, Math.PI*2);
  context.moveTo(x - 6, y - 6);
  context.lineTo(x + 6, y + 6);
  context.stroke();
}

function sol() {
  if ([...Array(4).keys()].every((pos) => {
    return slots[pos + 1][1].length === ncard/4;
  })) {
    if (!winanim) {
      clearTimeout(winid);
      winsol();
    }
  } else {
    winanim = false;
    imawake();
  }

  context.fillStyle = "#003D00"; // "#130733"
  context.fillRect(0, 0, canvas.width, canvas.height);

  context.fillStyle = "#007D00"; // "#260f66"
  context.fillRect(0, 0, ...solsize);

  context.drawImage(cards['deck'], gap.x, gap.y, ...cardsize);
  context.drawImage(cards[drawn === 3 ? 'undo3' : 'undo'], gap.x*3 + cardsize[0]*2, gap.y, ...cardsize);
  context.drawImage(cards['computer'], gap.x*8 + cardsize[0]*7, gap.y, ...cardsize);
  //context.drawImage(cards['deal'], gap.x*9 + cardsize[0]*8, gap.y, ...cardsize);

  if (solcomputer) {
    //context.strokeStyle = "#00FF00";
    //context.lineWidth = 3;
    //context.beginPath();
    //const coord = cardsize[0]*8+gap.x*2;
    //context.arc(coord, gap.y*2 + (debugcomputer ? 3+cardsize[1]*1/2 : 0), 2, 0, Math.PI*2);
    //context.stroke();

    context.drawImage(invert, gap.x*8 + cardsize[0]*7, gap.y + (debugcomputer ? cardsize[1]/2 : 0), invert.width, invert.height);
  }

  if (drawn-1-(draw.last+drawn)%drawn && draw.draw < draw.last+drawn && draw.cycle) {
    drawcross(cardsize[0]*3+gap.x*(drawn*0.6-0.8), gap.y*2);
  }

  context.drawImage(cards['slot'], 257*scale, gap.y, ...cardsize);
  context.drawImage(cards['slot'], 339*scale, gap.y, ...cardsize);
  context.drawImage(cards['slot'], 421*scale, gap.y, ...cardsize);
  context.drawImage(cards['slot'], 503*scale, gap.y, ...cardsize);

  //for (const pos of [...Array(cheatslots).keys()]) {
  //  context.drawImage(cards['busy'], 585*scale + 82*scale*pos, gap.y*2 + cardsize[1], ...cardsize);
  //}

  if ((drawn === 1 || !slots[0][1].length) && slots.every((slot) => {return !slot[0].length})) {
    if (debugcomputer) {
      console.log("Winning vector found");
      new_deck();
      sol();
      return;
    } else if (!won) {
      won = true;
      if (!winsoln) {
        speaker("So there's no more face-down cards, at this point the next card movement is unlosable and you also have earned the winning point.<br>You can restart the solitaire because you've won.");
      } else if (winsoln === 1) {
        speaker("No more face-down cards or cards to draw means you've won for Solitaire with draw 3 cards. You can restart the solitaire now that you have earned the winning point.")
      }
      winsoln += drawn === 1 ? 1 : drawn+1;
      winningcookie();
      makemenu();
    }
  }

  // Deck
  if (draw.draw < slots[0][1].length-1) {
    const repeat = Math.ceil((slots[0][1].length-draw.draw-1)/10);
    for (const pos of [...Array(repeat).keys()]){
      context.drawImage(cards['card1'], gap.x + pos*2*scale, gap.y + pos*scale, ...cardsize);
    }
  }

  // Waste
  if (deck.length) {
    let dep = 0;
    const repeat = Math.ceil((deck.length-1)/10);
    for (const pos of [...Array(repeat).keys()]){
      dep = pos*scale;
      context.drawImage(cards['01'], gap.x+dep*2 + 82*scale, gap.y+dep, ...cardsize);
    }
    const ded = Math.min(drawn, deck.length);
    if (dragcard || returncard) {
      if (deck.length-1) {
        context.drawImage(cards[deck[deck.length-2]], gap.x+dep*2 + 82*scale, gap.y+dep, ...cardsize);
      }
      for (const i of [...Array(ded).keys()]) {
        const card = deck[deck.length-ded+i];
        if (dragcard && dragcard.slot[1][draw.draw] === card || returncard && returncard.slot[1][draw.draw] === card) {
          break;
        };
        context.drawImage(cards[card], gap.x+dep*2 + 82*scale + 14*i, gap.y+dep+i, ...cardsize);
      };
    } else if (!dragcard || dragcard.slot[1][draw.draw] !== deck[deck.length]) {
      for (const i of [...Array(ded).keys()]) {
        context.drawImage(cards[deck[deck.length-ded+i]], gap.x+dep*2 + 82*scale + 14*i, gap.y+dep+i, ...cardsize);
      }
    }
  }

  // Foundation
  for (const pos of [...Array(4).keys()]){
    let dep = 0;
    const repeat = Math.ceil((slots[pos+1][1].length)/4);
    for (const de of [...Array(repeat).keys()]){
      dep = de*scale;
      if (slots[pos+1][1].length-1){
        context.drawImage(cards['01'], gap.x+dep*2 + 82*(pos+3)*scale, gap.y+dep, ...cardsize);
      }
    }
    for (const card of slots[pos+1][1]){
      if (dragcard && dragcard.slot[1][dragcard.draw] === card || returncard && returncard.slot[1][returncard.draw] === card) {
        break;
      }
      context.drawImage(cards[card], gap.x+dep*2 + 82*(pos+3)*scale, gap.y+dep, ...cardsize);
    }
  }

  for (const pos of [...Array(7+cheatslots).keys()]){
    let des = 0
    for (let i=0;i<slots[pos+5][0].length;i++){
      context.drawImage(cards['card1'], gap.x + 82*pos*scale, (106 + des)*scale, ...cardsize);
      des += 3;
    }
    for (const card of slots[pos+5][1]){
      if (dragcard && dragcard.slot[1][dragcard.draw] === card || returncard && returncard.slot[1][returncard.draw] === card) {
        break;
      }
      context.drawImage(cards[card], gap.x + 82*pos*scale, (106 + des)*scale, ...cardsize);
      des += 15;
    }
  }

  if (givehint) {
    // Draw preview
    let y = 400 + gap.y;
    context.fillStyle = "rgba(0, 0, 0, 0.75)";

    // Cycle
    for (const [n, card] of slots[0][1].entries()) {
      context.drawImage(cards[card], 5*(n+1) + cardsize[0]*n, y, ...cardsize);
      if (n === slots[0][1].length-1 ? 0 : drawn-1-(n > draw.last-1 ? n-(draw.last-drawn+1)%drawn : n)%drawn) {
        context.fillRect(5*(n+1) + cardsize[0]*n, y, ...cardsize);
      }
    }

    // Block undo
    if (drawn-1-(draw.last+drawn)%drawn) {
      const coord = Math.floor(draw.last/drawn)*drawn;
      drawcross(Math.max(0, 5*coord + cardsize[0]*coord - cardsize[0]/2), y+8)
    }

    // Dead end
    y += cardsize[1] + gap.y;
    for (const [n, card] of slots[0][1].entries()) {
      context.drawImage(cards[card], 5*(n+1) + cardsize[0]*n, y, ...cardsize);
      if (n === slots[0][1].length-1 ? 0 : drawn-1-n%drawn) {
        context.fillRect(5*(n+1) + cardsize[0]*n, y, ...cardsize);
      }
    }
    if (draw.cycle) {
      y -= cardsize[1] + gap.y;
    }
    const x = 5*(draw.draw+1) + cardsize[0]*draw.draw;

    // Current draw
    drawhint(hint4, x, y, x, y);
  }

  // Card design preview
  //for (const [n, card] of Object.keys(cards).entries()) {
  //  context.drawImage(cards[card], 5*((n%9)+1) + cardsize[0]*(n%9), 220 + (cardsize[1] + gap.y)*Math.floor(n/9), ...cardsize);
  //}

  if (solcomputer) {
    clearTimeout(readycomputer);
    readycomputer = setTimeout(computerplaysol, computerspeed);
  } else {
    computerplaysol(true);
  }
}

function drawhint(h, x, y, dx, dy) {
  if (!h) {
    x = gap.x*8 + cardsize[0]*7 + Math.floor(cardsize[0]/2) - 16*scale;
    y = gap.y*1 + cardsize[1]*0 + Math.floor(cardsize[1]/2) - 8*scale;
    dx = x+32*scale;
    dy = y+16*scale;
    hintb.style.clipPath = `polygon(
${x}px ${y}px,
${dx}px ${y}px,
${dx}px ${dy}px,
${x}px ${dy}px,

${x}px ${y}px,

${x+2}px ${y}px,
${x+2}px ${dy-2}px,
${dx-2}px ${dy-2}px,
${dx-2}px ${y+2}px,
${x}px ${y+2}px
)`;
    hintb.style.display = 'block';
    hint.style.display = 'none';
    hint2.style.display = 'none';
    hint3.style.display = 'none';
    hint4.style.display = 'none';
    givehint = false;
    if (!winsoln) {
      speaker("In case you need a hint, move cursor/fingertip across the magenta/lime striping ring to enable hint, cross again to disable hints.");
    }
    return;
  }
  h.style.display = givehint && x ? 'block' : 'none';
  if (x === dx && y === dy) {
    const ddx = dx + cardsize[0];
    const ddy = dy + cardsize[1];
    h.style.clipPath = `polygon(
${x}px ${y}px,
${ddx}px ${y}px,
${ddx}px ${ddy}px,
${x}px ${ddy}px,
${x}px ${y}px,

${x+2}px ${y}px,
${x+2}px ${ddy-2}px,
${ddx-2}px ${ddy-2}px,
${ddx-2}px ${y+2}px,
${x}px ${y+2}px
)`;
  } else {
    const xx = x + Math.floor(cardsize[0]/2);
    const ddx = dx + Math.floor(cardsize[0]/2);
    if (xx === ddx){
      h.style.clipPath = `polygon(${xx}px ${y}px,
${xx+1}px ${y}px,
${ddx+1}px ${dy}px,
${ddx}px ${dy}px)`;
    } else {
      h.style.clipPath = `polygon(${xx}px ${y}px,
${xx}px ${y+2}px,
${ddx}px ${dy+2}px,
${ddx}px ${dy}px)`;
    }
  }
}

var moved = false;
function computerplaysol(forhint) {
  imawake();
  drawhint(hint2);
  drawhint(hint3);
  if (!givehint) {
    drawhint(hint4);
  }

  const foundations = [];
  const stack = [[], []];
  const stackforpile = [];
  const facedowns = [];

  // Register cards from Foundation piles
  for (const pos of [...Array(4).keys()]) {
    if (slots[pos+1][1].length) {
      foundations.push([slots[pos+1], pos+1]);
    }
  }

  // Register cards from Stack piles
  for (const pos of [...Array(7+cheatslots).keys()]){
    if (!slots[pos+5][1].length && slots[pos+5][0].length) {
      facedowns.push(pos);
    } else if (slots[pos+5][1].length) {
      //if (!(parseInt(slots[pos+5][1][0][1], 16) === 13 && !slots[pos+5][0].length)) {
        stack[slots[pos+5][0].length ? 1 : 0].push([slots[pos+5][1][0], slots[pos+5], pos+5, false]);
      //}
      stackforpile.push([slots[pos+5], pos]);
    } else if (pos < 7) {
      stackforpile.push([slots[pos+5], pos]);
    }
  };

  // Flip
  for (const pos of facedowns) {
    const x = gap.x*(pos+1) + cardsize[0]*pos;
    const y = gap.y*2 + cardsize[1] + 3*scale*(slots[pos+5][0].length-1);
    drawhint(hint, x, y, x, y);
    if (!forhint) {
      const card = slots[pos+5][0].at(-1); 
      slots[pos+5][0] = slots[pos+5][0].slice(0, -1);
      slots[pos+5][1].push(card);
      snapshot();
      sol();
    }
    return;
  };

  // Stack to Foundation
  for (const [sta, slo, pos, isdeck] of [...stack[0], ...stack[1]]) {
    const des = pos > 4 ? 1 : 0;
    const depth = slots[pos][1].length-1;
    const card = slots[pos][1][depth];
    if (!moved && (parseInt(card[1], 16) === 1 || foundations.some((f) => {const fca = f[0][1].at(-1); return card[0] === fca[0] && parseInt(card[1], 16) === parseInt(fca[1], 16)+1}))) {
      const x = gap.x*(pos-(5*des)+1) + cardsize[0]*(pos-(5*des));
      const y = gap.y*2 + cardsize[1] + depth*15*scale + 3*scale*slots[pos][0].length;
      drawhint(hint, x, y, x, y);
      if (!forhint) {
        dragcard = {'x':x, 'y':y, 'dx':mousepos.x, 'dy':mousepos.y, 'slot':slots[pos], 'draw':depth};
        setTimeout(FFup, computerspeed*3);
      }
      return;
    }
  }

  // Register Deck pile
  if (deck.length) {
    stack[1].push([deck.at(-1), slots[0], 1, true]);

    // Deck to Foundation
    const card = deck.at(-1);
    if(!moved && (parseInt(card[1], 16) === 1 || foundations.some((f) => {const fca = f[0][1].at(-1); return card[0] === fca[0] && parseInt(card[1], 16) === parseInt(fca[1], 16)+1}))) {
      const depth = Math.min(drawn, deck.length)-1;
      const repeat = Math.floor(Math.abs(deck.length-2)/10)*scale;
      const x = gap.x*2 + cardsize[0]*1 + repeat*2 + depth*scale*14;
      const y = gap.y*1 + cardsize[1]*0 + repeat + depth*scale;
      drawhint(hint, x, y, x, y);
      if (!forhint) {
        dragcard = {'x':x, 'y':y, 'dx':mousepos.x, 'dy':mousepos.y, 'slot':slots[0]};
        setTimeout(FFup, computerspeed*3);
      }
      return;
    }
  }

  // Stack
  for (const pos of [...Array(7+cheatslots).keys()]){
    const vectors = [];
    if (slots[pos+5][1].length) {
      // Standard card movement
      const card = slots[pos+5][1].at(-1);
      for (const s of [...stack[1], ...stack[0]]) {
        if (s[0][0]%2 !== card[0]%2 && parseInt(s[0][1], 16) === parseInt(card[1], 16)-1) {
          vectors.push(s);
        }
      }
    } else if (pos < 7 && !slots[pos+5][0].length) {
      // Move King card to an empty slot
      for (const s of stack[1]) {
        if (parseInt(s[0][1], 16) === 13) {
          vectors.push(s);
        }
      }
    }
    if (vectors.length) {
      if (vectors.length > 1) {
        console.log("Alternative card movement available! Piles with face-down cards have priority but not necessarily top priority since empty slot could be reserved for King card with face-down cards.");
      }
      let o = 0;
      for (const [card, slo, place, isdeck] of vectors) {
        let depth = slots[pos+5][1].length;
        depth -= (depth ? 1 : 0)
        const x = gap.x*(pos+1) + cardsize[0]*pos;
        const y = gap.y*2 + cardsize[1]*1 + 3*scale*slots[pos+5][0].length + depth*15*scale;
        const des = place > 4 ? 1 : 0;
        drawhint([hint, hint2, hint3, hint4][o], x, y, gap.x*(place-(5*des)+1) + cardsize[0]*(place-(5*des)), gap.y*(des+1) + cardsize[1]*des + 3*scale*slo[0].length);
        if (!forhint) {
          dragcard = {'x':x, 'y':y, 'dx':mousepos.x, 'dy':mousepos.y, 'slot':slo};
          if(!isdeck) {
            dragcard['draw'] = 0;
          }
          setTimeout(FFup, computerspeed*3);
          return;
        }
        o++
      }
      if (o) {
        hints = o;
        return;
      }
    }
  }
  hints = 1;

  if (slots[0][1].length && !(draw.draw >= slots[0][1].length-1 && !draw.cycle)) {
    // Deck to Waste
    const repeat = draw.draw < slots[0][1].length-1 ? Math.ceil((slots[0][1].length-draw.draw-1)/10)-1 : 0;
    const x = gap.x + repeat*2;
    const y = gap.y + repeat;
    //hint.style.display = "none";
    //hintb.style.display = "block";
    drawhint(hint, x, y, x, y);
    if (!forhint) {
      setTimeout(()=> {
        drawx();
        sol();
      }, computerspeed);
    }
  } else {
    // Stack to Foundation: Pile movement
    for (const [fslo, fpos] of foundations) {
      for (const [slo, place] of stackforpile) {
        if (!slo[1].length) {
          continue;
        }
        for (const [n, card] of slo[1].entries()) {
          const fca = fslo[1].at(-1);
          if (fca[0] === card[0] && parseInt(fca[1], 16) === parseInt(card[1], 16)-1) {
            const ch = slo[1][n+1];
            if (!ch) {
              continue;
            }
            for (const pos of [...Array(7+cheatslots).keys()]){
              if (slots[pos+5][1].length) {
                const de = slots[pos+5][1].length-1;
                const ca = slots[pos+5][1][de];
                if (ch[0]%2 !== ca[0]%2 && parseInt(ch[1], 16) === parseInt(ca[1], 16)-1) {
                  const x = gap.x*(pos+1) + cardsize[0]*pos;
                  const y = gap.y*2 + cardsize[1]*1 + de*15*scale + 3*scale*slots[pos+5][0].length;
                  const dx = gap.x*(place+1) + cardsize[0]*place;
                  const dy = gap.y*1 + cardsize[1]*1 + (n+1)*15*scale + 3*scale*(slo[0].length+2);
                  drawhint(hint, x, y, dx, dy);

                  if (!forhint) {
                    drawx();
                    dragcard = {'x':x, 'y':y, 'dx':mousepos.x, 'dy':mousepos.y, 'slot':slo};
                    dragcard['draw'] = n+1;
                    console.log('That was a special move!');
                    setTimeout(FFup, computerspeed*3);
                  }
                  return;
                }
              }
            }
          }
        }
      }
    }

    // Foundation to Stack: if another card requires a borrowed card to move
    for (const pos of [...Array(7).keys()]) {
      if (slots[pos+5][0].length && slots[pos+5][1].length){
        const card = slots[pos+5][1][0];
        let unsure = false;
        for (const [fslo, fpos] of foundations) {
          const fca = fslo[1].at(-1);
          if (card[0]%2 !== fca[0]%2 && parseInt(card[1], 16) < parseInt(fca[1], 16)) {
            if (parseInt(card[1], 16) < parseInt(fca[1], 16)-1) {
              console.log('Takes more than 1 card to do it! Trying...');
            }
            for (const [slo, place] of stackforpile) {
              const ca = slo[1].at(-1);
              if (parseInt(fca[1], 16) === 13 && !ca || ca && fca[0]%2 !== ca[0]%2 && parseInt(fca[1], 16) === parseInt(ca[1], 16)-1) {
                const des = fpos > 4 ? 1 : 0;
                const repeat = Math.floor(Math.abs(fslo[1].length-2)/4)*scale;
                const x = gap.x*(place+1) + cardsize[0]*place;
                const y = gap.y*2 + cardsize[1]*1 + 15*scale*(slo[1].length-(slo[1].length ? 1 : 0)) + 3*scale*slo[0].length;
                drawhint(hint, x, y, gap.x*(fpos+3) + cardsize[0]*(fpos+2) + repeat*2, gap.y*(des+1) + cardsize[1]*(des*1) + repeat);
                moved = true;
                if (!forhint) {
                  drawx();
                  dragcard = {'x':x, 'y':y, 'dx':mousepos.x, 'dy':mousepos.y, 'slot':fslo};
                  dragcard['draw'] = fslo[1].length-1;
                  console.log("moved", fca, "to", ca);
                  setTimeout(FFup, computerspeed*3);
                }
                return;
              }
            }
            unsure = true;
          }
        }
        if (unsure) {
          console.log("About to run into a dead end and I'm not sure, maybe wanna move card", cardsym[parseInt(card[0], 16)], cardname[parseInt(card[1], 16)], "somehow? I see a larger number from pile that might be able to help with that.");
          if (debugcomputer) {
            new_deck();
            sol();
          } else {
            solcomputer = false;
            if (!forhint) {
              sol();
            }
          }
          return;
        }
      }
    }

    if (!won) {
      console.log('Ran into a dead end');
      const repeat = draw.draw < slots[0][1].length-1 ? Math.ceil((slots[0][1].length-draw.draw-1)/10)-1 : 0;
      const x = gap.x + repeat*2;
      const y = gap.y + repeat;
      drawhint(hint3, x, y, x, y);
    }

    if (debugcomputer) {
      new_deck();
      sol();
      // teach computer to undo and retry with alternative card movement
    } else if (!forhint) {
      solcomputer = false;
      sol();
    }

    //solcomputer = false;
    //stop computer play for debugging
  }
}



var fastclick = performance.now();
var dragcard = false;
var returncard = false;

var pickcard = () => {
  returncard = false;
  const sel = (x, y, e) => {
    return mousepos.x > gap.x*(x+1) + cardsize[0]*x && mousepos.x < gap.x*(x+1) + cardsize[0]*(x+1)+e && mousepos.y > gap.y*(y+1) + cardsize[1]*y && mousepos.y < gap.y*(y+1) + cardsize[1]*(y+1)
  };

  // Deck to Waste
  if(sel(0, 0, 0)){
    drawx();
  }

  // Drag card from Waste
  const dep = Math.min(drawn, deck.length)-1;
  if (sel(1, 0, 14*(drawn-1)*scale) && deck.length) {
    const repeat = Math.floor(Math.abs(deck.length-2)/10)*scale;
    dragcard = {
      x: gap.x*2 + cardsize[0]*1 + repeat*2 + dep*scale*14,
      y: gap.y*1 + cardsize[1]*0 + repeat + dep*scale,
      dx: mousepos.x,
      dy: mousepos.y,
      slot: slots[0],
    };
  }

  // Undo draw
  if (
    mousepos.x > gap.x*3 + cardsize[0]*2 + 12*(drawn-1)*scale &&
    mousepos.x < gap.x*3 + cardsize[0]*3 &&
    mousepos.y > gap.y + cardsize[1]*0 &&
    mousepos.y < gap.y*1 + cardsize[1]*1/2
  ) {
    if (draw.draw > -1) {
      if (!(drawn-1-(draw.last+drawn)%drawn) || draw.draw > draw.last || !draw.cycle) {
        if (slots[0][1].length-1 <= draw.draw) {
          const microdraw = draw.cycle ? (draw.draw-(draw.last-drawn)%drawn)%drawn : slots[0][1].length%drawn;
          if (microdraw) {
            // Partial backwards
            draw.draw -= microdraw;
            deck.splice(draw.draw+1);
          } else {
            // Standard backwards
            draw.draw -= drawn;
            deck.splice(draw.draw+1);
          }
        } else {
          // Standard backwards
          draw.draw -= drawn;
          deck.splice(draw.draw+1);
        }
      }
    } else {
      // Unflip deck
      draw.draw = slots[0][1].length-1;
      draw.cycle = true;
      for (const d of [...Array(draw.draw+1).keys()]) {
        deck.push(slots[0][1][d]);
      }
    }
  }

  // Undo card movement
  if (
    mousepos.x > gap.x*3 + cardsize[0]*2 + 12*(drawn-1)*scale &&
    mousepos.x <= gap.x*3 + cardsize[0]*2 + cardsize[0]*1/2 + 12/2*(drawn-1)*scale &&
    mousepos.y > gap.y + cardsize[1]*1/2 &&
    mousepos.y <= gap.y*1 + cardsize[1]*1
  ) {
    winanim = false;
    if (rev) {
      rev --;
      [deck, draw, slots] = JSON.parse(JSON.stringify(slothistory[rev]));
    }
    sol();
    return;
  }

  // Redo card movement
  if (
    !winanim &&
    mousepos.x > gap.x*3 + cardsize[0]*2 + cardsize[0]*1/2 + 12/2*(drawn-1)*scale &&
    mousepos.x < gap.x*3 + cardsize[0]*3 &&
    mousepos.y > gap.y + cardsize[1]*1/2 &&
    mousepos.y < gap.y*1 + cardsize[1]*1
  ) {
    if (rev < slothistory.length-1) {
      rev ++;
      [deck, draw, slots] = JSON.parse(JSON.stringify(slothistory[rev]));
    }
    sol();
    return;
  }

  // Solitaire with computer
  if (!winanim &&
    mousepos.x >= gap.x*8 + cardsize[0]*7 &&
    mousepos.x < gap.x*8 + cardsize[0]*8 &&
    mousepos.y >= gap.y*1 + cardsize[1]*0 &&
    mousepos.y < gap.y*1 + cardsize[1]*1
  ) {
    let pos = 0;

    if (mousepos.y < gap.y*1 + cardsize[1]*1/2) {
      solcomputer = debugcomputer ? true : !solcomputer;
      debugcomputer = false;
      computerspeed = 30;
    } else {
      solcomputer = !debugcomputer ? true : !solcomputer;
      debugcomputer = true;
      computerspeed = 1;
      pos = -cardsize[1]/2;
    }

    if (ice.filter) {
      ice.filter = 'invert(1)';
      ice.globalCompositeOperation = 'source-over';
      ice.clearRect(0, 0, invert.width, invert.height);
      ice.drawImage(cards['computer'], 0, pos, ...cardsize);
    } else {
      ice.globalCompositeOperation = 'source-over';
      ice.clearRect(0, 0, invert.width, invert.height);
      ice.drawImage(cards['computer'], 0, pos, ...cardsize);
      ice.globalCompositeOperation = 'difference';
      ice.fillStyle = 'white';
      ice.fillRect(0, 0, invert.width, invert.height);
      let invert2 = document.createElement('canvas');
      let ice2 = invert2.getContext('2d');
      invert2.width = invert.width;
      invert2.height = invert.height;
      ice2.drawImage(cards['computer'], 0, pos, ...cardsize);
      ice2.globalCompositeOperation = 'source-in';
      ice2.fillStyle = 'black';
      ice2.fillRect(0, 0, invert.width, invert.height);
      ice.globalCompositeOperation = 'destination-in';
      ice.drawImage(invert2, 0, 0, invert.width, invert.height);
    }

    sol();
  }

  // Drag card from Foundation
  for (const pos of [...Array(4).keys()]) {
    if (sel(pos+3, 0, 0)) {
      if (slots[pos+1][1].length) {
        const repeat = Math.ceil((slots[pos+1][1].length)/4)-1;
        dragcard = {
          x: gap.x*(pos+4) + cardsize[0]*(pos+3) + repeat*scale*2,
          y: gap.y*1 + cardsize[1]*0 + repeat*scale,
          dx: mousepos.x,
          dy: mousepos.y,
          slot: slots[pos+1],
          draw: slots[pos+1][1].length-1,
        };
        winanim = false;
      }
      break;
    }
  }

  // Drag card from Stack
  for (const pos of [...Array(7+cheatslots).keys()]) {
    if (
      mousepos.x >= gap.x*(pos+1) + cardsize[0]*pos &&
      mousepos.x < gap.x*(pos+1) + cardsize[0]*(pos+1) &&
      mousepos.y >= gap.y*2 + cardsize[1]*1 &&
      mousepos.y < gap.y*2 + cardsize[1]*2 + 3*scale*slots[pos+5][0].length + 15*scale*slots[pos+5][1].length
    ) {
      if (slots[pos+5][1].length) {
        const depth = Math.min(Math.floor(Math.max(mousepos.y - (gap.y*2 + cardsize[1]*1 + 3*scale*slots[pos+5][0].length), 0) / 15 / scale), slots[pos+5][1].length-1);
        dragcard = {
          x: gap.x*(pos+1) + cardsize[0]*pos,
          y: gap.y*2 + cardsize[1]*1 + 3*scale*slots[pos+5][0].length + depth*15*scale,
          dx: mousepos.x,
          dy: mousepos.y,
          slot: slots[pos+5],
          draw: depth,
        };
      } else if (slots[pos+5][0].length) {
        // Flip card
        const card = slots[pos+5][0].at(-1); 
        slots[pos+5][0] = slots[pos+5][0].slice(0, -1);
        slots[pos+5][1].push(card);
        snapshot();
      }
      break;
    }
  }

  imawake();

  if (dragcard) {
    let dragcards = 'draw' in dragcard ? dragcard.slot[1].slice(dragcard.draw) : [dragcard.slot[1][draw.draw]];
    let des = 0;
    for (const card of dragcards){
      context.drawImage(cards[card], dragcard.x, dragcard.y+des, ...cardsize);
      des += 15*scale;
    }
  }
  return;
}

function rubberband() {
  returncard = dragcard;
  let returncards = 'draw' in dragcard ? dragcard.slot[1].slice(dragcard.draw) : [dragcard.slot[1][draw.draw]];
  const rubbersize = 4;
  let rubberstep = rubbersize;
  const update = () => {
    if (!returncard || rubberstep === 0) {
      returncard = false;
      if (!dragcard) {
        sol();
      }
      return;
    }
    sol();
    requestAnimationFrame(update);
    let des = 0;
    for (const card of returncards) {
      const x = rubberstep / rubbersize * (mousepos.x - returncard.dx) + returncard.x;
      const y = rubberstep / rubbersize * (mousepos.y - returncard.dy) + returncard.y + des;
      context.drawImage(cards[card], x, y, ...cardsize);
      des += 15 * scale;
    }
    rubberstep -= 1;
  }
  update();
};

var releasecard = () => {
  const deckpop = () => {
    slots[0][1] = [...dragcard.slot[1].slice(0, draw.draw), ...dragcard.slot[1].slice(draw.draw+1)];
    deck.pop();
    draw.draw -= 1;
    draw.last = draw.draw;
    draw.cycle = true;
  }

  if (dragcard){
    let slot = [];
    let cheat = false;

    // Deal
    //if (mousepos.x - dragcard.dx + dragcard.x + cardsize[0] > gap.x*9 + cardsize[0]*8 && mousepos.x - dragcard.dx + dragcard.x < gap.x*9 + cardsize[0]*9 && mousepos.y - dragcard.dy + dragcard.y + cardsize[1] > gap.y*1 + cardsize[1]*0 && mousepos.y - dragcard.dy + dragcard.y < gap.y*1 + cardsize[1]*1) {
    //  dragcard = false;
    //  returncard = false;
    //  new_deck();
    //  sol();
    //  return;
    //}

    // Select pile from Foundation or an action for double click
    for (const pos of [...Array(4).keys()]) {
      if (
        mousepos.x - dragcard.dx + dragcard.x + cardsize[0] >= gap.x*(pos+4) + cardsize[0]*(pos+3) &&
        mousepos.x - dragcard.dx + dragcard.x < gap.x*(pos+4) + cardsize[0]*(pos+4) &&
        mousepos.y - dragcard.dy + dragcard.y + cardsize[1] >= gap.y*1 + cardsize[1]*0 &&
        mousepos.y - dragcard.dy + dragcard.y < gap.y*1 + cardsize[1]*1
      ) {
        slot.push(slots[pos+1]);
      }
      if (fastclick + 200 > performance.now()) {
        let stack = slots[pos+1][1].at(-1);
        let dragcards = 'draw' in dragcard ? dragcard.slot[1].slice(dragcard.draw) : [dragcard.slot[1][draw.draw]];
        let card = dragcards.at(-1);
        if (
          !stack &&
          parseInt(card[1], 16) === 1 ||
          stack &&
          dragcards.length === 1 &&
          parseInt(card[0], 16) === parseInt(stack[0], 16) &&
          parseInt(card[1], 16) === parseInt(stack[1], 16) + 1
        ) {
          if ('draw' in dragcard) {
            slots[pos+1][1].push(...dragcard.slot[1].slice(dragcard.draw));
            dragcard.slot[1] = dragcard.slot[1].slice(0, dragcard.draw);
          } else {
            slots[pos+1][1].push(dragcard.slot[1][draw.draw]);
            deckpop();
          }
          snapshot();
          sol();
          return;
        }
      }
    }

    // Drag card to this pile
    if (slot.length) {
      for (const s of slot){
        let stack = s[1].at(-1);
        let dragcards = 'draw' in dragcard ? dragcard.slot[1].slice(dragcard.draw) : [dragcard.slot[1][draw.draw]];
        let card = dragcards.at(-1);
        if (
          !stack &&
          parseInt(card[1], 16) === 1 ||
          stack &&
          dragcards.length === 1 &&
          parseInt(card[0], 16) === parseInt(stack[0], 16) &&
          parseInt(card[1], 16) === parseInt(stack[1], 16) + 1
        ) {
          if ('draw' in dragcard) {
            s[1].push(...dragcard.slot[1].slice(dragcard.draw));
            dragcard.slot[1] = dragcard.slot[1].slice(0, dragcard.draw);
          } else {
            s[1].push(dragcard.slot[1][draw.draw]);
            deckpop();
          }
          snapshot();
          sol();
          return;
        }
      }
    }
    slot = [];

    // Select pile from Stack
    for (const pos of [...Array(7+cheatslots).keys()]) {
      if (
        mousepos.x - dragcard.dx + dragcard.x + cardsize[0] >= gap.x*(pos+1) + cardsize[0]*(pos) &&
        mousepos.x - dragcard.dx + dragcard.x < gap.x*(pos+1) + cardsize[0]*(pos+1) &&
        mousepos.y - dragcard.dy + dragcard.y + cardsize[1] >= gap.y*2 + cardsize[1]*1 &&
        mousepos.y - dragcard.dy + dragcard.y < gap.y*2 + cardsize[1]*2 + 3*scale*slots[pos+5][0].length + 15*scale*(slots[pos+5][1].length-1)
      ) {
        slot.push(slots[pos+5]);
        if (!cheat){
          cheat = pos > 6 || 'draw' in dragcard && slots[pos+5][0].length === 0 && dragcard.slot[0].length === 0 ? 2 : 1;
        }
      }
    }

    // Drag card to this pile
    if (slot.length) {
      const card = dragcard.slot[1]['draw' in dragcard ? dragcard.draw : draw.draw];
      for (const s of slot){
        if (!s[1].length) {
          if (parseInt(card[1], 16) === ncard/4 || cheat === 2 && !(dragcard.draw)) {
            if ('draw' in dragcard) {
              s[1].push(...dragcard.slot[1].slice(dragcard.draw));
              dragcard.slot[1] = dragcard.slot[1].slice(0, dragcard.draw);
            } else {
              s[1].push(dragcard.slot[1][draw.draw]);
              deckpop();
            }
            snapshot();
            sol();
            fastclick = performance.now();
            return;
          } else {
            rubberband();
          };
        } else if (
          card[0] % 2 !== s[1].at(-1)[0] % 2 &&
          parseInt(card[1], 16) === parseInt(s[1].at(-1)[1][0], 16) - 1
        ) {
          if ('draw' in dragcard) {
            s[1].push(...dragcard.slot[1].slice(dragcard.draw));
            dragcard.slot[1] = dragcard.slot[1].slice(0, dragcard.draw);
          } else {
            s[1].push(dragcard.slot[1][draw.draw]);
            deckpop();
          }
          snapshot();
          sol();
          fastclick = performance.now();
          return;
        } else {
          rubberband();
        };
      }
    } else {
      rubberband();
    }
  }
  dragcard = false;
  moved = false;
  if (!winanim) {
    sol();
  }
  fastclick = performance.now();
  return;
}


let ZOOKd = null;
const FFdown = (e_) => {
  mousec.down = 1;
  clearTimeout(fader);

  if (isTouch) {
    if (e_.touches.length === 1) {
      mousepos.x = e_.touches[0].clientX + window.visualViewport.offsetLeft;
      mousepos.y = e_.touches[0].clientY + window.visualViewport.offsetTop;

      const sc = window.visualViewport.scale;
      const size = 3 / sc;
      const border = 1 / sc;

      touchloc.style.display = 'block';
      touchlocm.style.display = 'block';

      touchloc.style.animation = 'none';
      touchlocm.style.animation = 'none';

      touchloc.style.width = size + 'px';
      touchloc.style.height = size + 'px';
      touchlocm.style.width = size + 'px';
      touchlocm.style.height = size + 'px';

      touchloc.style.top = mousepos.y - border + 'px';
      touchloc.style.left = mousepos.x - border + 'px';
      touchlocm.style.top = mousepos.y + 'px';
      touchlocm.style.left = mousepos.x + 'px';

      touchloc.style.borderWidth = border + 'px';
    }
  } else {
    mousepos.x = e_.x;
    mousepos.y = e_.y;
  }

  graphdraw(e_);
  leverdraw(e_);

  if (e_.target.classList.contains('poppy') || e_.target.parentNode.classList.contains('poppy') || isTouch && e_.touches.length > 1) {
    ZOOKd = true;
    if (solitaire && dragcard) {
      rubberband();
      dragcard = false;
    }
  } else {
    ZOOKd = false;
    if (solitaire) {
      pickcard();
    }
  }
}

let fader = null;
const FFup = (e_) => {
  mousec.down = 0;

  if (e_ && !ZOOKd) {
    if(!e_.target.parentNode.classList.contains('poppy') && poppy.style.display !== 'none') {
      poppy.style.display = 'none';
    }

    if (dialogbox.style.display != 'none') {
      dialogbox.style.display = 'none';
    }
  }

  if (isTouch && e_.touches.length === 0) {
    touchloc.style.animation = '';
    touchlocm.style.animation = '';
    fader = setTimeout(() => {
      touchloc.style.display = 'none';
      touchlocm.style.display = 'none';
    }, 900);
  }

  leverdrawing = false;
  graphdrawing = false;

  if (e_) {
    e_.preventDefault();
  }

  if (solitaire) {
    releasecard();
  }
}



function imawake() {
  if ((solitaire || qix || glyph) && !stopscreensaver) {
    stopscreensaver = true;

    if (solitaire) {
      hintb.style.display = 'block';
      if (!winanim) {
        sol();
      }
    }

    if (qix) {
      keyboard.style.display = 'inline-block';
      qixupdate();
    }

    if (glyph) {
      hint.style.display = 'block';
      new_glyph();
    }
  }

  clearTimeout(idlescreensaver);
  idlescreensaver = setTimeout(() => {
    new_screensaver();
  }, 60000);
};

var crosshint, givehint;
var hints = 1;



var FFmove = (e_) => {
  clearTimeout(idlecursor);
  idlecursor = setTimeout(() => {
    canvas.style.cursor = "none";
  }, 1500);
  canvas.style.cursor = "default";
  imawake();

  if (e_) {
    if (isTouch) {
      if (e_.touches.length === 1) {
        e_.preventDefault();
        mousepos.x = e_.touches[0].clientX + window.visualViewport.offsetLeft;
        mousepos.y = e_.touches[0].clientY + window.visualViewport.offsetTop;
      }

      clearTimeout(fader);

      const sc = window.visualViewport.scale;
      touchlocm.style.top = mousepos.y + 'px';
      touchlocm.style.left = mousepos.x + 'px';
    } else {
      e_.preventDefault();
      mousepos.x = e_.x;
      mousepos.y = e_.y;
    }
  }

  graphdraw(e_);
  leverdraw(e_);

  if (solitaire && !winanim) {
    if (
      mousepos.x > gap.x*8 + cardsize[0]*7 + cardsize[0]/2 - 16*scale &&
      mousepos.x < gap.x*8 + cardsize[0]*7 + cardsize[0]/2 + 16*scale &&
      mousepos.y > gap.y*1 + cardsize[1]*0 + cardsize[1]/2 - 8*scale &&
      mousepos.y < gap.y*1 + cardsize[1]*0 + cardsize[1]/2 + 8*scale
    ) {
      if (!crosshint) {
        givehint = !givehint;
        if (givehint) {
          for (const o of [...Array(hints).keys()]) {
            [hint, hint2, hint3, hint4][o].style.display = 'block';
          }
          hintb.style.display = 'none';
        } else {
          hint.style.display = 'none';
          hint2.style.display = 'none';
          hint3.style.display = 'none';
          hint4.style.display = 'none';
          hintb.style.display = 'block';
        }
        sol();
      }
      clearTimeout(crosshint);
      crosshint = setTimeout(() => {
        crosshint = false;
      }, 200);
    }
  }

  if (solitaire && dragcard){
    sol();
    let dragcards = 'draw' in dragcard ? dragcard.slot[1].slice(dragcard.draw) : [dragcard.slot[1][draw.draw]];
    let des = 0;
    for (const card of dragcards){
      context.drawImage(cards[card], mousepos.x-dragcard.dx+dragcard.x, mousepos.y-dragcard.dy+dragcard.y+des, ...cardsize);
      des += 15*scale;
    }
  }
}



var rightc = (e_) => {
  if (isTouch && e_.touches.length > 1) {
    return;
  }

  for (const p of document.querySelectorAll('.poppywin')) {
    p.style.display = 'none';
  }
  poppy.style.display = 'block';
  const x = Math.min(
    isTouch
      ? e_.touches[0].clientX + window.visualViewport.offsetLeft
      : e_.x,
    document.documentElement.clientWidth - poppy.clientWidth,
  );
  const y = Math.min(
    isTouch
      ? e_.touches[0].clientY + window.visualViewport.offsetTop
      : e_.y,
    document.documentElement.clientHeight - poppy.clientHeight,
  );
  poppy.style.left = `${x > 0 ? x : 0}px`;
  poppy.style.top = `${y > 0 ? y : 0}px`;

  ZOOKd = true;
  e_.preventDefault();
};

function typeOf(obj) {
  const stringified = Object.prototype.toString.call(obj);
  const type = stringified.split(' ')[1].slice(0, -1);
  return type.toLowerCase();
}

var DOMwriter = null;
var winsoln = 0;
var morescr, options, seed, seednow, staropt, graph, graphdot, graphstat, lever, leverdot, leverstat;
var graphdrawing = false;
var leverdrawing = false;

function winningcookie() {
  const expires = new Date(Date.now() + 365 * 864e5).toUTCString();
  document.cookie = "winsol=" + encodeURIComponent(winsoln) + "; expires=" + expires + "; path=/; SameSite=Strict;";
  //no expiry would allow the cookie to be automatically deleted upon browser exit.
}

function savestar() {
  const expires = new Date(Date.now() + 365 * 864e5).toUTCString();
  const cookiestring = "what could star options be"; //staroptions
  document.cookie = "star=" + encodeURIComponent(cookiestring) + "; expires=" + expires + "; path=/; SameSite=Strict;";
  //no expiry would allow the cookie to be automatically deleted upon browser exit.
}

function graphdraw(e) {
  if (graphdrawing) {
    const rect = graph.getBoundingClientRect();
    const x = Math.min(Math.floor((isTouch ? e.touches[0].clientX : e.clientX) - rect.left)-1, 200);
    const y = Math.min(Math.floor((isTouch ? e.touches[0].clientY : e.clientY) - rect.top)-2, 200);
    graphdot.style.left = x - 2 + "px";
    graphdot.style.top = y - 3 + "px";
    star.life = parseFloat((10.75 - x/20).toFixed(2));
    star.x = (200-y)+1;
    star.y = Math.ceil(((200-y)+1)/star.r);
    graphstat.innerHTML = `Pixel: ${star.x}px Life: ${star.life}s`;
  }
}

function leverdraw(e) {
  if (leverdrawing) {
    const rect = lever.getBoundingClientRect();
    let x = parseInt(((Math.floor((isTouch ? e.touches[0].clientX : e.clientX) - rect.left))/10))*10;
    x = Math.min(x, 200);
    // x = Math.max(x, 0);
    leverdot.style.left = 4 + x + "px";
    star.accelerate = (200-x) / 25;
    star.delay = 60*fps.vfps;
    leverstat.innerHTML = `Accelerate: ${star.accelerate}s`;
  }
}

function updatestat() {
  graphdot.style.left = 200-star.life*20+13 + "px";
  graphdot.style.top = 200-star.x-2 + "px";
  graphstat.innerHTML = `Pixel: ${star.x}px Life: ${star.life}s`;
  leverdot.style.left = 204 - star.accelerate * 25 + "px";
  leverstat.innerHTML = `Accelerate: ${star.accelerate}s`;
}


var qixsc = 2;
//var qixmap = new Array(200*200).fill(0);
var qixmask = document.createElement('canvas');
var qixmaskc = qixmask.getContext('2d');
qixmask.width = 960/qixsc;
qixmask.height = 618/qixsc;
var qixmap = null; // qixmaskc.createImageData(qixmask.width, qixmask.height);
var qixpos, qixpos2, qix_tails, qixline;

var glyphm = document.createElement('canvas');
var glyphmc = glyphm.getContext('2d');
var glyphc = document.createElement('canvas');
var glyphcc = glyphc.getContext('2d');
var glyph_shift = 1;

var glyphimg = new Image();
glyphimg.src = 'SOL/glyph.png';
glyphimg.onload = () => {
  glyphm.width = glyphimg.width;
  glyphm.height = glyphimg.height;
  glyphc.width = 16*59;
  glyphc.height = 16*38;

  glyphmc.drawImage(glyphimg, 0, 0);
  glyphmc.globalCompositeOperation = 'source-in';
  glyphmc.fillStyle = '#0f0';
  glyphmc.fillRect(0, 0, glyphimg.width, glyphimg.height);
}

function new_glyph(clear) {
  context.fillStyle = '#000';
  context.fillRect(0, 0, canvas.width, canvas.height);

  glyphscr.style.display = 'block';
  keyboard.style.display = 'inline-block';

  if (clear) {
    glyphcc.clearRect(0, 0, glyphc.width, glyphc.height);
    glyph_cursor = 0;
    glyph_row = 0;
  }
}

function glyph_update(code) {
  if (code.startsWith('Arrow')) {
    const x = (code === 'ArrowLeft' ? -1 : 0) + (code === 'ArrowRight' ? 1 : 0);
    const y = (code === 'ArrowUp' ? -1 : 0) + (code === 'ArrowDown' ? 1 : 0);
    if (glyph_cursor + x >= 0 && glyph_cursor + x < 59) {
      glyph_cursor += x;
    }
    if (glyph_row + y >= 0 && glyph_row + y < 38) {
      glyph_row += y;
    }
  }

  if (['ShiftLeft', 'ShiftRight'].includes(code)) {
    glyph_shift = 2;
  }

  if (code === 'Backspace') {
    if (glyph_cursor) {
      glyph_cursor -= 1;
    } else if (glyph_row) {
      glyph_row -= 1;
      glyph_cursor = 58;
    }

    glyphcc.clearRect(16 * glyph_cursor, 16 * glyph_row, 16, 16);
  }

  if (code === 'Enter') {
    if (glyph_row > 36) {
      glyph_row = 0;
    } else {
      glyph_row += 1;
    }
    glyph_cursor = 0;
  }

  if (code === 'Space') {
    glyphcc.clearRect(16 * glyph_cursor, 16 * glyph_row, 16, 16);

    // cursor jump
    if (glyph_cursor > 57) {
      if (glyph_row > 36) { 
        glyph_row = 0;
      } else {
        glyph_row += 1;
      }
      glyph_cursor = 0;
    } else {
      glyph_cursor += 1;
    }
  }

  if (code.startsWith('Key')) {
    const pos = 16 * 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('').indexOf(code.at(-1));
    const des = 16 * glyph_shift;

    glyphcc.clearRect(16 * glyph_cursor, 16 * glyph_row, 16, 16);
    glyphcc.drawImage(glyphm, pos, des, 16, 16, 16 * glyph_cursor, 16 * glyph_row, 16, 16);

    // cursor jump
    if (glyph_cursor > 57) {
      if (glyph_row > 36) {
        glyph_row = 0;
      } else {
        glyph_row += 1;
      }
      glyph_cursor = 0;
    } else {
      glyph_cursor += 1;
    }
  }

  const x = 16*glyph_cursor + 7;
  const y = 16*glyph_row + 7;

  hint.style.clipPath = `polygon(${x}px ${y}px,
${x+2}px ${y}px,
${x+2}px ${y+18}px,
${x}px ${y+18}px)`;
}



function new_qix() {
  const center = [
    Math.floor(qixmask.width/2),
    Math.floor(qixmask.height/2),
  ]
  qixpos = {
    x: center[0]*qixsc + qixsc,
    y: center[1]*qixsc + qixsc,
  };
  qixpos2 = {
    x: Math.floor((Math.random()*qixmask.width-2)+1)*qixsc,
    y: Math.floor((Math.random()*qixmask.height-2)+1)*qixsc,
  };
  qix_tails = [];
  qixline = {
    x: 0,
    y: 0,
  };

  //for (const n of Array(qixmap.data.length/4).keys()) {
  //  qixmap.data[n*4] = 24;
  //  qixmap.data[n*4+1] = 8;
  //  qixmap.data[n*4+2] = 64;
  //  qixmap.data[n*4+3] = 255;
  //}

  qixmaskc.drawImage(silhouette, 0, 0, silhouette.width, silhouette.height, 0, 0, qixmask.width, qixmask.height);
  qixmap = qixmaskc.getImageData(0, 0, qixmask.width, qixmask.height);
  clearSq(center[0]-9, center[1]-9, 19, 19);
  clearSq(center[0]-8, center[1]-8, 17, 17, 0); // 128 for semi-translucent
  clearSq(0, 0, qixmask.width, 0);
  clearSq(0, 0, 0, qixmask.height);
  clearSq(0, qixmask.height-1, qixmask.width, 0);
  clearSq(qixmask.width-1, 0, 0, qixmask.height);

  qix = true;
  drawqix(qixscr, qixpos, 0.75);
  drawqix(qixscr2, qixpos2, 2);
}

function qixscan() {
  const satellite = [Math.floor(qixpos2.x/qixsc), Math.floor(qixpos2.y/qixsc)];
  //if (!rgba) {
  //  const n = satellite[0]+satellite[1]*qixmask.width;
  //  rgba = qixmap.data.slice(n*4, n*4+4);
  //}
  const monstermap = new Uint8Array(qixmask.width*qixmask.height);
  let pixels = 0;
  for (const n of Array(qixmask.width*qixmask.height).keys()) {
    //if (qixmap.data.slice(n*4, n*4+4).every((r, i) => {return r === rgba[i];})) {
    if (qixmap.data[n*4+3] === 255) {
      monstermap[n] = 1;
    } else {
      pixels++;
      monstermap[n] = 0;
    }
  }
  while (satellite.length > 0) {
    const y = satellite.pop();
    const x = satellite.pop();
    if (x >= 0 && y >= 0 && x < qixmask.width && y < qixmask.height && monstermap[y*qixmask.width + x]) {
      monstermap[y * qixmask.width + x] = 0;
      satellite.push(x + 1, y);
      satellite.push(x - 1, y);
      satellite.push(x, y + 1);
      satellite.push(x, y - 1);
    }
  }

  for (const [n, pixel] of monstermap.entries()) {
    if (pixel) {
      pixels++;
      qixmap.data[n*4+3] = 0; // 128 for semi-translucent
    }
  }

  if (Math.floor((pixels/monstermap.length)*10000)/100 > 99) {
    setTimeout(() => {
      stopqix = true;
      winsoln += 1;
      winningcookie();
      makemenu();
    }, 0);
    setTimeout(() => {
      new_qix();
      qixupdate();
    }, 1500);
  }
  qixmaskc.putImageData(qixmap, 0, 0);
}

function clearSq(x, y, w, h, co = 0) {
  const ww = qixmask.width;
  const yh = h>0 ? [y,h+1] : [y+h,-h+1];
  const xw = w>0 ? [x,w+1] : [x+w,-w+1];
  const d = ww*yh[0]*4;
  const r = xw[0]*4;
  for (const i of Array(yh[1]).keys()) {
    const ii = d+ww*i*4 + 3;
    for (const j of Array(xw[1]).keys()) {
      qixmap.data[ii + r+j*4] = co;
    }
  }
  qixmaskc.putImageData(qixmap, 0, 0);
}

function stixpath(nx, land) {
  const x = Math.floor(qixpos.x/qixsc);
  const y = Math.floor(qixpos.y/qixsc);

  if (!qix_tails.length) {
    if (land) {
      return;
    }
    qix_tails = [[x, y, 0, 0]];
    qixline.x = x;
    qixline.y = y;
    return;
  }

  const stix = qix_tails.at(-1);
  if (qixline.d === 'x' && qixline.x === x) {
    stix[3] = y-stix[1];
  } else if (qixline.y === y) {
    stix[2] = x-stix[0];
  } else {
    qix_tails.push([x, y, 0, 0]);
    qixline.x = x;
    qixline.y = y;
    qixline.d = nx ? 'y' : 'x';
  }
}

function qixstep() {
  imawake();
  const speed = qixsc*60/fps.hz;
  const step = {
    x: (Keypress.KeyD || Keypress.ArrowRight ? speed : 0) + (Keypress.KeyA || Keypress.ArrowLeft ? -speed : 0),
    y: (Keypress.KeyS || Keypress.ArrowDown ? speed : 0) + (Keypress.KeyW || Keypress.ArrowUp ? -speed : 0),
  }

  if (
    qixpos.x + step.x >= 0 &&
    qixpos.y + step.y >= 0 &&
    qixpos.x + step.x <= qixmask.width*qixsc &&
    qixpos.y + step.y <= qixmask.height*qixsc
  ) {
    // death barrier
    const toMask = {
      x: Math.floor((qixpos.x + step.x)/qixsc),
      y: Math.floor((qixpos.y + step.y)/qixsc),
    }

    //result.textContent = 'X: ' + toMask.x + ' Y: ' + toMask.y;
    //result.style.display = 'block';

    const datapos = toMask.x + qixmask.width * toMask.y;
    if (qixmap.data[datapos * 4 + 3] !== 255) {
      // established land
      stixpath(step.x, true);
      qixpos.x += step.x;
      qixpos.y += step.y;
      if (mousec.hold) {
        mousec.hold = 0;
        for (const area of qix_tails) {
          clearSq(...area);
        }
        qix_tails = [];
        qixscan();
      }
    } else if (mousec.down) {
      // on adventure
      mousec.hold = 1;
      stixpath(step.x);
      qixpos.x += step.x;
      qixpos.y += step.y;
    }
  }
}

function qixstep2(k = false) {
  const speed = qixsc*60/fps.hz;
  const step = {
    x: k ? (Keypress.KeyH ? speed : 0) + (Keypress.KeyF ? -speed : 0) : Math.round((Math.random() - 0.5) * 8),
    y: k ? (Keypress.KeyG ? speed : 0) + (Keypress.KeyT ? -speed : 0) : Math.round((Math.random() - 0.5) * 8),
  }

  if (
    qixpos2.x + step.x >= 0 &&
    qixpos2.y + step.y >= 0 &&
    qixpos2.x + step.x <= qixmask.width*qixsc &&
    qixpos2.y + step.y <= qixmask.height*qixsc
  ) {
    // death barrier
    const toMask = {
      x: Math.floor((qixpos2.x + step.x)/qixsc),
      y: Math.floor((qixpos2.y + step.y)/qixsc),
    }

    const datapos = Math.floor(toMask.x + qixmask.width * toMask.y);
    if (qixmap.data[datapos * 4 + 3] === 255) {
      qixpos2.x += step.x;
      qixpos2.y += step.y;
    }
  }
}

function drawqix(scr, pos, size = 0) {
  const tail = [];
  let dir = {
    x: 0,
    y: 0,
    w: 0,
    h: 0,
    nw: 0,
    nh: 0,
  };

  const chdir = (x, y, nx, ny) => {
    if (dir.x > 0) {
      if (y > 0) {
        dir.w = qixsc;
        dir.h = 0;
      } else if (y < 0) {
        dir.w = 0;
        dir.h = 0;
      }
    } else if (dir.y > 0) {
      if (x < 0) {
        dir.w = qixsc;
        dir.h = qixsc;
      } else if (x > 0) {
        dir.w = qixsc;
        dir.h = 0;
      }
    } else if (dir.x < 0) {
      if (y < 0) {
        dir.w = 0;
        dir.h = qixsc;
      } else if (y > 0) {
        dir.w = qixsc;
        dir.h = qixsc;
      }
    } else if (dir.y < 0) {
      if (x > 0) {
        dir.w = 0;
        dir.h = 0;
      } else if (x < 0) {
        dir.w = 0;
        dir.h = qixsc;
      }
    } else {
      dir.nw = nx;
      dir.nh = ny;
      if (x > 0) {
        dir.w = qixsc;
        dir.h = 0;
      } else if (y > 0) {
        dir.w = qixsc;
        dir.h = qixsc;
      } else if (x < 0) {
        dir.w = 0;
        dir.h = qixsc;
      } else if (y < 0) {
        dir.w = 0;
        dir.h = 0;
      }
    };
  }

  if (size < 2) {
    for (const area of qix_tails) {
      const nx = area[0] + area[2];
      const ny = area[1] + area[3];
      chdir(area[2], area[3], area[0], area[1]);
      dir.x = area[2];
      dir.y = area[3];
      tail.push(`${dir.nw * qixsc + dir.w}px ${dir.nh * qixsc + dir.h}px`);
      dir.nw = nx;
      dir.nh = ny;
    };
    if (qix_tails.length) {
      tail.push(`${dir.nw * qixsc + dir.w}px ${dir.nh * qixsc + dir.h}px`);
    }
  }

  if (size) {
    const x = pos.x+0.5;
    const y = pos.y+0.5;
    tail.push(`${x}px ${y-10*size}px,
${x+10*size}px ${y}px,
${x}px ${y+10*size}px,
${x-10*size}px ${y}px,
${x}px ${y-10*size}px`);
  }

  if (size < 2) {
    dir = {
      x: 0,
      y: 0,
      w: 0,
      h: 0,
      nw: 0,
      nh: 0,
    };
    for (const area of qix_tails.toReversed()) {
      const nx = area[0] + area[2];
      const ny = area[1] + area[3];
      chdir(-area[2], -area[3], nx, ny, qixsc);
      dir.x = -area[2];
      dir.y = -area[3];
      dir.nw = nx;
      dir.nh = ny;
      tail.push(`${dir.nw*qixsc+dir.w}px ${dir.nh*qixsc+dir.h}px`);
    };
    if (qix_tails.length) {
      const area = qix_tails[0];
      if (area[2] < 0) {
        dir.w = 0;
        dir.h = 0;
      } else if (area[3] < 0) {
        dir.w = qixsc;
        dir.h = 0;
      } else if (area[2] > 0) {
        dir.w = qixsc;
        dir.h = qixsc;
      } else if (area[3] > 0) {
        dir.w = 0;
        dir.h = qixsc;
      }
      tail.push(`${area[0] * qixsc + dir.w}px ${area[1] * qixsc + dir.h}px`);
    }
  }
  scr.style.clipPath = `polygon(${tail.join(',')})`;
}

var stopqix = false;
var mousec = {
  down: 0,
  hold: 0,
};

function qixupdate() {
  if (qix_tails.length > 0 && !mousec.down) {
    const stix = qix_tails.at(-1);
    if (stix[2]) {
      stix[2] += stix[2] > 0 ? -1 : 1;
    } else if (stix[3]) {
      stix[3] += stix[3] > 0 ? -1 : 1;
    } else {
      qix_tails.pop();
    }

    qixpos.x = (stix[0] + stix[2])*qixsc;
    qixpos.y = (stix[1] + stix[3])*qixsc;
    drawqix(qixscr, qixpos, 0.75);
  } else if ('WASD'.split('').some((k) => Keypress['Key' + k]) || ['Left', 'Up', 'Right', 'Down'].some((k) => Keypress['Arrow' + k])) {
    qixstep();
    drawqix(qixscr, qixpos, 0.75);
  }

  if ('TFGH'.split('').some((k) => Keypress['Key' + k])) {
    qixstep2(true);
  } else {
    qixstep2();
  }

  drawqix(qixscr2, qixpos2, 2);
  if (!qix || stopqix) {
    stopqix = false;
    return;
  }

  context.fillStyle = '#000';
  context.fillRect(0, 0, canvas.width, canvas.height);

  context.drawImage(reveal, 0, 0, reveal.width, reveal.height, 0, 0, qixmask.width*qixsc, qixmask.height*qixsc);
  context.drawImage(qixmask, 0, 0, qixmask.width*qixsc, qixmask.height*qixsc);

  if (stopscreensaver) {
    requestAnimationFrame(qixupdate);
  }
};



function makemenu() {
  while (poppy.firstChild) {
    poppy.lastChild.remove();
  }

  let listener = null;
  let dismissed = false;
  const tc = 'click';

  options = document.createElement('DIV');
  options.classList = 'poppy right';

  morescr = document.createElement('DIV');
  morescr.classList = 'poppy right';

  staropt = document.createElement('DIV');
  staropt.classList = 'poppy right';

  const newmenu = (name, listener, args, arrow) => {
    const e = document.createElement('DIV');
    if (name) {
      e.innerHTML = name;
      e.style.margin = '0 20px';
      listener(e, args);

      if (arrow) {
        const a = document.createElement('DIV');
        a.classList = 'poppyarrow';

        const p = document.createElement('DIV');
        p.classList = 'poppywin';

        p.append(arrow);
        a.append(p);
        e.append(a);
      }
    } else {
      e.style.borderTop = "1px solid #848484";
      e.style.borderBottom = "1px solid #fff";
    }

    return e;
  };

  const unlock = (m, n, arrow) => {
    const e = document.createElement("DIV");
    e.textContent = m.join(n-winsoln);
    e.style.margin = "0 20px";
    e.style.color = "#848484";
    e.style.textShadow = "1px 1px #fff";

    if (arrow) {
      const a = document.createElement("DIV");
      a.classList = "poppyarrow";
      e.append(a);
    }

    return e;
  };

  const submenu = (e) => {
    e.addEventListener('mousedown', (e_) => {
      const t = e.lastChild.lastChild;
      if (!e_.target.classList.contains('right') && !e_.target.parentNode.classList.contains('right') && !e_.target.classList.contains('left') && !e_.target.parentNode.classList.contains('left') && t.style.display === 'block') {
        dismissed = true;
        t.style.display = 'none';
      }
    });

    e.addEventListener(tc, () => {
      if (dismissed) {
        dismissed = false;
        return;
      }

      for (const p of document.querySelectorAll('.poppywin')) {
        p.style.display = 'none';
      }

      const t = e.lastChild.lastChild;
      t.style.display = 'block';
      const where = e.getBoundingClientRect();
      const wheret = t.lastChild.getBoundingClientRect();
      const y = Math.min(
        0,
        document.documentElement.clientHeight - window.visualViewport.offsetTop - where.top - t.clientHeight,
      );
      const x = Math.min(
        0,
        document.documentElement.clientWidth - window.visualViewport.offsetLeft - where.right - t.clientWidth - 17,
      );

      t.style.top = y - 12 + 'px';
      if (x) {
        t.lastChild.classList = 'poppy left';
        t.style.left = -where.width - wheret.width - 36 + 'px';
      } else {
        t.lastChild.classList = 'poppy right';
        t.style.left = x + 'px';
      }
    });
  };

  const inputcell = (B) => {
    const d = document.createElement('INPUT');
    d.type = 'text';
    d.placeholder = B;
    d.style.margin = "2px 20px";
    d.style.display = "block";
    return d;
  }

  listener = (e, arg) => {
    e.addEventListener(tc, () => {
      solitaire = true;
      qix = false;
      glyph = false;
      keyboard.style.display = 'none';
      qixscr.style.display = 'none';
      qixscr2.style.display = 'none';
      glyphscr.style.display = 'none';
      stopscreensaver = true;
      drawn = arg;
      drawhint();
      readcard(sol);
    });
  };

  if (!winsoln || winsoln >= 5) {
    poppy.append(newmenu('Solitaire (draw 1)', listener, 1));
  } else {
    poppy.append(unlock(['Solitaire (draw 1) (', ' or reset)'], 5));
  }

  if (winsoln >= 1) {
    poppy.append(newmenu('Solitaire (draw 3)', listener, 3));
  } else {
    poppy.append(unlock(['Solitaire (draw 3) (', ')'], 1));
  }

  if (winsoln >= 5) {
    listener = (e) => {
      e.addEventListener(tc, () => {
        solitaire = false;
        glyph = false;
        hint.style.display = 'none';
        hintb.style.display = 'none';
        stopscreensaver = true;

        if (qix) {
          stopqix = true;
        }
        glyphscr.style.display = 'none';

        silhouette.src = 'silhouette.png';
        silhouette.onload = () => {
          qixmask.width = silhouette.width/2/qixsc;
          qixmask.height = silhouette.height/2/qixsc;
          reveal.src = 'flower.jpg';
          reveal.onload = () => {
            qixscr.style.display = 'block';
            qixscr2.style.display = 'block';
            keyboard.style.display = 'inline-block';
            new_qix();
            qixupdate();
          }
        }
      });
    };
    poppy.append(newmenu('Qix', listener));

    listener = (e) => {
      e.addEventListener(tc, () => {
        solitaire = false;
        glyph = true;
        qix = false;

        hint.style.display = 'block';
        const x = 7;
        const y = 7;

        hint.style.clipPath = `polygon(${x}px ${y}px,
${x+2}px ${y}px,
${x+2}px ${y+18}px,
${x}px ${y+18}px)`;

        hintb.style.display = 'none';
        stopscreensaver = true;
        qixscr.style.display = 'none';
        qixscr2.style.display = 'none';

        new_glyph(true);
      });
    };
    poppy.append(newmenu('Glyph', listener));
    //newmenu('Chess', listener, [5, 3]);
  } else {
    poppy.append(unlock(['Qix (', ')'], 5));
    poppy.append(unlock(['Glyph (', ')'], 5));
  }

  poppy.append(newmenu('Options', submenu, false, options));

  listener = (e) => {
      e.addEventListener(tc, () => {
      if (document.fullscreenElement) {
        document.exitFullscreen();
      } else {
        document.body.requestFullscreen();
      }
    });
  };
  options.append(newmenu('Fullscreen', listener));

  seed = inputcell('Load seed...');
  options.append(seed);

  seednow = inputcell('Alphanumeric seed');
  options.append(seednow);

  listener = (e) => {
    e.addEventListener(tc, () => {
      speaker("I couldn't remember what I've said recently!");
    });
  };
  options.append(newmenu('Dialog history', listener));

  listener = (e) => {
    e.addEventListener(tc, () => {
      winsoln = 0;
      winningcookie();
      makemenu();
    });
  };
  options.append(newmenu('Reset', listener));

  poppy.append(newmenu());

  // screensaver
  listener = (e, args) => {
    e.addEventListener(tc, () => {
      sideways = false;
      stopscreensaver = true;

      if (qix) {
        qix = false;
        keyboard.style.display = 'none';
        qixscr.style.display = 'none';
        qixscr2.style.display = 'none';
        glyphscr.style.display = 'none';
      }

      if (solitaire) {
        solitaire = false;
        hintb.style.display = 'none';
      }

      scr.color = args[0];
      scr.density = args[1];
      useimg = args[3];
      star.x = args[4];
      star.y = args[5];
      star.r = star.x/star.y;
      star.life = args[6];
      star.accelerate = args[7];
      ccolor = args[8] || '#000';
      lastcolor = args[8] || '#000';

      if (args[2]) {
        alpha.src = args[2];
        alpha.onload = () => {
          new_stars();
        }
      } else {
        new_stars();
      }

      if (graphdot) {
        updatestat();
      }
      savestar();
    });
  };
  poppy.append(newmenu('Flying Windows',               listener, [2,      75,   'win95.png', true,   95,  95,    1, 4, false]));

  if (winsoln >= 1) {
    poppy.append(newmenu('Slow Windows',               listener, [2,      75,   'win95.png', true,   95,  95,   10, 4, false]));
  } else {
    poppy.append(unlock(['Slow Windows (', ')'], 1));
  }

  if (winsoln >= 5) {
    poppy.append(newmenu('Big Windows',                listener, [2,      75,   'win95.png', true,  380, 380,    1, 4, false]));
  } else {
    poppy.append(unlock(['Big Windows (', ')'], 5));
  }

  if (winsoln >= 10) {
    poppy.append(newmenu('Starfield',                  listener, [0,      200,  false,       false,   4,   4, 1.50, 0, false]));
  } else {
    poppy.append(unlock(['Starfield (', ')'], 10));
  }

  if (winsoln >= 24) {
    morescr.append(newmenu('Flying Windows 24-bit',    listener, [4,      75,   'win95.png', true,   95,  95,    1, 4, false]));
    morescr.append(newmenu('Flying Windows pride',     listener, [3,      75,   'win95.png', true,   95,  95,    1, 4, false]));
    morescr.append(newmenu('8000 colorful stars',      listener, [4,      8000, false,       false,   4,   4, 1.25, 0, false]));
    morescr.append(newmenu('Surreal Xmas memory',      listener, ['xmas', 800,  'light.png', true,  190, 190, 1.25, 4, "#072700"]));
    morescr.append(newmenu('2000 flying Windows',      listener, [4,      2000, 'win95.png', true,   95,  95, 1.25, 4, false]));

    if (winsoln >= 64) {
      morescr.append(newmenu('Flying cards',           listener, ['card', 2,    false,       true, 71*2, 96*2, 1.25, 4, false]));
    } else {
      morescr.append(unlock(['Flying cards (', ')'], 64))
    }

    poppy.append(newmenu('More stars', submenu, false, morescr));
  } else {
    poppy.append(unlock(['More stars (', ')'], 24, true));
  }

  listener = (e) => {
    e.addEventListener(tc, () => {
      sideways = true;
      stopscreensaver = true;

      solitaire = false;
      glyph = false;
      qix = false;

      keyboard.style.display = 'none';
      qixscr.style.display = 'none';
      qixscr2.style.display = 'none';
      glyphscr.style.display = 'none';

      hint.style.display = 'block';
      hintb.style.display = 'none';

      movingflower.src = 'flower.jpg';
      movingflower.onload = () => {
        new_screensaver();
      };
    });
  };
  poppy.append(newmenu('Moving photo', listener));

  // solcomputer
  listener = (e, arg) => {
    e.addEventListener(tc, () => {
      if (arg) {
        solcomputer = debugcomputer ? true : !solcomputer;
        debugcomputer = false;
        computerspeed = 30;
      } else {
        solcomputer = !debugcomputer ? true : !solcomputer;
        debugcomputer = true;
        computerspeed = 1;
      }

      if (solitaire) {
        sol();
      } else {
        solitaire = true;
        qix = false;
        keyboard.style.display = 'none';
        qixscr.style.display = 'none';
        qixscr2.style.display = 'none';
        stopscreensaver = true;
        drawn = 1;
        readcard(sol);
      }
    });
  };
  //poppy.append(newmenu('Sol computer Solve!', listener, true));
  //poppy.append(newmenu('Sol computer Debug', listener));

  // paint
  listener = (e, arg) => {
    e.addEventListener(tc, () => {
      if (arg === 2) {
        ccolor = "rgba(0, 0, 0, 0)";
      } else if (arg) {
        ccolor = "rgba(0, 0, 0, 0.1)";
      } else {
        ccolor = lastcolor;
      }
    });
  };
  //poppy.append(newmenu('Clear', listener, 0));
  //poppy.append(newmenu('Ghost', listener, 1));
  //poppy.append(newmenu('Paint', listener, 2));

  poppy.append(newmenu());

  listener = (e, arg) => {
    e.addEventListener(tc, () => {
      if (arg) {
        scr.glide = !scr.glide;
        scr.fly = !!scr.glide;
      } else {
        scr.fly = scr.glide || !scr.fly;
        scr.glide = false;
      }
      savestar();
    });
  };
  if (winsoln >= 32) {
    poppy.append(newmenu('Fly', listener));
  } else {
    poppy.append(unlock(['Fly (', ')'], 32));
  }

  if (winsoln >= 64) {
    poppy.append(newmenu('Glide', listener, true));

    document.addEventListener('wheel', (event) => {
      const w = -event.wheelDelta/480;
      if (star.life + w > 10.5) {
        star.life = 10.5;
      } else if (star.life + w >= 0.75) {
        star.life = parseInt((star.life + w)*4)/4;
      }
      graphdot.style.left = -star.life * 20 + 200 + 13 + 'px';
      graphstat.innerHTML = `Pixel: ${star.x}px Life: ${star.life}s`;
    });

    poppy.append(newmenu('Star speed', submenu, false, staropt));

    graph = document.createElement('DIV');
    graph.classList = 'graph';
    staropt.appendChild(graph);

    graphstat = document.createElement('DIV');
    staropt.appendChild(graphstat);
    graphdot = document.createElement('DIV');
    graphdot.classList = 'graphdot';
    graph.appendChild(graphdot);

    graph.addEventListener('mousedown', () => {
      graphdrawing = true;
    });
    graph.addEventListener('touchstart', (e) => {
      graphdrawing = true;
      FFmove(e);
    });
    graph.addEventListener('touchmove', (e) => {
      FFmove(e);
    });
    graph.addEventListener('touchend', (e) => {
      FFup(e);
    });

    lever = document.createElement('DIV');
    lever.style.padding = '10px 0';

    DOMwriter = document.createElement('DIV');
    DOMwriter.classList = 'leverbar';
    lever.appendChild(DOMwriter);

    leverstat = document.createElement('DIV');
    leverdot = document.createElement('DIV');
    leverdot.classList = 'leverdot';

    staropt.appendChild(lever);
    staropt.appendChild(leverstat);
    staropt.appendChild(leverdot);

    updatestat();

    lever.addEventListener('mousedown', () => {
      leverdrawing = true;
    });
    lever.addEventListener('touchstart', (e) => {
      leverdrawing = true;
      FFmove(e);
    });
    lever.addEventListener('touchmove', (e) => {
      FFmove(e);
    });
    lever.addEventListener('touchend', (e) => {
      FFup(e);
    });

  } else {
    poppy.append(unlock(['Glide (', ')'], 64));
    poppy.append(unlock(['Star speed (', ')'], 64, true));
  }

  poppy.append(newmenu());

  listener = (e) => {
    e.addEventListener(tc, () => {
      fps.display = !fps.display;
      result.style.display = fps.display && !solitaire ? 'block' : 'none';
    });
  };
  poppy.append(newmenu('Display FPS', listener));

  if (winsoln >= 16) {
    listener = (e, arg) => {
      e.addEventListener(tc, () => {
        if (arg) {
          fps.throttle = true;
          fps.vfps = arg;
          fps.msec = 1000 / arg;
        } else {
          fps.throttle = false;
          fps.vfps = fps.hz;
          fps.msec = 1000 / fps.hz;
        }
        startTime = performance.now();
        star.delay = 60*fps.vfps;
        frameCount = 0;
        savestar();
      });
    };
    poppy.append(newmenu('Nostalgia FPS', listener, 15));
    poppy.append(newmenu('Unrestricted FPS', listener));
  } else {
    poppy.append(unlock(['Unrestricted FPS (', ')'], 16));
  }
}

var glyph_cursor = 0;
var glyph_row = 0;
function pressed(code, location, down) {
  if (location) {
    location -= 1;
  }

  if (KeypressX[code]) {
    //console.log(code, location, down ? 'down' : 'up', 'registered to', KeypressX[code][location].childNodes[0].innerHTML);
  } else {
    console.log(code, location, down ? 'down' : 'up', 'registered to', null);
    return;
  }

  if (down) {
    KeypressX[code][location].childNodes[0].classList.add('pressed');
    KeypressX[code][location].classList.add('pressed');
    Keypress[code] = true;

    // glyph stuff
    if (glyph) {
      glyph_update(code);
    }
  } else {
    KeypressX[code][location].childNodes[0].classList.remove('pressed');
    KeypressX[code][location].classList.remove('pressed');
    Keypress[code] = false;

    // glyph stuff
    if (['ShiftLeft', 'ShiftRight'].includes(code)) {
      glyph_shift = 1;
    }
  }
}

function FFkeydown(e) {
  const { code, location } = e;
  if (code !== 'F12') {
    //e.preventDefault();
  }
  pressed(code, location, true);
}

function FFkeyup(e) {
  //e.preventDefault();
  const { code, location} = e;
  pressed(code, location);
}

const KeypressX = {};

const registerk = {
  AltLeft: 'Alt',
  AltRight: 'Alt',
  BracketLeft: '[ {',
  BracketRight: '] }',
  Backquote: '` ~',
  Backslash: '\\ |',
  Backspace: 'Backspace',
  CapsLock: 'Caps Lock',
  Comma: ', \<',
  ControlLeft: 'Ctrl',
  ControlRight: 'Ctrl',
  Enter: 'Enter',
  Equal: '= +',
  Escape: 'Esc',
  MetaRight: 'Win',
  MetaLeft: 'Win',
  Minus: '- _',
  Period: '. \>',
  Quote: '\' "',
  Semicolon: '; :',
  ShiftLeft: 'Shift',
  ShiftRight: 'Shift',
  Slash: '/ ?',
  Space: 'Space',
  Tab: 'Tab',

  PrintScreen: 'PrtSc',
  ScrollLock: 'ScrLk',
  Pause: 'Pause',

  Insert: 'Ins',
  Home: 'Home',
  PageUp: 'PgUp',

  Delete: 'Del',
  End: 'End',
  PageDown: 'PgDn',
};

for (const k of ['F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10', 'F11', 'F12']) {
  registerk[k] = k;
}

for (const [n, k] of ['0 )', '1 !', '2 @', '3 #', '4 $', '5 %', '6 ^', '7 &', '8 *', '9 ('].entries()) {
  registerk['Digit' + n] = k;
}

for (const k of 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('')) {
  registerk['Key' + k] = k;
}

for (const [n, k] of '←↑→↓'.split('').entries()) {
  registerk['Arrow' + ['Left', 'Up', 'Right', 'Down'][n]] = k;
}

const Keypress = Object.fromEntries(Object.keys(registerk).map((k) => [k, false]));

function drawkeyboard(socket, keycaps, w, c='keycap', logo) {
  for (const ks of keycaps) {
    for (const k of ks){
      const cap = document.createElement('DIV');
      cap.textContent = k;
      cap.classList = 'face';
      if (logo) {
        cap.classList.add('windo')
      }

      const keycap = document.createElement('DIV');
      keycap.classList = c;
      if (w) {
        cap.style.width = '100%';
        keycap.style.width = w + 'px';
      }
      keycap.appendChild(cap);

      const x = Object.keys(registerk).find(kx => registerk[kx] === k);

      if (KeypressX[x]) {
        KeypressX[x].push(keycap);
      } else {
        KeypressX[x] = [keycap];
      }

      const location = KeypressX[x].length === 1 ? 0 : KeypressX[x].length;
      if (isTouch) {
        keycap.addEventListener('touchstart', (e) => {
          e.preventDefault();
          pressed(x, location, true);
        });
        keycap.addEventListener('touchend', (e) => {
          e.preventDefault();
          pressed(x, location, false);
        });
      } else {
        keycap.addEventListener('mousedown', (e) => {
          e.preventDefault();
          pressed(x, location, true);
        });
        keycap.addEventListener('mouseenter', (e) => {
          if (mousec.down) {
            e.preventDefault();
            pressed(x, location, true);
          }
        });
        keycap.addEventListener('mouseleave', (e) => {
          e.preventDefault();
          pressed(x, location, false);
        });
        keycap.addEventListener('mouseup', (e) => {
          e.preventDefault();
          pressed(x, location, false);
        });
      }
      socket.appendChild(keycap);
    }
  }
}

function windo(win) {
  const mask = document.createElement('canvas');
  mask.width = 95;
  mask.height = 95;
 
  let maskcontext = mask.getContext('2d');
  maskcontext.fillStyle = "#088";
  maskcontext.drawImage(win, 0, 0);
  maskcontext.globalCompositeOperation = "source-in";
  maskcontext.fillRect(0, 0, 95, 95);
 
  let promise = new Promise(canvasToAB(mask, 'png'))
  promise.then(function(arri){
    const a = ABtoAB(arri);
    const wind = document.getElementsByClassName("windo");
    for (const win of wind) {
      const img = document.createElement("img");
      img.style.height = "10px";
      //img.style.imageRendering = "pixelated";
      img.src = ABtoURL(a);
      win.innerHTML = img.outerHTML;
    }
  })
};

var esc, f1, f5, f9, alphakeys, homekeys2, homekeys, arrows, numpad2, numpad;

function createkeyboard() {
  const keydiv = (sockets, left) => {
    const d = document.createElement('DIV');
    d.style.display = 'inline-block';

    if (left) {
      d.style.marginLeft = left + 'px';
    }

    for (const s of sockets) {
      if (s) {
        d.appendChild(s);
      } else {
        const x = document.createElement('DIV');
        d.appendChild(x);
      }
    }

    keyboard.append(d);
  }

  const keysocket = (right, top) => {
    const d = document.createElement('DIV');
    d.classList = 'keysocket';

    if (right) {
      d.style.marginRight = right + 'px';
    }

    if (top) {
      d.style.marginTop = top + 'px';
    }
    return d;
  }



  esc = keysocket(44);
  f1 = keysocket(24);
  f5 = keysocket(24);
  f9 = keysocket();
  alphakeys = keysocket(0, 12);
  keydiv([esc, f1, f5, f9, null, alphakeys]);

  drawkeyboard(esc, [['Esc']], null, 'keycap2');
  drawkeyboard(f1, [['F1', 'F2', 'F3', 'F4']]);
  drawkeyboard(f5, [['F5', 'F6', 'F7', 'F8']], null, 'keycap2');
  drawkeyboard(f9, [['F9', 'F10', 'F11', 'F12']]);

  DOMwriter = document.createElement('DIV');
  DOMwriter.classList = 'keysocketrow';
  alphakeys.appendChild(DOMwriter);

  drawkeyboard(DOMwriter, [['` ~', '1 !', '2 @', '3 #', '4 $', '5 %', '6 ^', '7 &', '8 *', '9 (', '0 )', '- _', '= +']]);
  drawkeyboard(DOMwriter, [['Backspace']], 88, 'keycap2');

  DOMwriter = document.createElement('DIV');
  DOMwriter.classList = 'keysocketrow';
  alphakeys.appendChild(DOMwriter);

  drawkeyboard(DOMwriter, [['Tab']], 58, 'keycap2');
  drawkeyboard(DOMwriter, ['QWERTYUIOP', ['[ {', '] }']]);
  drawkeyboard(DOMwriter, [['\\ |']], 59);

  DOMwriter = document.createElement('DIV');
  DOMwriter.classList = 'keysocketrow';
  alphakeys.appendChild(DOMwriter);

  drawkeyboard(DOMwriter, [['Caps Lock']], 68, 'keycap2');
  drawkeyboard(DOMwriter, ['ASDFGHJKL', ['; :', '\' "']]);
  drawkeyboard(DOMwriter, [['Enter']], 100, 'keycap2');

  DOMwriter = document.createElement('DIV');
  DOMwriter.classList = 'keysocketrow';
  alphakeys.appendChild(DOMwriter);

  drawkeyboard(DOMwriter, [['Shift']], 95, 'keycap2');
  drawkeyboard(DOMwriter, ['ZXCVBNM', [', <', '. >', '/ ?']]);
  drawkeyboard(DOMwriter, [['Shift']], 124, 'keycap2');

  DOMwriter = document.createElement('DIV');
  DOMwriter.classList = 'keysocketrow';
  alphakeys.appendChild(DOMwriter);

  drawkeyboard(DOMwriter, [['Ctrl']], 43, 'keycap2');
  drawkeyboard(DOMwriter, [['Win']], 43, 'keycap2', true);
  drawkeyboard(DOMwriter, [['Alt']], 43, 'keycap2');
  drawkeyboard(DOMwriter, [['Space']], 296);
  drawkeyboard(DOMwriter, [['Alt']], 43, 'keycap2');
  drawkeyboard(DOMwriter, [['Win']], 43, 'keycap2', true);
  drawkeyboard(DOMwriter, [['Fn']], 43, 'keycap2');
  drawkeyboard(DOMwriter, [['Ctrl']], 43, 'keycap2');



  // TKL
  if (true) {
    homekeys2 = keysocket();
    homekeys = keysocket(0, 12);
    arrows = keysocket(0, 44);
    keydiv([homekeys2, null, homekeys, null, arrows], 6);

    drawkeyboard(homekeys2, [['PrtSc', 'ScrLk', 'Pause']], null, 'keycap2');
    drawkeyboard(homekeys, [['Ins', 'Home', 'PgUp']], null, 'keycap2');

    DOMwriter = document.createElement('BR');
    homekeys.appendChild(DOMwriter);

    drawkeyboard(homekeys, [['Del', 'End', 'PgDn']], null, 'keycap2');

    DOMwriter = document.createElement('DIV');
    DOMwriter.innerHTML = '&nbsp;';
    DOMwriter.classList = 'plate right';
    arrows.appendChild(DOMwriter);

    drawkeyboard(arrows, ['↑'], null, 'keycap2');

    DOMwriter = document.createElement('DIV');
    DOMwriter.innerHTML = '&nbsp;';
    DOMwriter.classList = 'plate left';
    arrows.appendChild(DOMwriter);

    DOMwriter = document.createElement('BR');
    arrows.appendChild(DOMwriter);

    drawkeyboard(arrows, ['←', '↓', '→'], null, 'keycap2');
  }


  // Full
  if (false) {
    numpad2 = keysocket();
    numpad = keysocket(0, 12);
    keydiv([numpad2, null, numpad], 6);

    drawkeyboard(numpad2, [['Cal', 'Mute', 'Dec', 'Inc']], null, 'keycap2');
    drawkeyboard(numpad, [['Num'], '/', '*', '-'], null, 'keycap2');

    DOMwriter = document.createElement('BR');
    numpad.appendChild(DOMwriter);

    drawkeyboard(numpad, ['7', '8', '9']);

    drawkeyboard(numpad, [['+']], null, 'keycap2');
    //const numplus = KeypressX['Plus'][0];
    //numplus.childNodes[0].style.height = '84px';
    //numplus.style.float = 'right';

    DOMwriter = document.createElement('BR');
    numpad.appendChild(DOMwriter);

    drawkeyboard(numpad, ['4', '5', '6']);

    DOMwriter = document.createElement('BR');
    numpad.appendChild(DOMwriter);

    drawkeyboard(numpad, ['1', '2', '3',]);
    drawkeyboard(numpad, [['Enter']], null, 'keycap2');
    //const numenter = KeypressX['Enter'][1];
    //numenter.childNodes[0].style.height = '84px';
    //numenter.style.float = 'right';

    DOMwriter = document.createElement('BR');
    numpad.appendChild(DOMwriter);

    drawkeyboard(numpad, ['0'], 80);
    drawkeyboard(numpad, ['.']);
  }
}

function resize() {
  canvas.width = document.documentElement.clientWidth;
  canvas.height = document.documentElement.clientHeight;
  context.imageSmoothingEnabled = false;
  dim.x = Math.floor(canvas.width/2)
  dim.y = Math.floor(canvas.height/2);
  scr.friction.x = Math.ceil(canvas.width/canvas.height);
  scr.friction.y = Math.ceil(canvas.height/canvas.width);
}

window.onload = () => {
  result.style.display = fps.display ? 'block' : 'none';
  document.title = 'Starfield';
  glyphscr.appendChild(glyphc);
  let win = document.createElement('IMG');
  win.src = 'win95.png';
  win.onload = () => {
    windo(win);
  }

  createkeyboard();

  if (isTouch) {
    canvas.addEventListener('touchstart', (e_) => {
      FFdown(e_);
      if (busyclick) {
        clearTimeout(busyclick);
        busyclick = false;
      } else {
        busyclick = setTimeout(() => {
          rightc(e_);
        }, 500);
      }
    });
    canvas.addEventListener('touchend', (e_) => {
      FFup(e_);
      clearTimeout(busyclick);
      busyclick = false;
    });
    canvas.addEventListener('touchmove', (e_) => {
      FFmove(e_);
      clearTimeout(busyclick);
      busyclick = false;
    });
    canvas.addEventListener('contextmenu', (e_) => {
      e_.preventDefault();
    });
    poppy.addEventListener('touchstart', (e_) => {
      if (e_.touches.length > 1) {
        ZOOKd = true;
      }
    });
  } else {
    document.addEventListener('mousedown', FFdown);
    document.addEventListener('mouseup', FFup);
    document.addEventListener('mousemove', FFmove);
    document.addEventListener('contextmenu', (e_) => {
      rightc(e_);
    });
  }

  //let e = document.createElement("DIV");
  //e.innerHTML = '&times;';
  //e.style.cursor = 'pointer';
  //e.style.fontSize = '30px';
  //e.addEventListener('click', () => {
  //  poppy.style.display = 'none';
  //});
  //poppy.appendChild(e);

  const cookies = document.cookie.split(';');
  for (const cookie of cookies) {
    const ck = cookie.trimStart();
    if (ck.indexOf('winsol=') == 0) {
      winsoln = parseInt(decodeURIComponent(ck.substring('winsol='.length, ck.length)));
    }
  }

  makemenu();

  document.addEventListener('keydown', FFkeydown);
  document.addEventListener('keyup', FFkeyup);
  addEventListener('resize', () => {
    if (!winanim) {
      resize();
    }

    if (solitaire && !winanim) {
      sol();
    }
  });

  //addEventListener('visibilitychange', () => {
  //  frameCount = 0;
  //});

  canvas.style.cursor = 'pointer';
  document.body.append(canvas);

  dim.x = Math.floor(canvas.width/2)
  dim.y = Math.floor(canvas.height/2);
  mousepos.x = dim.x;
  mousepos.y = dim.y;
  scr.friction.x = Math.ceil(canvas.width/canvas.height);
  scr.friction.y = Math.ceil(canvas.height/canvas.width);

  alpha.src = 'win95.png';
  alpha.onload = () => {
    new_stars();
  }

  const close = document.getElementById('close');
  close.addEventListener('click', () => {
    dialogbox.style.display = 'none';
  });
}
</script>
</head>
<body>
<div id='fgbg'></div>
<div class='hintscreen'><div class='hint' id='hint'></div></div>
<div class='hintscreen'><div class='hint' id='hint2'></div></div>
<div class='hintscreen'><div class='hint' id='hint3'></div></div>
<div class='hintscreen'><div class='hint' id='hint4'></div></div>
<div class='hintscreen'><div class='hint' id='hintb'></div></div>
<div class='hintscreen'><div class='hint' id='qixscr'></div></div>
<div class='hintscreen'><div class='hint' id='qixscr2'></div></div>
<div id='result'></div>
<div id='glyphscr'></div>
<div id='stdout'>Output:</div>
<div class='poppy' id='poppy'></div>
<div id='touchloc'></div>
<div id='touchlocm'></div>
<div id='dialogbox'><div id='close'>&times;</div><div id='dialog'></div></div>
<div id='keyboard'></div>
</body>
</html>
