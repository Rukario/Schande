<!DOCTYPE html>
<html><head>
<meta charset="UTF-8">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="white">
<title>Starfield</title>
<style>
html, body {
  background-color: #000;
  margin: 0;
  font-family: Helvetica,Arial,Sans-Serif;
  -webkit-user-select: none;
  overflow: hidden;
}
canvas {
  position: absolute;
  image-rendering: pixelated;
}

#fgbg {
  display: none;
  width: 100%;
  height: 100%;
  position: absolute;
  background-image: url("bg.png");
  image-rendering: pixelated;
  mix-blend-mode: multiply;
  z-index: 2;
  pointer-events: none;
}

#result {
  white-space: pre;
  display: none;
  color: #0f0;
  font-family: courier;
  font-size: 24px;
  z-index: 1;
  pointer-events: none;
  position: absolute;
}

#poppy {
  background: #c0c0c0;
  position:absolute;
  display:none;
  z-index: 3;
  padding: 0px 25px;
  line-height:1.5;
  box-shadow: inset -1px -1px #000, inset 1px 1px #c0c0c0, inset -2px -2px #848484, inset 2px 2px #fff;
  cursor: default;
}
</style>
<script>
var fps = 20;
var speed = 60;
var throttlebyfps = true;
var displayfps = false;
var life = 1.25; // per second
var pixel = {'x':95, 'y':95};
var density = 75;
var frustum = 0.8 + 0.4;
var colorful = 3;
var fly = false;
var glide = false;
var solitaire = false;
var scale = 1;

var dim = {'x':0, 'y': 0};
var mousepos = {'x':0, 'y':0};
var fpsInterval = 1000 / fps;
var ti = Date.now();

var isTouch = 'ontouchstart' in window ? true : false;
var busyclick = false;

var alpha = new Image();

var foliage = new Image();
foliage.src = 'spruce.png';
var ccolor = '#000';
var lastcolor = '#000';

var useimg = true;
var ismask = true;


function ABtoURL(ab){
  return URL.createObjectURL(new Blob(ab, {type: 'application/octet-stream'}));
}

function ABtoIMG(ab){
  img = document.createElement("img")
  img.src = ABtoURL(ab);
  return img;
}

function ABtoAB(ab){
  return [new Uint8Array(ab)]
}

function canvasToAB(c, ext="png"){
  return function(resolve) {
    c.toBlob((blob0) => {
      var fr = new FileReader();
      fr.readAsArrayBuffer(blob0);
      fr.onload = () => {
        arri = new Uint8Array(fr.result);
        resolve(arri);
      };
    }, 'image/' + ext);
  }
}

function canvasToFrame(stars, mask, callback, interFrameN){
  let promise = new Promise(canvasToAB(mask, 'png'))
  promise.then(function(arri){
    newstar(ABtoIMG(ABtoAB(arri)));
    callback(interFrameN+1);
  })
}

var c = document.createElement('canvas');
c.width = document.documentElement.clientWidth;
c.height = document.documentElement.clientHeight;

var context = c.getContext('2d');
context.imageSmoothingEnabled = false;

var idlecursor = false;
var idlescreensaver = false;
var busyscreensaver = false;
var stopscreensaver = false;
var stars = [];
var frameCount = 0;
var startTime;



function newstar(star) {
  const age = Math.random()*speed*life%(0.66*speed*life);
  const x = ((Math.random()-0.5)*c.width*frustum/(speed*life))*(speed*life-age);
  const y = ((Math.random()-0.5)*c.height*frustum/(speed*life))*(speed*life-age);
  stars.push([age, x, y, star]);
}

function screensaver(resolve) {
  const update = () => {
    if (stopscreensaver) {
      return resolve(true);
    }

    requestAnimationFrame(update);

    now = Date.now();
    elapsed = now - ti;

    if (!throttlebyfps || elapsed > fpsInterval) {
      ti = now - (elapsed % fpsInterval);
      context.fillStyle = ccolor;
      context.fillRect(0, 0, c.width, c.height);

      for (const star of stars) {
        if (star[0] === 0) {
          star[1] = (Math.random()-0.5)*c.width*frustum + (glide?mousepos.x-dim.x:0);
          star[2] = (Math.random()-0.5)*c.height*frustum + (glide?mousepos.y-dim.y:0);
          //star[1] = Math.floor(c.width/6) + Math.floor(Math.random()*c.width/1.5);
          //star[2] = Math.floor(c.height/6) + Math.floor(Math.random()*c.height/1.5);
          //star[3] = colorful ? `rgb(${Math.floor(Math.random()*256)},${Math.floor(Math.random()*256)},${Math.floor(Math.random()*256)})` : '#fff';
        }
        const dot = {'x':Math.ceil(star[0]/(speed*life/pixel.x)), 'y':Math.ceil(star[0]/(speed*life/pixel.y))};

        const sx = (star[1]+(fly||glide?(mousepos.x-dim.x)/8:0))/(speed*life-star[0])*speed*life + (glide?star[0]*speed/life*(-(mousepos.x-dim.x)/1800):0);
        const sy = (star[2]+(fly||glide?(mousepos.y-dim.x)/8:0))/(speed*life-star[0])*speed*life + (glide?star[0]*speed/life*(-(mousepos.y-dim.y)/1800):0);
        if (glide) {
          star[1] -= (mousepos.x-dim.x)/200/life;
          star[2] -= (mousepos.y-dim.y)/200/life;
        }

        if ( sx < (glide?Math.min(mousepos.x-c.width,-dim.x):-dim.x)-pixel.x/2 || sy < (glide?Math.min(mousepos.y-c.height,-dim.y):-dim.y)-pixel.y/2 || sx > (glide?Math.max(mousepos.x,dim.x):dim.x)+pixel.x/2 || sy > (glide?Math.max(mousepos.y,dim.y):dim.y)+pixel.y/2 || star[0] > (speed*life)) {
          star[0] = 0;
        } else {
          star[0] += speed / fps;
        }

        //if (star[1] < dim.x) {
        //  star[1] -= ((dim.x/star[1])-1)*(1+star[0]/5);
        //} else {
        //  star[1] += ((dim.x/(c.width-star[1]))-1)*(1+star[0]/5);
        //}
        //
        //if (star[2] < dim.y) {
        //  star[2] -= ((dim.y/star[2])-1)*(1+star[0]/5);
        //} else {
        //  star[2] += ((dim.y/(c.height-star[2]))-1)*(1+star[0]/5);
        //}
        //
        //context.fillRect(Math.ceil(star[1]), Math.ceil(star[2]), dot.x, dot.y);
        //
        //if ( star[1] < 0 || star[2] < 0 || star[1] > c.width || star[2] > c.height || star[0] > speed*life) {
        //  star[0] = 0;
        //} else {
        //  star[0] += 1;
        //}

        if (useimg) {
          //maskcontext.fillStyle = star[3];
          //maskcontext.drawImage(alpha, 0, 0);
          //maskcontext.globalCompositeOperation = "source-in";
          //maskcontext.fillRect(0, 0, pixel.x, pixel.y);
          //context.drawImage(mask, Math.ceil(sx + dim.x - dot.x/2), Math.ceil(sy + dim.y - dot.y/2), dot.x, dot.y);

          //context.fillStyle = star[3];
          //context.fillRect(Math.ceil(sx + dim.x - dot.x/2), Math.ceil(sy + dim.y - dot.y/2), dot.x, dot.y);
          //context.drawImage(alpha, Math.ceil(sx + dim.x - dot.x/2), Math.ceil(sy + dim.y - dot.y/2), dot.x, dot.y);
          context.drawImage(star[3], Math.ceil(sx + dim.x - dot.x/2), Math.ceil(sy + dim.y - dot.y/2), dot.x, dot.y);
        } else {
          context.fillStyle = star[3];
          context.fillRect(Math.ceil(sx + dim.x - dot.x/2), Math.ceil(sy + dim.y - dot.y/2), dot.x, dot.y);
        }
      }
      const sinceStart = now - startTime;
      const toodiff = sinceStart / ++frameCount;
      if (toodiff > (1000/fps) + 2) {
        startTime = Date.now();
        frameCount = 0;
        fps = isFinite(fps) ? fps/1.1 : 120;
      } else {
        fps = Math.round(1000 / toodiff * 100) / 100;
      }
      result.innerHTML = `Uninterrupted for ${(Math.round(sinceStart / 1000 * 100) / 100).toFixed(2).padStart(3, '0')} seconds @ ${fps.toFixed(2).padStart(3, '0')} fps`;
    }
  };
  startTime = Date.now();
  frameCount = 0;
  update();
}

function new_screensaver() {
  let promise = new Promise((resolve) => {
    busyscreensaver = true;
    screensaver(resolve);
  });

  Promise.all([promise]).then(() => {
    busyscreensaver = false;
    stopscreensaver = false;
  });
}

const xlight = ['#f00', '#f90', '#390', '#06f', '#90c'];

function starcolor(colorful) {
  switch (colorful) {
    case 3:
      return `#${Math.floor(Math.random()*16).toString(16)}${Math.floor(Math.random()*16).toString(16)}${Math.floor(Math.random()*16).toString(16)}`;
    case 2:
      return `#${Math.floor(4 + Math.random()*12).toString(16)}${Math.floor(4 + Math.random()*12).toString(16)}${Math.floor(4 + Math.random()*12).toString(16)}`;
    case 1:
      return xlight[Math.floor(Math.random() * xlight.length)];
    default:
      return '#fff';
  }
}

function new_stars() {
  stars = [];
  function variant(i) {
    if (i == density) {
      new_screensaver();
      return;
    }

    if (ismask) {
      let mask = document.createElement('canvas');
      mask.width = 95;
      mask.height = 95;

      let maskcontext = mask.getContext('2d');
      if (colorful == 1 && Math.floor(Math.random()*4)) {
        maskcontext.drawImage(foliage, 0, 0);
      } else {
        maskcontext.fillStyle = starcolor(colorful);
        maskcontext.drawImage(alpha, 0, 0);
        maskcontext.globalCompositeOperation = "source-in";
        maskcontext.fillRect(0, 0, 95, 95);
      };
      canvasToFrame(stars, mask, variant, i);
    } else if (useimg) {
      for (let n=0;n<density;n++) {
        new_deck();
        readcard(new_screensaver, true);
      }
    } else {
      for (let n=0;n<density;n++) {
        newstar(starcolor(colorful));
      }
      new_screensaver();
    }
  }
  variant(0);
}



var deck = [];
var cards = {};
var slots = [];
var cheatslots = 8;
var ncard = 52;
var drawn = 1;
var draw = [-1, -1, true];
var rev = -1;
var slothistory = [];
var solcomputer = false;
var readycomputer = false;
var computerspeed = 30;
var winanim = false;
var winid = false;
var cardsize = [71*scale, 96*scale];
var gap = {'x':11*scale, 'y':5*scale};
var solsize = [((gap.x+1)*scale+cardsize[0])*(7+cheatslots), 400*scale];

var snapshot = () => {
  rev ++;
  if (rev < slothistory.length){
    slothistory.splice(rev);
  }
  slothistory.push(JSON.parse(JSON.stringify([deck, draw, slots])));
}

var drawx = () => {
  if (draw[0] < slots[0][1].length-1) {
    const dd = Math.min(drawn, slots[0][1].length-deck.length);
    draw[0] += dd;
    for (const i of [...Array(dd).keys()]) {
      deck.push(slots[0][1][draw[0]-dd+1+i]);
    }
  } else {
    draw[0] = -1;
    draw[2] = false;
    deck = [];
  }
}



function new_deck() {
  draw = [-1, -1, true];
  rev = -1;
  deck = [];
  winanim = false;
  clearTimeout(winid);
  winid = false;
  var factorysealed = [];
  for (const card of ['card1', 'card2', 'deck', 'slot', 'undo', 'undo3']){
    cards[card] = new Image();
    cards[card].src = `SOL/${card}.png`;
  } 
  for (const [s, suit] of ['C', 'D', 'S', 'H'].entries()){
    for (const [n, cs] of [0, 'A', 2, 3, 4, 5, 6, 7, 8, 9, 10, 'J', 'Q', 'K'].entries()){
      if (n) {
        card = `${s}${n.toString(16)}`;
        cards[card] = new Image();
        cards[card].src = `SOL/${cs}${suit}.png`;
        factorysealed.push(card);
      }
    }
  }

  ncard = factorysealed.length;

  while (factorysealed.length) {
    let pick = Math.floor(Math.random() * factorysealed.length);
    deck.push(factorysealed[pick]);
    factorysealed.splice(pick, 1);
  }

  slots = Array(12+cheatslots);
  for (const pos of [...Array(13+cheatslots).keys()]){
    slots[pos] = [[], []];
  };

  let used = 0;
  for (const pos of [...Array(7).keys()]) {
    used += pos-1;
    slots[pos+5][1].push(deck[pos+ncard-7]);
    for (const p of [...Array(pos).keys()]){
      slots[pos+5][0].push(deck[used+ncard-27+p]);
    }
  }
  slots[0][1] = deck.slice(0, ncard-28);
  deck = [];
  slothistory = [];
  snapshot();

  //insta win
  //for (const pos of [...Array(4).keys()]){
  //  for (const [n, cs] of [0, 'A', 2, 3, 4, 5, 6, 7, 8, 9, 10, 'J', 'Q', 'K'].entries()){
  //    if (n) {
  //      card = `${pos}${n.toString(16)}`;
  //      slots[pos+1][1].push(card);
  //    }
  //  }
  //}
}

function winsol() {
  winanim = true;
  const flycards = [];
  const gravity = {'x':0, 'y':1};
  const kinecticloss = 0.85;
  let i = 0;

  for (const card of [...Array(ncard/4).keys()]){
    for (const pos of [...Array(4).keys()]){
      const falldir = Math.floor(Math.random()*14-7)+1;
      const dep = Math.ceil((12-card)/4)*scale;
      flycards.push({'card':slots[pos+1][1][12-card], 'x':gap.x*4 + gap.x*pos + cardsize[0]*(pos+3) + dep*2, 'y':gap.y + dep, 'xdir':1, 'ydir':1, 'xvel':falldir ? falldir : -2, 'yvel':-Math.ceil(Math.random()*18)});
    }
  }

  const update = () => {
    const flycard = flycards[i];
    flycard.xvel += gravity.x;
    flycard.yvel += gravity.y;
    flycard.x += (flycard.xvel * flycard.xdir);
    flycard.y += (flycard.yvel * flycard.ydir);
    if (flycard.x < -cardsize[0] || flycard.x > c.width) {
      clearTimeout(idlescreensaver);
      i++;
      //flycard.xvel = -flycard.xvel;
    }
    if (!winanim || i === ncard) {
      idlescreensaver = setTimeout(() => {
        if (stopscreensaver) {
          stopscreensaver = false;
          new_screensaver();
        }
      }, 1000);
      return;
    }
    requestAnimationFrame(update);
    if (flycard.y + cardsize[1] > solsize[1]) {
        flycard.y = solsize[1] - cardsize[1];
        flycard.yvel = -flycard.yvel*kinecticloss;
    }
    context.drawImage(cards[flycard["card"]], flycard.x, flycard.y, ...cardsize);
  }

  winid = setTimeout(update, 1000);
}

function sol() {
  context.fillStyle = "#003D00";
  context.fillRect(0, 0, c.width, c.height);

  context.fillStyle = "#007D00";
  context.fillRect(0, 0, ...solsize);

  context.drawImage(cards['deck'], gap.x, gap.y, ...cardsize);
  context.drawImage(cards[drawn === 3 ? 'undo3' : 'undo'], gap.x*3 + cardsize[0]*2, gap.y, cardsize[0], cardsize[1]);

  const dd = drawn-1-(draw[1]+drawn)%drawn;
  const ded = Math.min(drawn, deck.length);

  if (dd && draw[0] < draw[1]+drawn && draw[2]) {
    context.strokeStyle = "#00FF00";
    context.lineWidth = 2;
    context.beginPath();
    const coord = cardsize[0]*3+gap.x*(drawn*0.6-0.8);
    context.arc(coord, gap.y*2, 8, 0, Math.PI*2);
    context.moveTo(coord - 6, gap.y*2 - 6);
    context.lineTo(coord + 6, gap.y*2 + 6);
    context.stroke();
  }


  context.drawImage(cards['slot'], 257*scale, gap.y, ...cardsize);
  context.drawImage(cards['slot'], 339*scale, gap.y, ...cardsize);
  context.drawImage(cards['slot'], 421*scale, gap.y, ...cardsize);
  context.drawImage(cards['slot'], 503*scale, gap.y, ...cardsize);

  //for (const pos of [...Array(cheatslots).keys()]) {
  //  context.drawImage(cards['busy'], 585*scale + 82*scale*pos, gap.y*2 + cardsize[1], ...cardsize);
  //}

  if (draw[0] < slots[0][1].length-1) {
    const repeat = Math.ceil((slots[0][1].length-draw[0]-1)/10);
    for (const pos of [...Array(repeat).keys()]){
      context.drawImage(cards['card1'], gap.x + pos*2*scale, gap.y + pos*scale, ...cardsize);
    }
  }

  if (deck.length) {
    let dep = 0;
    const repeat = Math.ceil((deck.length-1)/10);
    for (const pos of [...Array(repeat).keys()]){
      dep = pos*scale;
      context.drawImage(cards['01'], gap.x+dep*2 + 82*scale, gap.y+dep, ...cardsize);
    }
    if (dragcard || returncard) {
      if (deck.length-1) {
        context.drawImage(cards[deck[deck.length-2]], gap.x+dep*2 + 82*scale, gap.y+dep, ...cardsize);
      }
      for (const i of [...Array(ded).keys()]) {
        const card = deck[deck.length-ded+i];
        if (dragcard && dragcard.slot[1][draw[0]] === card || returncard && returncard.slot[1][draw[0]] === card) {
          break;
        };
        context.drawImage(cards[card], gap.x+dep*2 + 82*scale + 14*i, gap.y+dep+i, ...cardsize);
      };
    } else if (!dragcard || dragcard.slot[1][draw[0]] !== deck[deck.length]) {
      for (const i of [...Array(ded).keys()]) {
        context.drawImage(cards[deck[deck.length-ded+i]], gap.x+dep*2 + 82*scale + 14*i, gap.y+dep+i, ...cardsize);
      }
    }
  }

  if ([...Array(4).keys()].every((pos) => {return slots[pos+1][1].length === ncard/4}) && !winanim) {
    winsol();
  }

  for (const pos of [...Array(4).keys()]){
    let dep = 0;
    const repeat = Math.ceil((slots[pos+1][1].length)/4);
    for (const de of [...Array(repeat).keys()]){
      dep = de*scale;
      if (slots[pos+1][1].length-1){
        context.drawImage(cards['01'], gap.x+dep*2 + 82*(pos+3)*scale, gap.y+dep, ...cardsize);
      }
    }
    for (const card of slots[pos+1][1]){
      if (dragcard && dragcard.slot[1][dragcard.draw] === card || returncard && returncard.slot[1][returncard.draw] === card) {
        break;
      }
      context.drawImage(cards[card], gap.x+dep*2 + 82*(pos+3)*scale, gap.y+dep, ...cardsize);
    }
  }

  for (const pos of [...Array(7+cheatslots).keys()]){
    let des = 0
    for (let i=0;i<slots[pos+5][0].length;i++){
      context.drawImage(cards['card1'], gap.x + 82*pos*scale, (106 + des)*scale, ...cardsize);
      des += 3;
    }
    for (const card of slots[pos+5][1]){
      if (dragcard && dragcard.slot[1][dragcard.draw] === card || returncard && returncard.slot[1][returncard.draw] === card) {
        break;
      }
      context.drawImage(cards[card], gap.x + 82*pos*scale, (106 + des)*scale, ...cardsize);
      des += 15;
    }
  }

  if (solcomputer) {
    clearTimeout(readycomputer);
    readycomputer = setTimeout(computerplaysol, computerspeed);
  }
}

function computerplaysol() {
  const pile = [];
  const stack = [];
  const stackforpile = [];

  for (const pos of [...Array(4).keys()]) {
    if (slots[pos+1][1].length) {
      pile.push(slots[pos+1][1][slots[pos+1][1].length-1]);
    }
  }

  for (const pos of [...Array(7+cheatslots).keys()]){
    if (slots[pos+5][1].length) {
      const depth = slots[pos+5][1].length-1;
      const card = slots[pos+5][1][depth];
      if (!(parseInt(slots[pos+5][1][0][1], 16) === 13 && !slots[pos+5][0].length)) {
        stack.push([slots[pos+5][1][0], slots[pos+5], 0]);
      }
      stackforpile.push([slots[pos+5][1][0], slots[pos+5], 0]);
      if (parseInt(card[1], 16) === 1 || pile.some((slot) => {return card[0] === slot[0] && parseInt(card[1], 16) === parseInt(slot[1], 16)+1})) {
        dragcard = {'x':gap.x*(pos+1) + cardsize[0]*pos, 'y':gap.y*2 + cardsize[1]*1 + 3*scale*slots[pos+5][0].length + depth*15*scale, 'dx':mousepos.x, 'dy':mousepos.y, 'slot':slots[pos+5], 'draw':depth};
        setTimeout(FFup, computerspeed*3);
        return;
      }
    } else if (slots[pos+5][0].length) {
      const card = slots[pos+5][0][slots[pos+5][0].length-1]; 
      slots[pos+5][0] = slots[pos+5][0].slice(0, -1);
      slots[pos+5][1].push(card);
      snapshot();
      sol();
      return;
    }
  };

  if (deck.length) {
    const card = deck[deck.length-1];
    stack.push([deck[deck.length-1], slots[0], false]);
    if(parseInt(card[1], 16) === 1 || pile.some((slot) => {return card[0] === slot[0] && parseInt(card[1], 16) === parseInt(slot[1], 16)+1})) {
      const ded = Math.min(drawn, deck.length)-1;
      const repeat = (Math.ceil((deck.length)/10)-1)*scale;
      dragcard = {'x':gap.x*2 + cardsize[0]*1 + repeat*2 + ded*scale*14, 'y':gap.y*1 + cardsize[1]*0 + repeat + ded*scale, 'dx':mousepos.x, 'dy':mousepos.y, 'slot':slots[0]};
      setTimeout(FFup, computerspeed*3);
      return;
    }
  }

  for (const pos of [...Array(7+cheatslots).keys()]){
    if (slots[pos+5][1].length) {
      const card = slots[pos+5][1][slots[pos+5][1].length-1];
      const depth = slots[pos+5][1].length-1;
      for (const [car, slo, dep] of stack) {
        if (car[0]%2 !== card[0]%2 && parseInt(car[1], 16) === parseInt(card[1], 16)-1) {
          dragcard = {'x':gap.x*(pos+1) + cardsize[0]*pos, 'y':gap.y*2 + cardsize[1]*1 + 3*scale*slo[0].length + dep*15*scale, 'dx':mousepos.x, 'dy':mousepos.y, 'slot':slo};
          if(dep !== false) {
            dragcard['draw'] = dep;
          }
          setTimeout(FFup, computerspeed*3);
          return;
        }
      }
    } else if (!slots[pos+5][0].length && pos < 7) {
      for (const [car, slo, dep] of stack) {
        if (parseInt(car[1], 16) === 13) {
          dragcard = {'x':gap.x*(pos+1) + cardsize[0]*pos, 'y':gap.y*2 + cardsize[1]*1 + 3*scale*slo[0].length + dep*15*scale, 'dx':mousepos.x, 'dy':mousepos.y, 'slot':slo};
          if(dep !== false) {
            dragcard['draw'] = dep;
          }
          setTimeout(FFup, computerspeed*3);
          return;
        }
      }
    }
  }

  if (slots[0][1].length && !(draw[0] >= slots[0][1].length-1 && !draw[2])) {
    setTimeout(()=> {
      drawx();
      sol();
    }, computerspeed);
  } else {
    //read last card on all piles, wants greater
    for (const slot of pile) {
      for (const [car, slo, dep] of stackforpile) {
        for (const [n, card] of slo[1].entries()) {
          if (slot[0] === card[0] && parseInt(slot[1], 16) === parseInt(card[1], 16)-1) {
            const ch = slo[1][n+1];
            for (const pos of [...Array(7+cheatslots).keys()]){
              if (slots[pos+5][1].length) {
                const de = slots[pos+5][1].length-1;
                const ca = slots[pos+5][1][de];
                if (ch[0]%2 !== ca[0]%2 && parseInt(ch[1], 16) === parseInt(ca[1], 16)-1) {
                  console.log("That was a special move!");
                  drawx();
                  dragcard = {'x':gap.x*(pos+1) + cardsize[0]*pos, 'y':gap.y*2 + cardsize[1]*1 + 3*scale*slo[0].length + de*15*scale, 'dx':mousepos.x, 'dy':mousepos.y, 'slot':slo};
                  dragcard['draw'] = n+1;
                  setTimeout(FFup, computerspeed*3);
                  return;
                }
              }
            }
          }
        }
      }
    }

    console.log("Help me? I'm stuck");
    // teach computer to borrow a card from pile if another card that requires a borrowed card is found to be movable
    // teach computer to undo and retry with alternative card movement

    //solcomputer = false;
    //stop computer play for debugging
  }
}



var fastclick = Date.now();
var dragcard = false;
var returncard = false;

var FFdown = (e_) => {
  if (poppy.style.display !== 'none') {
    poppy.style.display = 'none';
    return;
  }

  if (e_) {
    if (!isTouch || e_.touches.length === 1) {
      mousepos.x = isTouch ? e_.touches[0].clientX + window.visualViewport.offsetLeft: e_.x;
      mousepos.y = isTouch ? e_.touches[0].clientY + window.visualViewport.offsetTop: e_.y;
    }
  }

  if (solitaire){
    returncard = false;
    const sel = (x, y, e) => {return mousepos.x > gap.x*(x+1) + cardsize[0]*x && mousepos.x < gap.x*(x+1) + cardsize[0]*(x+1)+e && mousepos.y > gap.y*(y+1) + cardsize[1]*y && mousepos.y < gap.y*(y+1) + cardsize[1]*(y+1)};

    if(sel(0, 0, 0)){
      drawx();
    }

    const ded = Math.min(drawn, deck.length)-1;
    if(sel(1, 0, 14*(drawn-1)*scale) && deck.length){
      const repeat = (Math.ceil((deck.length)/10)-1)*scale;
      dragcard = {'x':gap.x*2 + cardsize[0]*1 + repeat*2 + ded*scale*14, 'y':gap.y*1 + cardsize[1]*0 + repeat + ded*scale, 'dx':mousepos.x, 'dy':mousepos.y, 'slot':slots[0]};
    }

    //undo draw
    if(mousepos.x > gap.x*3 + cardsize[0]*2 + 12*(drawn-1)*scale && mousepos.x < gap.x*3 + cardsize[0]*3 && mousepos.y > gap.y + cardsize[1]*0 && mousepos.y < gap.y*1 + cardsize[1]*1/2){
      if (draw[0] > -1) {
        if (!(drawn-1-(draw[1]+drawn)%drawn) || draw[0] > draw[1] || !draw[2]) {
          draw[0] -= drawn;
          deck.splice(draw[0]+1);
        }
      } else {
        draw[0] = slots[0][1].length - drawn - slots[0][1].slice(draw[1]).length%drawn;
        draw[2] = true;
        for (const d of [...Array(draw[0]+1).keys()]) {
          deck.push(slots[0][1][d]);
        }
      }
    }

    // UNdo card movement
    if(mousepos.x > gap.x*3 + cardsize[0]*2 + 12*(drawn-1)*scale && mousepos.x < gap.x*3 + cardsize[0]*2 + cardsize[0]*1/2 + 12/2*(drawn-1)*scale && mousepos.y > gap.y + cardsize[1]*1/2 && mousepos.y < gap.y*1 + cardsize[1]*1){
      if (rev) {
        rev --;
        [deck, draw, slots] = JSON.parse(JSON.stringify(slothistory[rev]));
      }
      sol();
      return;
    }

    // REdo card movement
    if(mousepos.x > gap.x*3 + cardsize[0]*2 + cardsize[0]*1/2 + 12/2*(drawn-1)*scale && mousepos.x < gap.x*3 + cardsize[0]*3 && mousepos.y > gap.y + cardsize[1]*1/2 && mousepos.y < gap.y*1 + cardsize[1]*1){
      if (rev < slothistory.length-1) {
        rev ++;
        [deck, draw, slots] = JSON.parse(JSON.stringify(slothistory[rev]));
      }
      sol();
      return;
    }

    for (const pos of [...Array(4).keys()]){
      if(sel(pos+3, 0, 0)) {
        if (slots[pos+1][1].length) {
          const repeat = Math.ceil((slots[pos+1][1].length)/4)-1;
          dragcard = {'x':gap.x*(pos+4) + cardsize[0]*(pos+3) + repeat*scale*2, 'y':gap.y*1 + cardsize[1]*0 + repeat*scale, 'dx':mousepos.x, 'dy':mousepos.y, 'slot':slots[pos+1], 'draw':slots[pos+1][1].length-1};
        }
        break;
      }
    }

    for (const pos of [...Array(7+cheatslots).keys()]){
      if(mousepos.x > gap.x*(pos+1) + cardsize[0]*pos && mousepos.x < gap.x*(pos+1) + cardsize[0]*(pos+1) && mousepos.y > gap.y*2 + cardsize[1]*1 && mousepos.y < gap.y*2 + cardsize[1]*2 + 3*scale*slots[pos+5][0].length + 15*scale*slots[pos+5][1].length) {
        if (slots[pos+5][1].length) {
          let depth = Math.min(Math.floor(Math.max(mousepos.y-(gap.y*2 + cardsize[1]*1 + 3*scale*slots[pos+5][0].length), 0)/15/scale), slots[pos+5][1].length-1);
          dragcard = {'x':gap.x*(pos+1) + cardsize[0]*pos, 'y':gap.y*2 + cardsize[1]*1 + 3*scale*slots[pos+5][0].length + depth*15*scale, 'dx':mousepos.x, 'dy':mousepos.y, 'slot':slots[pos+5], 'draw':depth};
        } else if (slots[pos+5][0].length) {
          let card = slots[pos+5][0][slots[pos+5][0].length-1]; 
          slots[pos+5][0] = slots[pos+5][0].slice(0, -1);
          slots[pos+5][1].push(card);
          snapshot();
        }
        break;
      }
    }

    sol();
    imawake();

    if (dragcard) {
      let dragcards = 'draw' in dragcard ? dragcard.slot[1].slice(dragcard.draw) : [dragcard.slot[1][draw[0]]];
      let des = 0;
      for (const card of dragcards){
        context.drawImage(cards[card], dragcard.x, dragcard.y+des, ...cardsize);
        des += 15*scale;
      }
    }
    return;
  }
  //if (document.fullscreenElement) {
  //  document.exitFullscreen();
  //} else {
  //  document.body.requestFullscreen();
  //}
  //setTimeout(() => {
  //  c.width = document.documentElement.clientWidth;
  //  c.height = document.documentElement.clientHeight;
  //  context.imageSmoothingEnabled = false;
  //  dim.x = Math.floor(c.width/2)
  //  dim.y = Math.floor(c.height/2);
  //  if (solitaire){
  //    sol();
  //  }
  //}, 500);
}



function rubberband(){
  returncard = dragcard;
  let returncards = 'draw' in dragcard ? dragcard.slot[1].slice(dragcard.draw) : [dragcard.slot[1][draw[0]]];
  const ribbersize = 4;
  let rubberstep = ribbersize;
  const update = () => {
    if (!returncard || rubberstep === 0) {
      returncard = false;
      if (!dragcard) {
        sol();
      }
      return;
    }
    sol();
    requestAnimationFrame(update);
    let des = 0;
    for (const card of returncards){
      context.drawImage(cards[card], rubberstep/ribbersize*(mousepos.x-returncard.dx) + returncard.x, rubberstep/ribbersize*(mousepos.y-returncard.dy) + returncard.y+des, ...cardsize);
      des += 15*scale;
    }
    rubberstep -= 1;
  }
  update();
};



var FFup = (e_) => {
  if (e_) {
    e_.preventDefault();
  }
  if (solitaire){
    if (dragcard){
      let slot = [];
      let cheat = false;

      for (const pos of [...Array(4).keys()]) {
        if(mousepos.x - dragcard.dx + dragcard.x + cardsize[0] > gap.x*(pos+4) + cardsize[0]*(pos+3) && mousepos.x - dragcard.dx + dragcard.x < gap.x*(pos+4) + cardsize[0]*(pos+4) && mousepos.y - dragcard.dy + dragcard.y + cardsize[1] > gap.y*1 + cardsize[1]*0 && mousepos.y - dragcard.dy + dragcard.y < gap.y*1 + cardsize[1]*1) {
          slot.push(slots[pos+1]);
        }
        if (fastclick + 200 > Date.now()) {
          let stack = slots[pos+1][1][slots[pos+1][1].length-1];
          let dragcards = 'draw' in dragcard ? dragcard.slot[1].slice(dragcard.draw) : [dragcard.slot[1][draw[0]]];
          let card = dragcards[dragcards.length-1];
          if (!stack && parseInt(card[1], 16) === 1 || stack && dragcards.length === 1 && parseInt(card[0], 16) === parseInt(stack[0], 16) && parseInt(card[1], 16) === parseInt(stack[1], 16)+1){
            if ('draw' in dragcard) {
              slots[pos+1][1].push(...dragcard.slot[1].slice(dragcard.draw));
              dragcard.slot[1] = dragcard.slot[1].slice(0, dragcard.draw);
            } else {
              slots[pos+1][1].push(dragcard.slot[1][draw[0]]);
              slots[0][1] = [...dragcard.slot[1].slice(0, draw[0]), ...dragcard.slot[1].slice(draw[0]+1)];
              deck.pop();
              draw[0] -= 1;
              draw[1] = draw[0];
              draw[2] = true;
            }
            dragcard = false;
            returncard = false;
            snapshot();
            sol();
            return;
          }
        }
      }

      if (slot.length) {
        for (const s of slot){
          let stack = s[1][s[1].length-1];
          let dragcards = 'draw' in dragcard ? dragcard.slot[1].slice(dragcard.draw) : [dragcard.slot[1][draw[0]]];
          let card = dragcards[dragcards.length-1];
          if (!stack && parseInt(card[1], 16) === 1 || stack && dragcards.length === 1 && parseInt(card[0], 16) === parseInt(stack[0], 16) && parseInt(card[1], 16) === parseInt(stack[1], 16)+1){
            if ('draw' in dragcard) {
              s[1].push(...dragcard.slot[1].slice(dragcard.draw));
              dragcard.slot[1] = dragcard.slot[1].slice(0, dragcard.draw);
            } else {
              s[1].push(dragcard.slot[1][draw[0]]);
              slots[0][1] = [...dragcard.slot[1].slice(0, draw[0]), ...dragcard.slot[1].slice(draw[0]+1)];
              deck.pop();
              draw[0] -= 1;
              draw[1] = draw[0];
              draw[2] = true;
            }
            dragcard = false;
            returncard = false;
            snapshot();
            sol();
            return;
          }
        }
      }

      for (const pos of [...Array(7+cheatslots).keys()]) {
        if (mousepos.x - dragcard.dx + dragcard.x + cardsize[0] > gap.x*(pos+1) + cardsize[0]*(pos) && mousepos.x - dragcard.dx + dragcard.x < gap.x*(pos+1) + cardsize[0]*(pos+1) && mousepos.y - dragcard.dy + dragcard.y + cardsize[1] > gap.y*2 + cardsize[1]*1 && mousepos.y - dragcard.dy + dragcard.y < gap.y*2 + cardsize[1]*2 + 3*scale*slots[pos+5][0].length + 15*scale*(slots[pos+5][1].length-1)) {
          slot.push(slots[pos+5]);
          if (!cheat){
            cheat = pos > 6 || 'draw' in dragcard && slots[pos+5][0].length === 0 && dragcard.slot[0].length === 0 ? 2 : 1;
          }
        }
      }

      if (slot.length) {
        for (const s of slot){
          if (!s[1].length) {
            if ((parseInt(dragcard.slot[1]['draw' in dragcard ? dragcard.draw : draw[0]][1], 16) === ncard/4 || cheat === 2) && !(dragcard.draw)) {
              if ('draw' in dragcard) {
                s[1].push(...dragcard.slot[1].slice(dragcard.draw));
                dragcard.slot[1] = dragcard.slot[1].slice(0, dragcard.draw);
              } else {
                s[1].push(dragcard.slot[1][draw[0]]);
                slots[0][1] = [...dragcard.slot[1].slice(0, draw[0]), ...dragcard.slot[1].slice(draw[0]+1)];
                deck.pop();
                draw[0] -= 1;
                draw[1] = draw[0];
                draw[2] = true;
              }
              dragcard = false;
              returncard = false;
              snapshot();
              sol();
              fastclick = Date.now();
              return;
            } else {
              rubberband();
            };
          } else if (dragcard.slot[1]['draw' in dragcard ? dragcard.draw : draw[0]][0] % 2 !== s[1][s[1].length-1][0] % 2 && parseInt(dragcard.slot[1]['draw' in dragcard ? dragcard.draw : draw[0]][1], 16) === parseInt(s[1][s[1].length-1][1][0], 16)-1) {
            if ('draw' in dragcard) {
              s[1].push(...dragcard.slot[1].slice(dragcard.draw));
              dragcard.slot[1] = dragcard.slot[1].slice(0, dragcard.draw);
            } else {
              s[1].push(dragcard.slot[1][draw[0]]);
              slots[0][1] = [...dragcard.slot[1].slice(0, draw[0]), ...dragcard.slot[1].slice(draw[0]+1)];
              deck.pop();
              draw[0] -= 1;
              draw[1] = draw[0];
              draw[2] = true;
            }
            dragcard = false;
            returncard = false;
            snapshot();
            sol();
            fastclick = Date.now();
            return;
          } else {
            rubberband();
          };
        }
      } else {
        rubberband();
      }
    }
    dragcard = false;
    sol();
    fastclick = Date.now();
    return;
  }
}

var imawake = () => {
  if (solitaire && !stopscreensaver) {
    stopscreensaver = true;
    sol();
  }
  clearTimeout(idlescreensaver);
  idlescreensaver = setTimeout(() => {
    if (stopscreensaver) {
      stopscreensaver = false;
      new_screensaver();
    }
  }, 60000);
};

var FFmove = (e_) => {
  clearTimeout(idlecursor);
  idlecursor = setTimeout(() => {
    c.style.cursor = "none";
  }, 1500);
  c.style.cursor = "default";
  imawake();

  if (e_) {
    if (!isTouch || e_.touches.length === 1) {
      mousepos.x = isTouch ? e_.touches[0].clientX + window.visualViewport.offsetLeft: e_.x;
      mousepos.y = isTouch ? e_.touches[0].clientY + window.visualViewport.offsetTop: e_.y;
      e_.preventDefault();
    }
  }

  if (solitaire && dragcard){
    sol();
    let dragcards = 'draw' in dragcard ? dragcard.slot[1].slice(dragcard.draw) : [dragcard.slot[1][draw[0]]];
    let des = 0;
    for (const card of dragcards){
      context.drawImage(cards[card], mousepos.x-dragcard.dx+dragcard.x, mousepos.y-dragcard.dy+dragcard.y+des, ...cardsize);
      des += 15*scale;
    }
  }
}



var rightc = (e_) => {
  if (isTouch && e_.touches.length > 1) {
    return;
  }
  poppy.style.display = 'block';
  const x = Math.min(
    isTouch
      ? e_.touches[0].clientX + window.visualViewport.offsetLeft
      : e_.x,
    document.documentElement.clientWidth - poppy.clientWidth,
  );
  const y = Math.min(
    isTouch
      ? e_.touches[0].clientY + window.visualViewport.offsetTop
      : e_.y,
    document.documentElement.clientHeight - poppy.clientHeight,
  );
  poppy.style.left = `${x > 0 ? x : 0}px`;
  poppy.style.top = `${y > 0 ? y : 0}px`;

  e_.preventDefault();
};

function typeOf(obj) {
  const stringified = Object.prototype.toString.call(obj);
  const type = stringified.split(' ')[1].slice(0, -1);
  return type.toLowerCase();
}

function readcard(callback, is_star) {
  let promiseCards = [];
  for (const card of Object.keys(cards)) {
    promiseCards.push(new Promise((resolve, reject) => {
      if (is_star && card.length === 2) {
        newstar(cards[card]);
      }
      setTimeout(() => {
        reject(cards[card]);
      }, 1000);
      cards[card].onload = function() {
        resolve();
      };
    }))
  }
  Promise.all(promiseCards).then(() => {
    callback();
  }).catch((reason) => {
    console.log(reason);
  })
}

window.onload = () => {
  if (isTouch) {
    c.addEventListener('touchstart', (e_) => {
      FFdown(e_);
      if (busyclick) {
        clearTimeout(busyclick);
        busyclick = false;
      } else {
        busyclick = setTimeout(() => {rightc(e_)}, 500);
      }
    });
    c.addEventListener('touchend', (e_) => {
      FFup(e_);
      clearTimeout(busyclick);
      busyclick = false;
    });
    c.addEventListener('touchmove', (e_) => {
      FFmove(e_);
      clearTimeout(busyclick);
      busyclick = false;
      mousepos.x = e_.touches[0].clientX;
      mousepos.y = e_.touches[0].clientY;
    });
    c.addEventListener('contextmenu', (e_) => {
      e_.preventDefault();
    });
  } else {
    c.addEventListener('mousedown', FFdown);
    c.addEventListener('mouseup', FFup);
    c.addEventListener("mousemove", FFmove);
    document.body.addEventListener('contextmenu', (e_) => {
      rightc(e_);
    });
  }

  //let e = document.createElement("DIV");
  //e.innerHTML = '&times;';
  //e.style.cursor = 'pointer';
  //e.style.fontSize = '30px';
  //e.addEventListener('click', () => {
  //  poppy.style.display = 'none';
  //});
  //poppy.appendChild(e);

  const change_screensaver = (o) => {
    colorful = o[2];
    useimg = o[3];
    ismask = o[4];
    pixel = {'x':o[6], 'y':o[7]};
    life = o[8];
    density = o[9];
    if (o.length == 11) {
      ccolor = o[10];
    } else {
      ccolor = '#000';
    }
    lastcolor = ccolor;
    if (o[5]) {
      alpha.src = o[5];
      alpha.onload = () => {
        new_stars();
      }
    } else {
      new_stars();
    }
  }

  const makemenu = (options) => {
    e = document.createElement("DIV");
    e.innerHTML = options[0];
    if (options[1] === 1) {
      e.addEventListener('click', () => {
        displayfps = !displayfps;
        result.style.display = displayfps ? 'block' : 'none';
      });
    } else if (options[1] === 2) {
      e.addEventListener('click', () => {
        if (options[2]) {
          fly = !fly;
        } else {
          glide = !glide;
        }
      });
    } else if (options[1] === 3) {
      e.addEventListener('click', () => {
        if (options.length > 2) {
          throttlebyfps = true;
          fpsInterval = 1000 / options[2];
        } else {
          throttlebyfps = false;
          fpsInterval = 1000 / 120;
        }

        startTime = Date.now();
        frameCount = 0;
      });
    } else if (options[1] === 4) {
      e.addEventListener('click', () => {
        if (options[2] == 0) {
          ccolor = lastcolor;
        } else if (options[2] == 1) {
          ccolor = "rgba(0, 0, 0, 0.1)";
        } else {
          ccolor = "rgba(0, 0, 0, 0)";
        }
      });
    } else if (options[1] === 5) {
      e.addEventListener('click', () => {
        new_deck();
        solitaire = true;
        stopscreensaver = true;
        drawn = options[2];
        readcard(sol);
      });
    } else if (options[1] === 6) {
      e.addEventListener('click', () => {
        solcomputer = !solcomputer;
        if (solitaire) {
          sol();
        }
      });
    } else {
      e.addEventListener('click', () => {
        stopscreensaver = true;
        if (solitaire) {
          solitaire = false;
          new_screensaver();
        }
        change_screensaver(options);
      });
    }
    poppy.appendChild(e);
  };

  makemenu(['Flying Windows',      0, 3,      true,  true,  'win95.png', 95, 95, 1.25, 75]);
  makemenu(['Slow Windows',        0, 3,      true,  true,  'win95.png', 95, 95, 10, 75]);
  makemenu(['Big Windows',         0, 3,      true,  true,  'win95.png', 380, 380, 1.25, 75]);
  makemenu(['2000 flying Windows', 0, 3,      true,  true,  'win95.png', 95, 95, 1.25, 2000]);
  makemenu(['Starfield',           0, false,  false, false, false,       4, 4, 1.25, 200]);
  makemenu(['8000 colorful stars', 0, 3,      false, false, false,       4, 4, 1.25, 8000]);
  makemenu(['8000 slow colorful stars', 0, 3, false, false, false,       4, 4, 10, 8000]);
  makemenu(['Surreal Xmas memory', 0, 1,      true,  true,  'light.png', 190, 190, 1.25, 800, "#072700"]);
  //makemenu(['Flying solitaire',    0, false,  true,  false, false,       71*3, 96*3, 1.25, 1, "#007D00"]);
  makemenu(['Nostalgia FPS',       3, 20]);
  makemenu(['Unrestricted FPS',    3]);
  makemenu(['Display FPS',         1]);
  makemenu(['Solitaire (draw 1)',  5, 1]);
  makemenu(['Solitaire (draw 3)',  5, 3]);
  makemenu(['Solitaire with computer', 6]);
  makemenu(['Clear',               4, 0]);
  makemenu(['Ghost',               4, 1]);
  makemenu(['Paint',               4, 2]);
  makemenu(['Fly',                 2, true]);
  makemenu(['Glide',               2, false]);

  addEventListener("resize", () => {
    c.width = document.documentElement.clientWidth;
    c.height = document.documentElement.clientHeight;
    context.imageSmoothingEnabled = false;
    dim.x = Math.floor(c.width/2)
    dim.y = Math.floor(c.height/2);
    if (solitaire){
      sol();
    }
  });
  addEventListener("visibilitychange", (event) => {
    //startTime = Date.now();
    //frameCount = 0;
  });
  c.style.cursor = 'pointer';
  document.body.append(c);

  dim.x = Math.floor(c.width/2)
  dim.y = Math.floor(c.height/2);
  mousepos.x = dim.x;
  mousepos.y = dim.y;

  alpha.src = 'win95.png';
  alpha.onload = () => {
    new_stars();
  }
}
</script></head>
<body>
<div id="fgbg"></div><div id="result"></div><div id="poppy"></div></body>
</html>
