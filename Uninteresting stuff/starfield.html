<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="white">
<meta name="format-detection" content="telephone=no">
<meta name="viewport" content="width=749, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"/>
<style>
body {
  background-color: #000;
}
</style>
<script>
function opencss(file) {
  const head = document.getElementsByTagName('head')[0];
  const link = document.createElement('link');
  link.rel = 'stylesheet';
  link.type = 'text/css';
  link.href = file + '?' + Date.now();
  head.appendChild(link);
}

function opendb(file) {
  return (resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.overrideMimeType('application/json');
    xhr.open('GET', file, true);
    xhr.setRequestHeader('Cache-Control', 'no-cache, no-store, max-age=0');
    xhr.send();
    xhr.onreadystatechange = () => {
      if (xhr.readyState === 4) {
        if (xhr.status !== 404 && xhr.responseText) {
          resolve(xhr.responseText);
        } else if (xhr.responseText) {
          reject();
        } else {
          local_tooltip.style.display = 'inline-block';
          local_tooltip.textContent = '⚠';
          local_tooltip.dataset.tooltip = "couldn't access " + file + '! (non-404 error)';
        }
      }
    }
  }
}

const fps = {
  throttle: true,
  vfps: 15,
  hz: 120,
  msec: 1000 / 15,
  display: false,
  avg_slots: 10,
  avg: [],
};

const star = {
  speed: 60,
  accelerate: 4,
  life: 1, // per second
  x: 95,
  y: 95,
  r: 95/95,
};

const scr = {
  img: true,
  density: 75,
  frustum: 0.8 + 0.4,
  color: 2,
  fly: false,
  glide: false,
  levitate: 1,
  drift: 1, //0.66
  friction: {x: 2, y: 2},
  paint: false,
}

var task = {
  freecell: false,
  glyph: false,
  qix: false,
  scr: true,
  sol: false,
  stop: function() { // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions
    this.freecell = false;
    this.glyph = false;
    this.qix = false;
    this.scr = false;
    this.sol = false;

    desk.style.display = 'none';
    tailscr.style.display = 'none';

    qixsatescr.style.display = 'none';
    qixmobscr.style.display = 'none';
    qixprojscr.style.display = 'none';
    glyphscr.style.display = 'none';

    hint1.style.display = 'none';
    hint4.style.display = 'none';
    hintb.style.display = 'none';

    winanim = false;

    clearTimeout(idlescr);
    idlescr = false;
    clearInterval(mobspawner);
    mobspawner = false;

    document.body.style.backgroundColor = '#003D00';
  },
};

var scale = 1;
var dim = {x: 0, y: 0};
const max_touches = 5;
const pointers = Array.from({ length: max_touches }).map(() => {
  return {
    down: null,
    identifier: null,
    x: 0,
    y: 0,
  };
});
var rubberpointers = {x: 0, y: 0};

const touch = Object.seal({
  is_touch_device: 'ontouchstart' in window,
  long_press_callback: null,
  x: 0,
  y: 0,
});

var ccolor = '#000';
var lastcolor = '#000';


function echo(B, cls = '<br>', echoer = stdout) {
  if (cls === false) {
    while (echoer.firstChild) {
      echoer.lastChild.remove();
    }
    cls = '';
  }
  echoer.insertAdjacentHTML('beforeend', cls + B);
  echoer.style.display = 'inline-block';
}

function speaker(B) {
  ZOOKd = true;
  dialog.innerHTML = B;
  dialogbox.style.display = 'inline-block';
  anger = 1;
  if (task.freecell) {
    repaint.freecell();
  }
  if (task.qix) {
    repaint.qix();
  }
}

function ABtoURL(ab) {
  return URL.createObjectURL(new Blob(ab, {type: 'application/octet-stream'}));
}

function ABtoIMG(ab) {
  const img = document.createElement('img');
  img.src = ABtoURL(ab);
  return img;
}

function ABtoAB(ab) {
  return [new Uint8Array(ab)];
}

function newCanvas(w, h) {
  const d = document.createElement('CANVAS').getContext('2d');
  if (w) {
    d.width = d.canvas.width = w;
  }
  if (h) {
    d.height = d.canvas.height = h;
  }
  d.imageSmoothingEnabled = false;
  return d;
}

function echoCanvas(c) {
  c.style.maxHeight = '400px';
  echo('');
  stdout.appendChild(c);
}

function canvasToAB(c, ext = 'png') {
  return function(resolve) {
    c.toBlob((blob0) => {
      const fr = new FileReader();
      fr.readAsArrayBuffer(blob0);
      fr.addEventListener('load', () => {
        arri = new Uint8Array(fr.result);
        resolve(arri);
      });
    }, 'image/' + ext);
  }
}

function canvasToFrame(c, callback, interFrameN) {
  let promise = new Promise(canvasToAB(c, 'png'));
  promise.then(function(arri) {
    callback(interFrameN, ABtoIMG(ABtoAB(arri)));
  });
}

const canvas = document.createElement('canvas');
canvas.width = document.documentElement.clientWidth;
canvas.height = document.documentElement.clientHeight;
const context = canvas.getContext('2d');
context.imageSmoothingEnabled = false;

const asRetina = window.devicePixelRatio || 1;
const shader = newCanvas(canvas.width * asRetina, canvas.height * asRetina);
shader.canvas.style.width = canvas.width + 'px';
shader.canvas.style.height = canvas.height + 'px';
shader.imageSmoothingEnabled = false;

//for (const n of Array(shader.width).keys()) {
//  shader.fillStyle = ['rgba(255, 0, 0, 0.5)', 'rgba(0, 255, 0, 0.5)', 'rgba(0, 0, 255, 0.5)'][n%3];
//  shader.fillRect(n, 0, 1, shader.height);
//}
//
//for (const n of Array(shader.height).keys()) {
//  if (n % 3 === 0) {
//    shader.fillStyle = 'rgba(0, 0, 0, 0.5)';
//    shader.fillRect(0, n, shader.width, 1);
//  }
//}

//for (const c of Array(shader.width).keys()) {
//  for (const r of Array(shader.height).keys()) {
//    //shader.fillStyle = ['rgba(255, 0, 0, 0.2)', 'rgba(0, 255, 0, 0.2)', 'rgba(0, 0, 255, 0.2)'][Math.floor(Math.random()*3)];
//    shader.fillStyle = `rgba(0, 0, 0, ${Math.random()/5})`;
//    shader.fillRect(c, r, 1, 1);
//  }
//}

var idlecursor = false;
var idlescr = false;
var busyscr = false;
var busyqix = false;
var sideways = false;
var stars = [];
var frameCount = 0;
var scrTime, startTime;



function newstar(img, color) {
  const horizon = Math.random();
  const scanline = Math.random();
  const speli = star.speed * star.life;
  const age = Math.random() * speli % (0.66 * speli);
  stars.push({
    boost: age,
    x: ((horizon - 0.5) * canvas.width * scr.frustum / speli) * (speli - age),
    y: ((scanline - 0.5) * canvas.height * scr.frustum / speli) * (speli - age),
    canvas: img,
    color: color,
  });
}



function starry(vmsec, msec, vfps) {
  if (vmsec > (1000 / star.delay) + 60/vfps) {
    scrTime = performance.now();
    frameCount = 0;
    if (!star.accelerate) {
      star.delay = (1000 / vmsec).toFixed(2);
    } else if (isFinite(star.delay)) {
      const easein = msec / (star.accelerate * 200);
      const easeout = msec / (vfps * 50) / (star.accelerate * 50 / star.delay);
      const easeinout = Math.min(easein, easeout);
      star.delay = star.delay / (1 + easeinout*(vfps/fps.vfps));
    } else {
      star.delay = 60 * vfps;
    }
  } else {
    star.delay = (1000 / vmsec).toFixed(2);
  }

  const drift = {
    x: (pointers[0].x - dim.x) / (200 / scr.levitate) / (vfps / 60) / star.life - (pointers[0].x - rubberpointers.x) / scr.friction.x * scr.drift,
    y: (pointers[0].y - dim.y) / (200 / scr.levitate) / (vfps / 60) / star.life - (pointers[0].y - rubberpointers.y) / scr.friction.y * scr.drift,
  }

  const off = {
    x: scr.fly ? (pointers[0].x - dim.x) / 5 : 0,
    y: scr.fly ? (pointers[0].y - dim.x) / 5 : 0,
  }

  context.fillStyle = ccolor;
  context.fillRect(0, 0, canvas.width, canvas.height);

  const bound = {
    x: -star.x / 2,
    y: -star.y / 2,
    dx: star.x / 2,
    dy: star.y / 2,
  };

  if (scr.glide) {
    bound.x += Math.min(pointers[0].x - canvas.width, -dim.x);
    bound.y += Math.min(pointers[0].y - canvas.height, -dim.y);
    bound.dx += Math.max(pointers[0].x, dim.x);
    bound.dy += Math.max(pointers[0].y, dim.y);
  } else {
    bound.x += -dim.x;
    bound.y += -dim.y;
    bound.dx += dim.x;
    bound.dy += dim.y;
  }

  let channel = stars.length;
  if (scr.color === 4 && stars.length > 125) {
    channel = stars.length / 125 * 5;
  }

  const sx = (ishtar, speli) => {
    return (ishtar.x + off.x) / (speli - ishtar.boost) * speli + (scr.glide ? ishtar.boost * star.speed / star.life * (-(pointers[0].x - dim.x) / (900 * scr.friction.x)) : 0);
  };

  const sy = (ishtar, speli) => {
    return (ishtar.y + off.y) / (speli - ishtar.boost) * speli + (scr.glide ? ishtar.boost * star.speed / star.life * (-(pointers[0].y - dim.y) / (900 * scr.friction.y)) : 0);
  }

  for (const [n, ishtar] of stars.entries()) {
    if (ishtar.boost === 0) {
      ishtar.boost = Math.floor(Math.random() * 480 / vfps / star.delay);
      //const horizon = Math.floor(n / channel) % 5 / 5 + Math.random() / 5;
      const horizon = Math.random();

      //const scanline = n % channel / channel + Math.random() / channel;
      const scanline = Math.random();

      ishtar.x = (horizon - 0.5) * canvas.width * scr.frustum + (scr.glide ? (pointers[0].x - dim.x) / scr.friction.x : 0);
      ishtar.y = (scanline - 0.5) * canvas.height * scr.frustum + (scr.glide ? (pointers[0].y - dim.y) / scr.friction.y : 0);
    }

    if (scr.glide) {
      ishtar.x -= drift.x;
      ishtar.y -= drift.y;
    }

    const speli = star.speed * star.life;
    const dot = {
      x: Math.ceil(ishtar.boost / (speli / star.x)),
      y: Math.ceil(ishtar.boost / (speli / star.y)),
    };

    if (false) {
      if (ishtar.x < dim.x) {
        ishtar.x -= (dim.x / ishtar.x - 1) * (1 + ishtar.boost / 5);
      } else {
        ishtar.x += (dim.x / (canvas.width - ishtar.x) - 1) * (1 + ishtar.boost / 5);
      }
      
      if (ishtar.y < dim.y) {
        ishtar.y -= (dim.y / ishtar.y - 1) * (1 + ishtar.boost / 5);
      } else {
        ishtar.y += (dim.y / (canvas.height - ishtar.y) - 1)*(1 + ishtar.boost / 5);
      }
    }

    const x = sx(ishtar, speli);
    const y = sy(ishtar, speli);

    if (
      x < bound.x ||
      y < bound.y ||
      x > bound.dx ||
      y > bound.dy ||
      ishtar.boost > speli
    ) {
      ishtar.boost = 0;
    } else {
      ishtar.boost += star.speed / star.delay;

      const dot_pos = [Math.ceil(x + dim.x - dot.x / 2), Math.ceil(y + dim.y - dot.y / 2), dot.x, dot.y];
      if (ishtar.canvas) {
        context.drawImage(ishtar.canvas, ...dot_pos);
      } else {
        context.fillStyle = ishtar.color;
        context.fillRect(...dot_pos);
      }
    }
  }
  rubberpointers.x = pointers[0].x;
  rubberpointers.y = pointers[0].y;
}

const alpha = new Image();
alpha.addEventListener('load', () => {
  new_stars();
});

const silhouette = new Image();
silhouette.addEventListener('load', () => {
  const qg = qixdb.gallery[qixsel];
  qixmask.width = qixmask.canvas.width = silhouette.width/qg.downscale/qixsc;
  qixmask.height = qixmask.canvas.height = silhouette.height/qg.downscale/qixsc;
  qixmask.imageSmoothingEnabled = false;

  spoilermask.width = spoilermask.canvas.width = silhouette.width/qg.downscale;
  spoilermask.height = spoilermask.canvas.height = silhouette.height/qg.downscale;
  spoilermask.imageSmoothingEnabled = false;

  reveal.src = qg.reveal;
});

const reveal = new Image();
reveal.addEventListener('load', () => {
  const qg = qixdb.gallery[qixsel];

  spoiler.width = spoiler.canvas.width = reveal.width/qg.downscale;
  spoiler.height = spoiler.canvas.height = reveal.height/qg.downscale;
  spoiler.imageSmoothingEnabled = false;

  spoiler.drawImage(reveal, 0, 0, spoiler.width, spoiler.height);

  //desk.style.opacity = 0.5;
  desk.style.display = touch.is_touch_device ? 'inline-block' : 'none';

  speaker("Move player with WASD or arrow keys, click and hold while moving to set up barriers.\n\nCapsLock to un/freeze enemies, Shift/Space to accelerate X/Y.\n\nMind control the boss with TFGH keys.");
  new_qix();
});

const win = new Image();
win.src = 'win95.png';
win.addEventListener('load', () => {
  windo(win);
});

var currentFrame = 0;
function movingphoto() {
  context.clearRect(0, 0, canvas.width, canvas.height);
  for (const [n, ishtar] of stars.entries()) {
    //ishtar.canvas.width ishtar.canvas.height
    for (let x = currentFrame; x < canvas.width; x += star.x) {
      context.drawImage(ishtar.canvas, x, n * star.y, star.x, star.y);
    }
    if (n * star.y > canvas.height) {
      break;
    }
  }

  currentFrame += Math.ceil(20 / star.life * star.x / fps.vfps);
  if (currentFrame > 0) {
    currentFrame -= star.x;
  }
}

const fps_history_slots = 10;
function screensaver(resolve) {
  let frameThen = then = performance.now();
  let fps_increase = 0;
  let fps_frames = 0;
  let fpshistory = [];
  const update = () => {
    if (!task.scr) {
      return resolve(true);
    }
    requestAnimationFrame(update);

    const now = performance.now();
    const sinceStart = now - scrTime;
    const msec = now - startTime;
    fpshistory.unshift(msec);

    if (fpshistory.length > fps_history_slots) {
      const fps_last = fpshistory.pop();
      const findhz = Math.floor(1000 * fps_history_slots / (msec - fps_last));
      Hz = Math.round(findhz/60)*60;
      if (Hz >= 60) {
        if (Hz != fps.hz && !fps.throttle) {
          console.log(`New Hz: ${Hz}`)
          fps.vfps = Hz;
          fps.msec = 1000 / Hz;
          scrTime = performance.now();
          star.delay = 60 * fps.vfps;
          frameCount = 0;
        }
        fps.hz = Hz;
      }
      if (fps.display) {
        fps_increase++;
        if (now >= frameThen) {
          frameThen = now + 1000;
          fps_frames = fps_increase;
          fps_increase = 0;
        }
        const sec = (Math.round(msec / 1000 * 100) / 100).toFixed(2).padStart(3, '0');
        result.textContent = `Uninterrupted for ${sec} seconds @ ${String(findhz).padStart(3, '0')} fps ${fps.hz} Hz ${String(fps_frames).padStart(3, '0')} frames`;
      }
    }

    const elapsed = now - then;
    if (!fps.throttle || elapsed > fps.msec) {
      then = now - (elapsed % fps.msec);
      const vmsec = (sinceStart || fps.msec) / ++frameCount;
      if (vmsec > fps.msec * 2 + 2) {
        startTime = performance.now();
        frameCount = 0;
        fpshistory = [];
      }

      if (sideways) {
        movingphoto(vmsec);
      } else if (scr.paint) {
        const hztrail = Math.round(480/fps.vfps);
        for (const nth of Array.from({ length: hztrail }).keys()) {
          starry(1000/480, 1000/(480*(480/fps.vfps)), 480*(480/fps.vfps));
        }
      } else {
        starry(vmsec, fps.msec, fps.vfps);
      }
    }
  };
  scrTime = performance.now();
  startTime = performance.now();
  if (!sideways) {
    star.delay = 60*fps.vfps;
  }
  frameCount = 0;
  result.style.display = fps.display ? 'block' : 'none';
  update();
}

function change_stars(args) {
  scr.paint = false;
  scr.color = args[0];
  scr.density = args[1];
  scr.img = args[3];
  star.x = args[4];
  star.y = args[5];
  star.r = star.x/star.y;
  star.life = args[6];
  star.accelerate = args[7];
  ccolor = args[8] || '#000';
  lastcolor = args[8] || '#000';
  document.body.style.backgroundColor = ccolor;
  sideways = args[9];

  if (args[2]) {
    alpha.src = args[2];
  } else {
    new_stars();
  }
}

function new_screensaver(need_shuffle = false) {
  if (need_shuffle) {
    stars = shuffle(stars, Math.random().toString(36).slice(2));
  }
  desk.style.display = 'none';
  glyphscr.style.display = 'none';
  winanim = false;
  hint1.style.display = 'none';
  hint2.style.display = 'none';
  hint3.style.display = 'none';
  hint4.style.display = 'none';
  hintb.style.display = 'none';

  Promise.all([busyscr]).then(() => {
    task.scr = true;
    busyscr = new Promise((resolve) => {
      screensaver(resolve);
    });
  });
}

const xlight = ['#f00', '#f90', '#390', '#06f', '#90c'];
const xnatur = ['#fdd', '#f90', '#940', '#766', '#000', '#90c'];
const xstrob = ['#c02', '#d82', '#fdd', '#28d'];
const oldstars = [
  '#F0F8F8', '#D0E0D0', '#A8B8A8', '#709080', '#587070', '#406048', '#182818',
  '#F8D868', '#E8A840', '#D04828', '#881008',
  '#B0E8F8', '#78A0F8', '#5848D8', '#2810A8',
];
const wincolor = ['#000000', '#00FF00', '#008080', '#808080', '#A6CAF0', '#C0DCC0', '#800000', '#F60000', '#800080', '#00007F', '#808000', '#FFFBF0', '#C0C0C0', '#710071', '#008000'];

function starcolor(s) {
  let hex = null;
  switch (scr.color) {
    case 4:
      if (false && s) {
        const [r1, r2, r3] = [splitmix32(s), splitmix32(s+1), splitmix32(s+2)];
        hex = [
          Math.floor(r1() * 16).toString(16),
          Math.floor(r2() * 16).toString(16),
          Math.floor(r3() * 16).toString(16),
        ];
      } else {
        hex = [
          Math.floor(Math.random()*16).toString(16),
          Math.floor(Math.random()*16).toString(16),
          Math.floor(Math.random()*16).toString(16),
        ];
        //hex = [
        //  Math.floor(4 + Math.random()*12).toString(16),
        //  Math.floor(4 + Math.random()*12).toString(16),
        //  Math.floor(4 + Math.random()*12).toString(16),
        //];
      }
      return '#' + hex.join('');
    case 2:
      return wincolor[Math.floor(Math.random() * wincolor.length)];
    case 1:
      return oldstars[Math.floor(Math.random() * oldstars.length)];
    default:
      return '#fff';
  }
}

function starmask(color, img, branch) {
  const mask = newCanvas();

  if (img) {
    mask.width = mask.canvas.width = img.width;
    mask.height = mask.canvas.height = img.height;
    mask.drawImage(img, 0, 0);

    //mask.width = mask.canvas.width = img.width*2;
    //mask.height = mask.canvas.height = img.height*2;
    //mask.imageSmoothingEnabled = false;
    //
    //mask.translate(img.width, img.height);
    //
    ////const fol = newCanvas(img.width, img.height);
    //const fol = document.createElement('CANVAS').getContext('webgl', {antialias: false, preserveDrawingBuffer: true});
    //fol.width = fol.canvas.width = img.width;
    //fol.height = fol.canvas.height = img.height;
    ////fol.imageSmoothingEnabled = false;
    //fol.texImage2D(fol.TEXTURE_2D, 0, fol.RGBA, fol.RGBA, fol.UNSIGNED_BYTE, img);
    //echoCanvas(fol.canvas);
    //return;
    //
    //fol.drawImage(img, 0, 0);
    //fol.globalCompositeOperation = 'source-in';
    //mask.rotate(360 / 2 / branch * Math.PI / 180);
    //
    //for (const nth of Array(branch).keys()) {
    //  fol.fillStyle = color[nth % color.length];
    //  fol.fillRect(0, 0, fol.width, fol.height);
    //
    //  mask.drawImage(fol.canvas, -fol.width/2, -fol.height, fol.width, fol.height);
    //  mask.rotate(360 / branch * Math.PI / 180);
    //}
    //mask.setTransform(1, 0, 0, 1, 0, 0);
  } else {
    mask.width = mask.canvas.width = alpha.width;
    mask.height = mask.canvas.height = alpha.height;
    mask.drawImage(alpha, 0, 0);

    mask.globalCompositeOperation = 'source-in';
    mask.fillStyle = color;
    mask.fillRect(0, 0, mask.width, mask.height);
  }

  return mask.canvas;
}

function new_stars(color) {
  stars = [];
  if (['xmas', 'natu', 'xott'].includes(scr.color)) {
    let remainder = remainder2 = scr.density;
    const variant = (ntimes, img) => {
      Array.from({ length: parseInt(ntimes) }, () => newstar(img));
      remainder -= ntimes;
      if (!remainder) {
        new_screensaver(true);
      }
    }

    const xarray = (() => {
      switch (scr.color) {
        case 'xmas':
          return xlight;
        case 'natu':
          return xnatur;
        case 'xott':
          return xstrob;
      }
    })();

    const foliage = (src, ntimes) => {
      remainder2 -= ntimes;
      const f = new Image();
      f.src = src;
      f.addEventListener('load', () => {
        canvasToFrame(starmask(null, f, 15), variant, ntimes);
        //canvasToFrame(starmask(['#033201', '#0E600C', '#033201', '#233A0D', '#065001', '#0E600C'], f, 15), variant, ntimes);
      });
    }

    if (scr.color === 'xott') {
      foliage('otter.png', xarray.length);
      foliage('otter2.png', xarray.length);
    } else {
      const multi = scr.density / xarray.length * (xarray.length - 1);
      foliage('spruce.png', multi);
      //foliage('foliage.png', multi;
    }

    remainder2 /= xarray.length;
    for (const color of xarray) {
      canvasToFrame(starmask(color), variant, remainder2);
    }
  } else if (scr.color === 'card') {
    const variant = (interFrameN, img) => {
      if (img) {
        newstar(img);
      }

      if (interFrameN === scr.density) {
        new_screensaver();
        return;
      }

      loadcards(variant, interFrameN + 1);
    }
    variant(0);
  } else if (scr.img) {
    if (scr.color === 4 && scr.density > 125) {
      let remainder = scr.density;
      const variant = (ntimes, img) => {
        Array.from({ length: parseInt(ntimes) }, () => newstar(img));
        remainder -= ntimes;
        if (!remainder) {
          new_screensaver(true);
        }
      }

      const ntimes = Math.ceil(scr.density / 125);
      for (const r of Array.from({ length: 5 }).keys()) {
        const rr = (r * 3 + 1).toString(16);
        for (const g of Array.from({ length: 5 }).keys()) {
          const gg = (g * 3 + 1).toString(16);
          for (const b of Array.from({ length: 5 }).keys()) {
            const color = '#' + rr + gg + (b * 3 + 1).toString(16);
            canvasToFrame(starmask(color), variant, ntimes);
          }
        }
      }
    } else {
      seednow = seedboxnow.value !== '0' && seedboxnow.value !== '' ? seedboxnow.value.replace(/\W/g, '') : Math.random().toString(36).slice(2);
      seedboxnow.value = seednow;
      const s = parseInt(seednow, 36) / Math.pow(36, seednow.length).toString(10).slice(2);
      const variant = (interFrameN, img) => {
        if (img) {
          newstar(img);
        }
      
        if (interFrameN === scr.density) {
          new_screensaver();
          return;
        }

        const color = starcolor(s + interFrameN);
        canvasToFrame(starmask(color), variant, interFrameN + 1);
      }
      variant(0);
    }
  } else {
    for (const n of Array.from({ length: scr.density }).keys()) {
      newstar(null, starcolor(n));
    }
    new_screensaver();
  }
}



var hand = [];
var cards = {};
var slots = [];
var tableau_slots = 7;
var cheat_slots = 2;
var allow_cheat = false;
var cards_on_tableau = Array.from({ length: tableau_slots + 1 }).keys().reduce((a, n) => a + n);
var deck, drawn;
var draw = {};
var rev = -1;
var win_ratio = [1, 0, 0];
var other_vectors = [];
var tried_vector = 0;
var slothistory = [];
var sol_computer = false;
var readycomputer = false;
var computerspeed = 30;
var winanim = false;
var resize_flag = false;
var won = false;
var busysol = false;
var cardsize = [71 * scale, 96 * scale];
const gap = {
  x: 11 * scale,
  y: 5 * scale,
  dn: 3 * scale,
  up: 15 * scale,
};
var solsize = [
  ((gap.x + 1) * scale + cardsize[0]) * (tableau_slots + cheat_slots),
  400 * scale,
];
let face = 2;
let anger = 0;

const paint_card = (card, dri = 0, dep = 0, x = 1, y = 1) => {
  context.drawImage(cards[card], gap.x * x + dri, gap.y * y + dep, ...cardsize);
}

var snapshot = () => {
  dragcard = false;
  returncard = false;
  rev ++;
  if (rev < slothistory.length){
    slothistory.splice(rev);
  }
  slothistory.push(JSON.parse(JSON.stringify([hand, draw, slots])));
}

var drawx = () => {
  if (draw.draw < slots[0][1].length-1) {
    const dd = Math.min(drawn, slots[0][1].length - hand.length);
    draw.draw += dd;
    for (const n of Array.from({ length: dd }).keys()) {
      hand.push(slots[0][1][draw.draw - dd + 1 + n]);
    }
  } else {
    draw.draw = -1;
    draw.cycle = false;
    hand = [];
  }
}

var cardsym = ['Clover', 'Diamond', 'Spade', 'Heart'];
var cardname = [0, 'A', 2, 3, 4, 5, 6, 7, 8, 9, 10, 'J', 'Q', 'K'];//, 'L', 'Z'];
function newloc(l=0, r=26) {
  const sym = [
    [9],
    [1,16],
    [1,9,16],
    [0,2,15,17],
    [0,2,9,15,17],
    [0,2,8,10,15,17],
    [0,2,4,8,10,15,17],
    [0,2,5,7,11,13,15,17],
    [0,2,5,7,9,11,13,15,17],
    [0,2,3,5,7,11,13,14,15,17],
  ];
  const symloc = [
    [l,0],  [13,0],  [r,0],
            [13,10],
            [13,16],
    [l,21], [13,21], [r,21],
    [l,31], [13,31], [r,31],
    [l,40], [13,40], [r,40],
            [13,50],
    [l,61], [13,61], [r,61],
  ];
  const arri = [];
  for (const index of sym) {
    const loc = [];
    for (const i of index) {
      loc.push(symloc[i]);
    }
    arri.push(loc);
  }
  return arri;
}

var cloverloc = newloc();
var diamondloc = newloc(-1, 27);
var spadeloc = newloc();
var heartloc = newloc();

// Fine-tuning symbol locations
cloverloc[6][2][1] += 1;
cloverloc[8][4][1] -= 2;
cloverloc[9][2][1] += 1;

diamondloc[8][2][1] -= 1;
diamondloc[8][3][1] -= 1;
diamondloc[8][5][1] += 1;
diamondloc[8][6][1] += 1;
diamondloc[7][2] = [13,16];
diamondloc[7][3] = [-1,31];
diamondloc[7][4] = [27,31];
diamondloc[7][5] = [13,45];
diamondloc[9][2][1] += 1;
diamondloc[9][3][1] -= 1;
diamondloc[9][4][1] -= 1;
diamondloc[9][5][1] += 1;
diamondloc[9][6][1] += 1;

spadeloc[5][2][1] -= 2;
spadeloc[5][3][1] -= 2;
spadeloc[6][2][1] += 1;
spadeloc[8][2][1] -= 1;
spadeloc[8][3][1] -= 1;
spadeloc[8][4][1] -= 2;
spadeloc[8][5][1] += 2;
spadeloc[8][6][1] += 2;
spadeloc[9][7][1] += 1;

heartloc[6][2][1] -= 1;
heartloc[8][4][1] += 2;
heartloc[9][7][1] += 1;

function new_card(next, suit) {
  let flip = false;

  const acard = newCanvas(71, 96);
  const sym = newCanvas();

  if (next === 0 && suit === 2) {
    acard.drawImage(cards['card0'], 0, 0, acard.width, acard.height);
    // Spade A
    sym.width = sym.canvas.width = 39;
    sym.height = sym.canvas.height = 39;
    sym.clearRect(0, 0, sym.width, sym.height);
    sym.drawImage(cards['sym'], -147, 0, cards['sym'].width, 60);
    acard.drawImage(sym.canvas, 17, 25, 39, 39);
  } else if (next >= 10) {
    // Monarch
    acard.drawImage(cards['cardm'], 0, 0, acard.width, acard.height);

    const rotatecopy = cards['mon'].height % 72 ? true : false; // 72px portraits odd of odd/even, otherwise there will be rotate copy monarches
    sym.width = sym.canvas.width = Math.floor(45);
    sym.height = sym.canvas.height = Math.floor(rotatecopy ? 36 : 72);
    sym.clearRect(0, 0, sym.width, sym.height);

    let monsym;
    if (next === 12) {
      monsym = suit === 1 ? 0 : 1; // diamond
    } else {
      monsym = suit === 1 ? 30 : 29;
    }

    sym.drawImage(cards['mon'], -sym.width * suit, -sym.height * (next - 10), cards['mon'].width, cards['mon'].height);
    sym.drawImage(cards['sym'], 37, 15*suit, 15, 15, monsym, 1, 15, 15);
    acard.drawImage(sym.canvas, 13, 12, sym.width, sym.height);
    if (rotatecopy) {
      sym.clearRect(0, 0, sym.width, sym.height);
      sym.translate(sym.width, sym.height);
      sym.scale(-1, -1);
      sym.drawImage(cards['mon'], -sym.width * suit, -sym.height * (next - 10), cards['mon'].width, cards['mon'].height);
      sym.drawImage(cards['sym'], 37, 15*suit, 15, 15, monsym, 1, 15, 15);
      acard.drawImage(sym.canvas, 13, 12+sym.height, sym.width, sym.height);
    }
  } else {
    acard.drawImage(cards['card0'], 0, 0, acard.width, acard.height);
    sym.width = sym.canvas.width = 15;
    sym.height = sym.canvas.height = 15;
    sym.clearRect(0, 0, sym.width, sym.height);
    sym.drawImage(cards['sym'], -22, -15*suit, ...symdim);
    for (const symloc of [cloverloc, diamondloc, spadeloc, heartloc][suit][next]) {
      if (symloc[1] > 33 && !flip) {
        sym.clearRect(0, 0, sym.width, sym.height);
        sym.translate(sym.width, sym.height);
        sym.scale(-1, -1);
        sym.drawImage(cards['sym'], -22, -15*suit, ...symdim);
        flip = true;
      }
      acard.drawImage(sym.canvas, symloc[0]+15, symloc[1]+10, 15, 15);
    }
  }
  sym.setTransform(1,0,0,1,0,0);
  flip = false;

  const x = 52 + 12*(next%8);
  const y = 15*Math.floor(next/8) + 30*(suit%2);

  sym.width = sym.canvas.width = 12;
  sym.height = sym.canvas.height = 14;
  sym.clearRect(0, 0, sym.width, sym.height);
  sym.drawImage(cards['sym'], -x, -y, ...symdim);
  acard.drawImage(sym.canvas, 2, 4, 12, 14);
  sym.clearRect(0, 0, sym.width, sym.height);
  sym.translate(sym.width, sym.height);
  sym.scale(-1, -1);
  sym.drawImage(cards['sym'], -x, -y, ...symdim);
  acard.drawImage(sym.canvas, 57, 78, 12, 14);
  sym.setTransform(1,0,0,1,0,0);

  sym.width = sym.canvas.width = 11;
  sym.height = sym.canvas.height = 11;
  sym.clearRect(0, 0, sym.width, sym.height);
  sym.drawImage(cards['sym'], -11*(next >= 10 ? 1 : 0), -15*suit, ...symdim);
  const ms = {'x':3, 'y':18};
  if (suit === 1) {
    // Diamond
    ms.x = 2;
    ms.y = 17;
  } else if (next >= 10 && suit === 0) {
    // Spade mon
    ms.x = 1;
    ms.y = 17;
  } else if (next === 11 && suit === 3) {
    // Heart Queen
    ms.x = 2;
    ms.y = 18;
  } else if (next >= 10) {
    ms.x = 2;
    ms.y = 17;
  }
  acard.drawImage(sym.canvas, ms.x, ms.y, 11, 11);
  sym.clearRect(0, 0, sym.width, sym.height);
  sym.translate(sym.width, sym.height);
  sym.scale(-1, -1);
  sym.drawImage(cards['sym'], -11*(next >= 10 ? 1: 0), -15*suit, ...symdim);
  sym.setTransform(1,0,0,1,0,0);
  acard.drawImage(sym.canvas, 60-ms.x, 85-ms.y, 11, 11);

  return acard.canvas;
}

function shuffle(breakseal, seednow) {
  const shuffled = [];
  const s = parseInt(seednow, 36) / Math.pow(36, seednow.length).toString(10).slice(2);
  const rand = splitmix32(s);
  while (breakseal.length) {
    const pick = Math.floor(rand() * breakseal.length);
    shuffled.push(breakseal[pick]);
    breakseal.splice(pick, 1);
  }
  return shuffled;
}

function splitmix32(a) {
  return function() {
    a |= 0; a = a + 0x9e3779b9 | 0;
    var t = a ^ a >>> 16; t = Math.imul(t, 0x21f0aaad);
        t = t ^ t >>> 15; t = Math.imul(t, 0x735a2d97);
    return ((t = t ^ t >>> 15) >>> 0) / 4294967296;
  }
}

//function crapndom() {
//  return crypto.getRandomValues(new Uint32Array(1))[0].toString(36);
//}
var seed = '';
var seednow = 0;
function new_deck(restart = false) {
  draw = {
    draw: -1,
    last: -1,
    cycle: true,
  };

  rev = -1;
  won = false;
  winanim = false;
  allow_cheat = false;

  clearTimeout(busysol);
  busysol = false;

  give_hint = false;

  if (restart) {
    seednow = restart;
  } else {
    seednow = seed !== '' ? seed.replace(/\W/g, '') : Math.random().toString(36).slice(2);
  }
  seedboxnow.value = seednow;
  deck = shuffle([...factorysealed], seednow);

  hand = [];
  if (task.sol) {
    // Solitaire
    gap.x = 11 * scale;
    gap.y = 5 * scale;
    gap.up = 15 * scale;
    drawhint.sol();

    slots = Array.from({ length: tableau_slots + cheat_slots + 6 }, () => [[], []]);
    let used = 0;
    for (const pos of Array.from({ length: tableau_slots }).keys()) {
      used += pos-1;
      slots[pos+5][1].push(deck[pos + deck.length - tableau_slots]);
      for (const p of Array.from({ length: pos }).keys()) {
        slots[pos+5][0].push(deck[used + deck.length - cards_on_tableau + 1 + p]);
      }
    }
    slots[0][1] = deck.slice(0, deck.length - cards_on_tableau);
  } else {
    // Freecell, incomplete
    gap.x = 7 * scale;
    gap.y = 5 * scale;
    gap.up = 18 * scale;
    drawhint.freecell();

    slots = Array.from({ length: 16 }, () => [[], []]);
    let used = 0;
    for (const pos of Array.from({ length: 8 }).keys()) {
      for (const p of Array.from({ length: pos < 4 ? 7 : 6 }).keys()) {
        slots[pos+8][1].push(deck[used + p]);
      }
      used += pos < 4 ? 7 : 6;
    }
  }

  // history management
  slothistory = [];
  win_ratio = [1, 0, 0];
  other_vectors = [];
  tried_vector = 0;
  snapshot();
}

var factorysealed = [];
var symdim = [0, 0];
function loadcards(callback, interFrameN) {
  const is_star = !isNaN(interFrameN);
  if (factorysealed.length) {
    if (is_star) {
      for (const card of factorysealed) {
        newstar(cards[card]);
      };
    } else if (!task.qix) {
      new_deck();
    }
    callback(interFrameN);
    return;
  };

  for (const card of ['card0', 'card1', 'card2', 'cardm', 'hand', 'undo', 'undo3', 'free', 'freemon', 'slot', 'computer', 'mon', 'sym']) {
    cards[card] = new Image();
    cards[card].src = `SOL/${card}.png`;
  }

  let promiseCards = [];

  for (const card of Object.keys(cards)) {
    promiseCards.push(new Promise((resolve, reject) => {
      setTimeout(() => {
        reject(cards[card]);
      }, 1000);

      cards[card].addEventListener('load', () => {
        resolve();
      });
    }))
  }

  Promise.all(promiseCards).then(() => {
    symdim = [cards['sym'].width, cards['sym'].height];

    // optional hue
    for (const [pos, card] of Object.keys(cards).entries()) {
      break;
      const hue = newCanvas(...cardsize);
      hue.filter = 'brightness(0.6) contrast(3) saturate(2.5) hue-rotate(130deg)';
      if (['hand', 'undo', 'undo3', 'slot', 'computer'].includes(card)) {
        hue.clearRect(0, 0 , hue.width, hue.height);
        hue.drawImage(cards[card], 0, 0, hue.width, hue.height);
        cards[card] = hue.canvas;
      }
    }

    for (const [n, cs] of cardname.entries()) {
      if (n) {
        for (const [s, suit] of cardsym.entries()) {
          card = `${s}${n.toString(16)}`;
          //cards[card] = new Image();
          //cards[card].src = `SOL/${cs}${suit[0]}.png`;
          cards[card] = new_card(n-1, s);
          factorysealed.push(card);
        }
      }
    }

    if (is_star) {
      for (const card of factorysealed) {
        newstar(cards[card]);
      };
    } else if (!task.qix) {
      new_deck();
    }

    callback(interFrameN);
  }).catch((reason) => {
    console.log(reason);
  })
}

function winsol() {
  sol_computer = false;
  winanim = true;
  const launch = [];
  const flycards = [];
  const flewcards = [];
  const gravity = {x: 0, y: 1};
  const kinecticloss = 0.85;
  let i = 0;
  const ranks = deck.length / 4;

  for (const card of Array.from({ length: ranks }).keys()) {
    for (const pos of Array.from({ length: 4 }).keys()) {
      const falldir = Math.floor(Math.random()*14-7)+1;
      const dep = Math.ceil((ranks-1-card)/4)*scale;
      launch.push({
        card: slots[pos+1][1][ranks-1-card],
        x: gap.x*4 + gap.x*pos + cardsize[0]*(pos+3) + dep*2,
        y: gap.y + dep,
        xdir: scale,
        ydir: scale,
        xvel: falldir ? falldir : -2,
        yvel: -Math.ceil(Math.random()*18)
      });
    }
  }

  hint1.style.display = 'none';
  hintb.style.display = 'none';

  const update = () => {
    if (!winanim) {
      return;
    }

    const ground = solsize[1];
    //const ground = document.documentElement.clientHeight;
    for (const nth of Array.from({ length: Math.round(240 / fps.hz) }).keys()) {
      if (!flycards.length) {
        idlescr = setTimeout(() => {
          if (resize_flag) {
            resize_flag = false;
            resize();
          }
          new_screensaver();
        }, 4000);
        return;
      }
      for (const flycard of flycards) {
        flycard.xvel += gravity.x;
        flycard.yvel += gravity.y;
        flycard.x += (flycard.xvel * flycard.xdir);
        flycard.y += (flycard.yvel * flycard.ydir);
        if (flycard.y + cardsize[1] > ground) {
          flycard.y = ground - cardsize[1];
          flycard.yvel = -flycard.yvel*kinecticloss;
        }
        context.drawImage(cards[flycard['card']], flycard.x, flycard.y, ...cardsize);

        // card flew away
        if (flycard.x < -cardsize[0] || flycard.x > solsize[0] || flycard.x > canvas.width) {
          //flycard.xvel = -flycard.xvel;
          if (i < deck.length - 1 && !flewcards.includes(flycard)) {
            clearTimeout(idlescr);
            flewcards.push(flycard);
            i++;
            flycards.push(launch[i]);
          }

          // card is out of bound
          if (flycard.x < -cardsize[0] || flycard.x > canvas.width) {
            flycards.splice(flycards.indexOf(flycard), 1);
          }
        }
      }
    }
    requestAnimationFrame(update);
  }
  flycards.push(launch[i]);
  busysol = setTimeout(update, 1000);
}

var invert = newCanvas(cardsize[0], Math.floor(cardsize[1]/2));
invert.imageSmoothingEnabled = false;

function drawcross(x, y) {
  context.strokeStyle = '#00FF00';
  context.lineWidth = 2;
  context.beginPath();
  context.arc(x, y, 8, 0, Math.PI*2);
  context.moveTo(x - 6, y - 6);
  context.lineTo(x + 6, y + 6);
  context.stroke();
}

const repaint = {
  sol: () => {
    context.fillStyle = '#003D00'; // "#130733"
    context.fillRect(0, 0, canvas.width, canvas.height);

    context.fillStyle = '#007D00'; // "#260f66"
    context.fillRect(0, 0, ...solsize);

    // Card design preview
    //for (const [n, card] of Object.keys(cards).entries()) {
    //  context.drawImage(cards[card], 5*((n%9)+1) + cardsize[0]*(n%9), 220 + (cardsize[1] + gap.y)*Math.floor(n/9), ...cardsize);
    //}

    paint_card('hand');
    paint_card(drawn > 1 ? 'undo3' : 'undo', cardsize[0] * 2, 0, 3);
    paint_card('computer', cardsize[0] * 8, 0, 9);
    //context.drawImage(cards['deal'], gap.x*9 + cardsize[0]*8, gap.y, ...cardsize);

    if (sol_computer) {
      //context.strokeStyle = "#00FF00";
      //context.lineWidth = 3;
      //context.beginPath();
      //const coord = cardsize[0]*8+gap.x*2;
      //context.arc(coord, gap.y*2 + (computerspeed ? 0 : 3+cardsize[1]/2), 2, 0, Math.PI*2);
      //context.stroke();

      context.drawImage(invert.canvas, gap.x*9 + cardsize[0]*8, gap.y + (computerspeed ? 0 : cardsize[1]/2), invert.width, invert.height);
    }

    if (drawn-1-(draw.last+drawn)%drawn && draw.draw < draw.last+drawn && draw.cycle) {
      drawcross(cardsize[0]*3+gap.x*(drawn*0.6-0.8), gap.y*2);
    }

    const offset = cardsize[0] + gap.x;
    const offsety = cardsize[1] + gap.y * 2;

    // Foundation slots
    for (const pos of Array.from({ length: 4 }).keys()) {
      paint_card('slot', offset * (pos + 3));
    }

    // Cheat slots
    for (const pos of Array.from({ length: cheat_slots }).keys()) {
      paint_card('free', offset * (pos + tableau_slots), cardsize[1], 1, 2);
    }

    // Hand
    if (draw.draw < slots[0][1].length-1) {
      const repeat = Math.ceil((slots[0][1].length-draw.draw-1)/10);
      for (const pos of Array.from({ length: repeat }).keys()) {
        paint_card('card1', pos * 2 * scale, pos * scale);
      }
    }

    // Waste
    if (hand.length) {
      let dep = 0;
      const repeat = Math.ceil((hand.length-1)/10);
      for (const pos of Array.from({ length: repeat }).keys()) {
        dep = pos*scale;
        paint_card('card0', dep * 2 + offset, dep);
      }
      const ded = Math.min(drawn, hand.length);
      if (dragcard || returncard) {
        if (hand.length-1) {
          paint_card(hand[hand.length - 2], dep * 2 + offset, dep);
        }
        for (const i of Array.from({ length: ded }).keys()) {
          const card = hand[hand.length-ded+i];
          if (dragcard && dragcard.slot[1][draw.draw] === card || returncard && returncard.slot[1][draw.draw] === card) {
            break;
          };
          paint_card(card, dep * 2 + offset + 14 * i, dep + i);
        };
      } else if (!dragcard || dragcard.slot[1][draw.draw] !== hand[hand.length]) {
        for (const i of Array.from({ length: ded }).keys()) {
          paint_card(hand[hand.length - ded + i], dep * 2 + offset + 14 * i, dep + i);
        }
      }
    }

    // Foundation
    for (const pos of Array.from({ length: 4 }).keys()) {
      let dep = 0;
      const slot = slots[pos+1];
      const repeat = Math.ceil((slot[1].length) / 4);
      for (const de of Array.from({ length: repeat }).keys()) {
        dep = de*scale;
        if (slot[1].length-1 > 0) {
          paint_card('card0', dep * 2 + offset * (pos + 3), dep);
        }
      }
      for (const card of slot[1]) {
        if (dragcard && dragcard.slot[1][dragcard.draw] === card || returncard && returncard.slot[1][returncard.draw] === card) {
          break;
        }
        paint_card(card, dep * 2 + offset * (pos + 3), dep);
      }
    }

    // Stack
    for (const pos of Array.from({ length: tableau_slots + cheat_slots }).keys()) {
      let des = 0;
      const slot = slots[pos+5];
      for (const card of slot[0]) {
        paint_card('card1', offset * pos, offsety + des * scale, 1, 0);
        des += 3;
      }
      for (const card of slot[1]) {
        if (dragcard && dragcard.slot[1][dragcard.draw] === card || returncard && returncard.slot[1][returncard.draw] === card) {
          break;
        }
        paint_card(card, offset * pos, offsety + des * scale, 1, 0);
        des += 15;
      }
    }

    if (givehint) {
      const slot = slots[0];

      // Draw preview
      let y = 400 + gap.y;
      context.fillStyle = 'rgba(0, 0, 0, 0.75)';

      // Cycle
      for (const [n, card] of slot[1].entries()) {
        paint_card(card, 5 * ( n + 1) + cardsize[0] * n, y, 0, 0);
        if (n === slot[1].length-1 ? 0 : drawn-1-(n > draw.last-1 ? n-(draw.last-drawn+1)%drawn : n)%drawn) {
          context.fillRect(5*(n+1) + cardsize[0]*n, y, ...cardsize);
        }
      }

      // Block undo
      if (drawn-1-(draw.last+drawn)%drawn) {
        const coord = Math.floor(draw.last/drawn)*drawn;
        drawcross(Math.max(0, 5*coord + cardsize[0]*coord - cardsize[0]/2), y+8)
      }

      // Dead end
      y += cardsize[1] + gap.y;
      for (const [n, card] of slot[1].entries()) {
        paint_card(card, 5 * (n + 1) + cardsize[0] * n, y, 0, 0);
        if (n === slot[1].length-1 > 0 ? 0 : drawn-1-n%drawn) {
          context.fillRect(5* (n + 1) + cardsize[0] * n, y, ...cardsize);
        }
      }
      if (draw.cycle) {
        y -= cardsize[1] + gap.y;
      }
      const x = 5*(draw.draw+1) + cardsize[0]*draw.draw;

      // Current draw
      drawhint.sol(hint4, x, y, x, y);
    }
  },

  freecell: () => {
    context.fillStyle = '#003D00'; // "#130733"
    context.fillRect(0, 0, canvas.width, canvas.height);

    context.fillStyle = '#007D00'; // "#260f66"
    context.fillRect(0, 0, ...solsize);

    // Free cells
    for (const pos of Array.from({ length: 4 }).keys()) {
      const slot = slots[pos];
      let card = slot[1][0];
      if (dragcard && dragcard.slot[1][dragcard.draw] === card || returncard && returncard.slot[1][returncard.draw] === card) {
        card = 'free';
      }
      context.drawImage(cards[slot[1].length > 0 ? card : 'free'], cardsize[0]*pos*scale, 0, ...cardsize);
    }

    // Monarch
    context.drawImage(cards['freemon'], 0, 0, 38, 38, cardsize[0]*4*scale + 12, 18, 38, 38);
    context.drawImage(cards['freemon'], 38*face, 38*anger, 38, 38, cardsize[0]*4*scale + 12, 18, 38, 38);
    context.drawImage(cards['freemon'], 0, 38, 38, 38, cardsize[0]*4*scale + 12, 64, 38, 38);

    // Home cells
    for (const pos of Array.from({ length: 4 }).keys()) {
      const slot = slots[pos+4];
      context.drawImage(cards[slot[1].length > 0 ? slot[1].at(-1) : 'free'], cardsize[0]*(pos+5)*scale - 10, 0, ...cardsize);
    }

    context.drawImage(cards['computer'], 11*9*scale + cardsize[0]*8*scale, gap.y, ...cardsize);
    if (sol_computer) {
      context.drawImage(invert.canvas, 11*9 + cardsize[0]*8, gap.y + (computerspeed ? 0 : cardsize[1]/2), invert.width, invert.height);
    }

    // Stack
    for (const pos of Array.from({ length: 8 }).keys()){
      let des = 0;
      for (const card of slots[pos+8][1]) {
        if (dragcard && dragcard.slot[1][dragcard.draw] === card || returncard && returncard.slot[1][returncard.draw] === card) {
          break;
        }
        context.drawImage(cards[card], gap.x*(pos+1)*scale + cardsize[0]*pos*scale, (106 + des)*scale, ...cardsize);
        des += 18;
      }
    }

    if ([...Array.from({ length: 4 }).keys()].every((pos) => {
      return slots[pos+4][1].length === deck.length / 4;
    })) {
      context.drawImage(cards['freemon'], 38*3, 38*anger, 38, 38, 0, cardsize[1], 38*8, 38*8);
    } else {
      imawake();
    }
  },

  qix: () => {
    context.fillStyle = qixdb.color;
    context.fillRect(0, 0, canvas.width, canvas.height);

    const worldmap = {
      x: dim.x - qixscr.x * qixsc*qixzoom,
      y: dim.y - qixscr.y * qixsc*qixzoom,
      width: spoiler.width*qixzoom,
      height: spoiler.height*qixzoom,
    }
    context.drawImage(spoiler.canvas, worldmap.x, worldmap.y, worldmap.width, worldmap.height);

    if (!winanim) {
      context.drawImage(spoilermask.canvas, worldmap.x, worldmap.y, worldmap.width, worldmap.height);
      context.drawImage(cards['freemon'], 38*face, 38*anger, 38, 38, dim.x-19*qixzoom + (qixpos.x-qixscr.x)*qixsc, dim.y-19*qixzoom + (qixpos.y-qixscr.y)*qixsc, 38*qixzoom, 38*qixzoom);
    }
  },
}

// Dead by 2 10 red cards lj33xp9ini
const game = {
  sol: () => {
    if ([...Array.from({ length: 4 }).keys()].every((n) => slots[n+1][1].length === deck.length / 4)) {
      if (!winanim) {
        clearTimeout(busysol);
        winsol();
      }
    } else {
      winanim = false;
      imawake();
    }

    repaint.sol();

    let isseq = true;
    if (drawn > 1 && slots[0][1].length) {
      const subsuite = {};
      for (const slot of slots[0][1]) {
        if (!subsuite[slot[0]] || subsuite[slot[0]] > slot[1]) {
          subsuite[slot[0]] = slot[1];
        } else {
          isseq = false;
          break;
        }
      }
    }
    const facedowns = slots.some((slot) => {return slot[0].length});
    if (isseq && !facedowns) {
      if (!computerspeed) {
        console.log("Winning vector found, the seed is", seednow);
        //new_deck(seednow);
        //game.sol();
        win_ratio[1] += 1;
        if (other_vectors.length > tried_vector) {
          sol_computer = true;
          rev = other_vectors[tried_vector][0];
          [hand, draw, slots] = JSON.parse(JSON.stringify(other_vectors[tried_vector][1]));
          tried_vector += 1;
        } else {
          console.log('vectors', win_ratio[0], 'win', win_ratio[1], 'losses', win_ratio[2]);
          computerspeed = 30;
        }
        computer.sol();
        return;
      } else if (!won) {
        console.log('won');
        won = true;
        const old = winsoln;
        winsoln += drawn > 1 ? drawn + 1 : 1;
        savestar('winsol=', winsoln);
        makemenu();

        const award = (n, B) => {
          if (old < n && winsoln >= n) {
            speaker(B);
            sol_computer = false;
          };
        };
        award(1, `So there's no more face-down cards, at this point the next card movement is unlosable and you also have earned the winning point.
You can restart the game because you've won.

New game: Solitaire (draw 3)

Changed: Solitaire (draw 1) requires 4 winning points to play again`);
        award(2, `No more face-down cards or draw is in sequential order (per suite) mean you've won for Solitaire with draw ${drawn} cards.
You can restart the game now that you have earned the winning point.

New screensaver: Starfield

New game: Qix

New test suite: Glyph\n\nChanged: Solitaire (draw 1) returned`);
        award(16, `New game: FreeCell

New test suite: Moving photo

New option: Frame rate`);
        award(24, "New screensaver: More stars");
        award(32, "New mode: Fly");
        award(64, `New mode: Glide

New option: Star speed`);
        award(88, `New screensaver: Star Fox

New mode: Hyperspace`);
        award(100, "New screensaver: Flying cards");
      }
    }

    if (sol_computer && computerspeed) {
      clearTimeout(readycomputer);
      readycomputer = setTimeout(computer.sol, computerspeed);
    } else {
      computer.sol();
    }
  },

  freecell: () => {
    repaint.freecell();

    if (sol_computer && computerspeed) {
      clearTimeout(readycomputer);
      readycomputer = setTimeout(computer.freecell, computerspeed);
    } else {
      computer.freecell();
    }
  },
}

function drawhint_line(h, x, y, dx, dy) {
  if (Math.abs(x-dx) * 2 < Math.abs(y-dy)){
    h.style.clipPath = `polygon(
${x}px ${y}px,
${x + 1}px ${y}px,
${dx + 1}px ${dy}px,
${dx}px ${dy}px)`;
  } else {
    h.style.clipPath = `polygon(
${x}px ${y}px,
${x}px ${y + 2}px,
${dx}px ${dy + 2}px,
${dx}px ${dy}px)`;
  }
}

function drawhint_outline(h, x, y, dx, dy) {
  h.style.clipPath = `polygon(
${x}px ${y}px,
${dx}px ${y}px,
${dx}px ${dy}px,
${x}px ${dy}px,
${x}px ${y}px,

${x + 2}px ${y}px,
${x + 2}px ${dy - 2}px,
${dx - 2}px ${dy - 2}px,
${dx - 2}px ${y + 2}px,
${x}px ${y + 2}px
)`;
}

const drawhint = {
  sol: (h, x, y, dx, dy) => {
    if (!h) {
      x = gap.x * 9 + cardsize[0] * 8 + Math.floor(cardsize[0] / 2) - 16 * scale;
      y = gap.y * 1 + cardsize[1] * 0 + Math.floor(cardsize[1] / 2) - 8 * scale;
      dx = x + 32 * scale;
      dy = y + 16 * scale;
      drawhint_outline(hintb, x, y, dx, dy);
    
      hintb.style.display = 'block';
      hint1.style.display = 'none';
      hint2.style.display = 'none';
      hint3.style.display = 'none';
      hint4.style.display = 'none';
      givehint = false;
      if (!winsoln) {
        speaker("In case you need a hint, move cursor/fingertip across the magenta/lime striping ring to enable hint, cross again to disable hints.");
      }
      return;
    }
    h.style.display = givehint && x ? 'block' : 'none';
    if (x === dx && y === dy) {
      drawhint_outline(h, x, y, dx + cardsize[0], dy + cardsize[1]);
    } else {
      drawhint_line(h, x + Math.floor(cardsize[0]/2), y, dx + Math.floor(cardsize[0]/2), dy);
    }
  },

  freecell: (h, x, y, dx, dy) => {
    if (!h) {
      x = 11 * 9 + cardsize[0] * 8 + Math.floor(cardsize[0] / 2) - 16 * scale;
      y = gap.y * 1 + cardsize[1] * 0 + Math.floor(cardsize[1] / 2) - 8 * scale;
      dx = x + 32 * scale;
      dy = y + 16 * scale;
      drawhint_outline(hintb, x, y, dx, dy);
    
      hintb.style.display = 'block';
      hint1.style.display = 'none';
      hint2.style.display = 'none';
      hint3.style.display = 'none';
      hint4.style.display = 'none';
      givehint = false;
      if (!winsoln) {
        speaker("In case you need a hint, move cursor/fingertip across the magenta/lime striping ring to enable hint, cross again to disable hints.");
      }
      return;
    }
    speaker('Unimplemented');
  },
}

const isAce = (ca) => parseInt(ca[1], 16) === 1;
const isKing = (ca) => parseInt(ca[1], 16) === deck.length / 4;
const isRanked = (ca, dest) => parseInt(ca[0], 16) === parseInt(dest[1].at(-1)[0], 16) && parseInt(ca[1], 16) === parseInt(dest[1].at(-1)[1], 16) + 1;
const isRankedAlt = (ca, dest) => ca[0] % 2 !== dest[1].at(-1)[0] % 2 && parseInt(ca[1], 16) === parseInt(dest[1].at(-1)[1], 16) - 1;

const vector = (x, y, slot, depth, dest) => {
  dragcard = {
    slot: slot,
  };
  if (depth !== false) {
    dragcard.draw = depth;
  }
  if (computerspeed) {
    dragcard.x = x;
    dragcard.y = y;
    dragcard.dx = pointers[0].x;
    dragcard.dy = pointers[0].y;
    setTimeout(FFup, computerspeed * 3);
  } else {
    draginto(dest);
  }
}

const vectorA = (x, y, slot, depth) => {
  const p = task.sol ? 1 : 4;
  for (const fpos of Array.from({ length: 4 }).keys()) {
    const fslo = slots[fpos+p];
    if (!fslo[1].length) {
      vector(x, y, slot, depth, fslo);
      if (!computerspeed) {
        game.sol();
      }
      break;
    }
  }
}

let moved = false;
const computer = {
  sol: (forhint) => {
    imawake();
    drawhint.sol(hint2);
    drawhint.sol(hint3);
    if (!givehint) {
      drawhint.sol(hint4);
    }

    const foundations = [];
    const stack = [[], []];
    const stackforpile = [];
    const facedowns = [];

    // Register cards from Foundation piles
    for (const pos of Array.from({ length: 4 }).keys()) {
      if (slots[pos+1][1].length) {
        foundations.push(pos+1);
      }
    }

    // Register cards from Stack piles
    for (const pos of Array.from({ length: tableau_slots + cheat_slots }).keys()){
      const slot = slots[pos+5];
      if (!slot[1].length && slot[0].length) {
        facedowns.push(pos);
      } else if (slot[1].length) {
        //if (!(parseInt(slots[pos+5][1][0][1], 16) === 13 && !slot[0].length)) {
          stack[slot[0].length ? 1 : 0].push([slot[1][0], slot, pos+5, false]);
        //}
        stackforpile.push([slot, pos]);
      } else if (pos < tableau_slots) {
        stackforpile.push([slot, pos]);
      }
    };

    // Flip
    for (const pos of facedowns) {
      const slot = slots[pos+5];
      const x = gap.x * (pos + 1) + cardsize[0] * pos;
      const y = gap.y * 2 + cardsize[1] + gap.dn * (slot[0].length - 1);
      drawhint.sol(hint1, x, y, x, y);
      if (sol_computer) {
        const card = slot[0].at(-1); 
        slot[0] = slot[0].slice(0, -1);
        slot[1].push(card);
        snapshot();
        game.sol();
      }
      return;
    };

    // Stack to Foundation
    for (const [sta, slo, pos, ishand] of [...stack[0], ...stack[1]]) {
      const des = pos > 4 ? 1 : 0;
      const slot = slots[pos];
      const depth = slot[1].length-1;
      const card = slot[1][depth];
      if (!moved) {
        const x = gap.x * (pos - (5 * des) + 1) + cardsize[0] * (pos - (5 * des));
        const y = gap.y * 2 + cardsize[1] + gap.up * depth + gap.dn * slot[0].length;
        if (isAce(card)) {
          drawhint.sol(hint1, x, y, x, y);
          if (sol_computer) {
            vectorA(x, y, slot, !ishand ? depth : false);
          }
          return;
        } else {
          for (const fpos of foundations) {
            const fslo = slots[fpos];
            if (isRanked(card, fslo)) {
              drawhint.sol(hint1, x, y, x, y);
              if (sol_computer) {
                vector(x, y, slot, !ishand ? depth : false, fslo);
                if (!computerspeed) {
                  game.sol();
                }
              }
              return;
            }
          }
        }
      }
    }

    // Register Hand pile
    if (hand.length) {
      stack[1].push([hand.at(-1), slots[0], 1, true]);

      // Hand to Foundation
      const card = hand.at(-1);
      if (!moved) {
        const depth = Math.min(drawn, hand.length)-1;
        const repeat = Math.floor(Math.abs(hand.length-2)/10)*scale;
        const x = gap.x*2 + cardsize[0]*1 + repeat*2 + depth*scale*14;
        const y = gap.y*1 + cardsize[1]*0 + repeat + depth*scale;
        if (isAce(card)) {
          drawhint.sol(hint1, x, y, x, y);
          if (sol_computer) {
            vectorA(x, y, slots[0], false);
          }
          return;
        } else {
          for (const fpos of foundations) {
            const fslo = slots[fpos];
            if (isRanked(card, fslo)) {
              drawhint.sol(hint1, x, y, x, y);
              if (sol_computer) {
                vector(x, y, slots[0], false, fslo);
                if (!computerspeed) {
                  game.sol();
                }
              }
              return;
            }
          }
        }
      }
    }

    // Stack
    for (const pos of Array.from({ length: tableau_slots + cheat_slots }).keys()) {
      const slot = slots[pos+5];
      const vectors = [];
      if (slot[1].length) {
        // Standard card movement
        for (const s of [...stack[1], ...stack[0]]) {
          if (isRankedAlt(s[0], slot)) {
            vectors.push(s);
          }
        }
      } else if (pos < 7 && !slot[0].length) {
        // Move King card to an empty slot
        for (const s of stack[1]) {
          if (isKing(s[0])) {
            vectors.push(s);
          }
        }
      }

      if (vectors.length) {
        if (vectors.length > 1) {
          console.log("Alternative card movement available! Piles with face-down cards have priority but not necessarily top priority since empty slot could be reserved for King card with face-down cards.");
          win_ratio[0] += vectors.length - 1;
        }
        let o = 0;
        for (const [card, slo, place, ishand] of vectors) {
          let depth = slot[1].length;
          depth -= (depth ? 1 : 0);
          const x = gap.x * (pos + 1) + cardsize[0] * pos;
          const y = gap.y * 2 + cardsize[1] * 1 + gap.dn * slot[0].length + gap.up * depth;
          const des = place > 4 ? 1 : 0;
          drawhint.sol([hint1, hint2, hint3, hint4][o], x, y, gap.x * (place - (5 * des) + 1) + cardsize[0] * (place - (5 * des)), gap.y * (des + 1) + cardsize[1] * des + gap.dn * slo[0].length);
          if (sol_computer) {
            vector(x, y, slo, !ishand ? 0 : false, slot);
            if (vectors.length > o + 1) {
              other_vectors.push([rev, JSON.parse(JSON.stringify([hand, draw, slots]))]);
              rev --;
            } else {
              if (!computerspeed) {
                game.sol();
              }
              return;
            }
          }
          o++
        }
        if (o) {
          hints = o;
          return;
        }
      }
    }
    hints = 1;

    if (slots[0][1].length && !(draw.draw >= slots[0][1].length-1 && !draw.cycle)) {
      // Hand to Waste
      const repeat = draw.draw < slots[0][1].length-1 ? Math.ceil((slots[0][1].length-draw.draw-1)/10)-1 : 0;
      const x = gap.x + repeat*2;
      const y = gap.y + repeat;
      //hint1.style.display = "none";
      //hintb.style.display = "block";
      drawhint.sol(hint1, x, y, x, y);
      if (sol_computer) {
        drawx();
        if (computerspeed) {
          setTimeout(game.sol, computerspeed);
        } else {
          game.sol();
        }
      }
    } else {
      // Stack to Foundation: Pile movement
      for (const fpos of foundations) {
        const fslo = slots[fpos];
        for (const [slo, place] of stackforpile) {
          if (!slo[1].length) {
            continue;
          }
          for (const [n, card] of slo[1].entries()) {
            if (isRanked(card, fslo)) {
              const ch = slo[1][n+1];
              if (!ch) {
                continue;
              }
              for (const pos of Array.from({ length: tableau_slots + cheat_slots }).keys()) {
                const slot = slots[pos+5];
                if (slot[1].length) {
                  if (isRankedAlt(ch, slot)) {
                    const x = gap.x * (pos + 1) + cardsize[0] * pos;
                    const y = gap.y * 2 + cardsize[1]*1 + gap.up * (slot[1].length - 1) + gap.dn * slot[0].length;
                    const dx = gap.x * (place + 1) + cardsize[0] * place;
                    const dy = gap.y * 1 + cardsize[1] * 1 + gap.up * (n + 1) + gap.dn * (slo[0].length + 2);
                    drawhint.sol(hint1, x, y, dx, dy);
                    if (sol_computer) {
                      drawx();
                      vector(x, y, slo, n+1, slot);
                      console.log('That was a special move!');
                      if (!computerspeed) {
                        game.sol();
                      }
                    }
                    return;
                  }
                }
              }
            }
          }
        }
      }

      // Foundation to Stack: if another card requires a borrowed card to move
      for (const pos of Array.from({ length: tableau_slots }).keys()) {
        if (slots[pos+5][0].length && slots[pos+5][1].length){
          const card = slots[pos+5][1][0];
          let unsure = false;
          for (const fpos of foundations) {
            const fslo = slots[fpos];
            const fca = fslo[1].at(-1);
            if (card[0] % 2 !== fca[0] % 2 && parseInt(card[1], 16) < parseInt(fca[1], 16)) {
              if (parseInt(card[1], 16) < parseInt(fca[1], 16)-1) {
                console.log('Takes more than 1 card to do it! Trying...');
              }
              for (const [slo, place] of stackforpile) {
                if (
                  slo[1].length === 0 && isKing(fca) ||
                  slo[1].length > 0 && isRankedAlt(fca, slo)
                ) {
                  const des = fpos > 4 ? 1 : 0;
                  const repeat = Math.floor(Math.abs(fslo[1].length-2)/4)*scale;
                  const x = gap.x * (place + 1) + cardsize[0] * place;
                  const y = gap.y * 2 + cardsize[1] * 1 + gap.up * (slo[1].length - (slo[1].length ? 1 : 0)) + gap.dn * slo[0].length;
                  drawhint.sol(hint1, x, y, gap.x*(fpos+3) + cardsize[0]*(fpos+2) + repeat*2, gap.y*(des+1) + cardsize[1]*(des*1) + repeat);
                  moved = true;
                  if (sol_computer) {
                    drawx();
                    vector(x, y, fslo, fslo[1].length-1, slo);
                    console.log("moved", fca, "to", slo[1].at(-1));
                    if (!computerspeed) {
                      game.sol();
                    }
                  }
                  return;
                }
              }
              unsure = true;
            }
          }
          if (unsure) {
            console.log("About to run into a dead end and I'm not sure, maybe wanna move card", cardsym[parseInt(card[0], 16)], cardname[parseInt(card[1], 16)], "somehow? I see a larger number from pile that might be able to help with that.");
            if (computerspeed) {
              sol_computer = false;
              if (sol_computer) {
                game.sol();
              }
            }// else {
            //  new_deck();
            //  game.sol();
            //}
            return;
          }
        }
      }

      if (moved) {
        draw.cycle = true;
        moved = false;
        if (sol_computer) {
          game.sol();
          return;
        }
      }

      if (!won) {
        const repeat = draw.draw < slots[0][1].length - 1 ? Math.ceil((slots[0][1].length - draw.draw - 1) / 10) - 1 : 0;
        const x = gap.x + repeat * 2;
        const y = gap.y + repeat;
        drawhint.sol(hint3, x, y, x, y);
        win_ratio[2] += 1;

        if (!computerspeed && other_vectors.length > tried_vector) {
          console.log('Trying another vector, vectors/tries', other_vectors.length, tried_vector);
          rev = other_vectors[tried_vector][0];
          [hand, draw, slots] = JSON.parse(JSON.stringify(other_vectors[tried_vector][1]));
          tried_vector += 1;
          game.sol();
        } else if (sol_computer) {
          console.warn('Turned off sol_computer, vectors/tries', other_vectors.length, tried_vector);
          sol_computer = false;
          if (!computerspeed) {
            console.log('vectors', win_ratio[0], 'win', win_ratio[1], 'losses', win_ratio[2]);
          }
          game.sol();
        } else {
          console.log('Ran into a dead end');
        }
      }
      //sol_computer = false;
      //stop computer play for debugging
    }
  },

  freecell: () => {
    imawake();
    drawhint.sol(hint2);
    drawhint.sol(hint3);
    //speaker("Computer started");

    const freecells = [];
    const homecells = [];
    const stack = [];

    // Register cards from Free Cell piles
    for (const pos of Array.from({ length: 4 }).keys()) {
      if (slots[pos][1].length) {
        freecells.push(pos);
      }
    }

    // Register cards from Home Cell piles
    for (const pos of Array.from({ length: 4 }).keys()) {
      if (slots[pos+4][1].length) {
        homecells.push(pos+4);
      }
    }

    // Register cards from Stack piles
    for (const pos of Array.from({ length: 8 }).keys()){
      if (slots[pos+8][1].length) {
        stack.push(pos+8);
      }
    };

    // Stack to Home Cells
    for (const pos of [...freecells, ...stack]) {
      const des = pos > 4 ? 1 : 0;
      const slot = slots[pos];
      const depth = slot[1].length-1;
      const card = slot[1][depth];
      const x = gap.x * (pos - (8 * des) + 1) * des + cardsize[0] * (pos - (8 * des));
      const y = gap.y * 2 * des + cardsize[1] * des + gap.up * depth;
      if (isAce(card)) {
        drawhint.sol(hint1, x, y, x, y);
        if (sol_computer) {
          vectorA(x, y, slot, depth);
        }
        return;
      } else {
        for (const fpos of homecells) {
          const fslo = slots[fpos];
          if (isRanked(card, fslo)) {
            drawhint.sol(hint1, x, y, x, y);
            if (sol_computer) {
              vector(x, y, slot, depth, fslo);
              if (!computerspeed) {
                computer.sol();
              }
            }
            return;
          }
        }
      }
    }
  }
}



var fastclick = performance.now();
var dragcard = false;
var returncard = false;

var pickcard = () => {
  returncard = false;
  const area = (x, y, dx = 0, dy = 0, gapx = gap.x, gapy = gap.y) => {
    return (
      pointers[0].x >= cardsize[0] * x + gapx * (x + 1) &&
      pointers[0].x < cardsize[0] * (x + 1) + gapx * (x + 1) + dx &&
      pointers[0].y >= cardsize[1] * y + gapy * (y + 1) &&
      pointers[0].y < cardsize[1] * (y + 1) + gapy * (y + 1) + dy
    )
  };

  const undo3gap = task.sol ? 13 * (drawn - 1) : -10;
  const undoloc = task.sol ? gap.x * 3 + cardsize[0] * 2 : cardsize[0] * 4;
  const undoarea = task.sol ? area(2, 0) : area(4, 0, -10, 0, 0, 11);
  // Menu
  if (undoarea && pointers[0].x >= undoloc + undo3gap) {
    if (task.sol && pointers[0].y < cardsize[1] / 2 + gap.y) {
      // Undo draw
      const slot = slots[0];
      if (draw.draw > -1) {
        if (!(drawn-1-(draw.last+drawn)%drawn) || draw.draw > draw.last || !draw.cycle) {
          if (slot[1].length-1 <= draw.draw) {
            const microdraw = draw.cycle ? (draw.draw-(draw.last-drawn)%drawn)%drawn : slot[1].length%drawn;
            if (microdraw) {
              // Partial backwards
              draw.draw -= microdraw;
              hand.splice(draw.draw+1);
            } else {
              // Standard backwards
              draw.draw -= drawn;
              hand.splice(draw.draw+1);
            }
          } else {
            // Standard backwards
            draw.draw -= drawn;
            hand.splice(draw.draw+1);
          }
        }
      } else {
        // Unflip hand
        draw.draw = slot[1].length-1;
        draw.cycle = true;
        for (const d of Array.from({ length: draw.draw + 1 }).keys()) {
          hand.push(slot[1][d]);
        }
      }
    } else if (pointers[0].x <= undoloc + (cardsize[0] + undo3gap) / 2) {
      // Undo card movement
      winanim = false;
      if (rev) {
        rev --;
        [hand, draw, slots] = JSON.parse(JSON.stringify(slothistory[rev]));
      }
      if (task.sol) {
        game.sol();
      } else {
        game.freecell();
      }
      return;
    } else {
      // Redo card movement
      if (rev < slothistory.length-1) {
        rev ++;
        [hand, draw, slots] = JSON.parse(JSON.stringify(slothistory[rev]));
      }
      if (task.sol) {
        game.sol();
      } else {
        game.freecell();
      }
      return;
    }
  }

  // Solitaire with computer
  if (!winanim && area(8, 0, 0, 0, 11)) {
    let pos = 0;

    if (pointers[0].y < gap.y + cardsize[1] / 2) {
      sol_computer = !computerspeed ? true : !sol_computer;
      computerspeed = 30;
    } else {
      sol_computer = computerspeed ? true : !sol_computer;
      computerspeed = 0;
      pos = -cardsize[1]/2;
    }

    if (invert.filter) {
      invert.filter = 'invert(1)';
      invert.globalCompositeOperation = 'source-over';
      invert.clearRect(0, 0, invert.width, invert.height);
      invert.drawImage(cards['computer'], 0, pos, ...cardsize);
    } else {
      invert.globalCompositeOperation = 'source-over';
      invert.clearRect(0, 0, invert.width, invert.height);
      invert.drawImage(cards['computer'], 0, pos, ...cardsize);
      invert.globalCompositeOperation = 'difference';
      invert.fillStyle = 'white';
      invert.fillRect(0, 0, invert.width, invert.height);

      const ice = newCanvas(invert.width, invert.height);
      ice.drawImage(cards['computer'], 0, pos, ...cardsize);
      ice.globalCompositeOperation = 'source-in';
      ice.fillStyle = 'black';
      ice.fillRect(0, 0, invert.width, invert.height);
      invert.globalCompositeOperation = 'destination-in';
      invert.drawImage(ice.canvas, 0, 0, invert.width, invert.height);
    }

    console.warn(sol_computer ? 'sol_computer started' : 'sol_computer stopped');
    if (task.sol) {
      computer.sol();
    } else {
      computer.freecell();
    }

    return;
  }

  if (task.sol) {
    // Hand to Waste
    if (area(0, 0)) {
      drawx();
    }

    // Drag card from Waste
    const dep = Math.min(drawn, hand.length) - 1;
    if (area(1, 0, 14 * (drawn - 1) * scale) && hand.length) {
      const repeat = Math.floor(Math.abs(hand.length-2)/10)*scale;
      dragcard = {
        x: gap.x*2 + cardsize[0]*1 + repeat*2 + dep*scale*14,
        y: gap.y*1 + cardsize[1]*0 + repeat + dep*scale,
        dx: pointers[0].x,
        dy: pointers[0].y,
        slot: slots[0],
      };
    }

    // Drag card from Foundation
    for (const pos of Array.from({ length: 4 }).keys()) {
      const slot = slots[pos+1];
      if (area(pos+3, 0)) {
        if (slot[1].length) {
          const repeat = Math.ceil((slot[1].length) / 4) - 1;
          dragcard = {
            x: gap.x * (pos + 4) + cardsize[0] * (pos + 3) + repeat * scale * 2,
            y: gap.y * 1 + repeat * scale,
            dx: pointers[0].x,
            dy: pointers[0].y,
            slot: slot,
            draw: slot[1].length-1,
          };
          winanim = false;
        }
        break;
      }
    }

    // Drag card from Stack
    for (const pos of Array.from({ length: tableau_slots + cheat_slots }).keys()) {
      const slot = slots[pos+5];
      const dy = gap.dn * slot[0].length + gap.up * slot[1].length + (slot[1].length > 0 ? -gap.up : 0);
      if (area(pos, 1, 0, dy)) {
        if (slots[pos+5][1].length) {
          const depth = Math.min(Math.floor(Math.max(pointers[0].y - (gap.y * 2 + cardsize[1] * 1 + gap.dn * slot[0].length), 0) / 15 / scale), slot[1].length-1);
          dragcard = {
            x: gap.x * (pos + 1) + cardsize[0] * pos,
            y: gap.y * 2 + cardsize[1] * 1 + gap.dn * slot[0].length + gap.up * depth,
            dx: pointers[0].x,
            dy: pointers[0].y,
            slot: slot,
            draw: depth,
          };
        } else if (slot[0].length) {
          // Flip card
          const card = slot[0].at(-1); 
          slot[0] = slot[0].slice(0, -1);
          slot[1].push(card);
          snapshot();
        }
        break;
      }
    }
  } else {
    // Drag card from Free Cell
    for (const pos of Array.from({ length: 4 }).keys()) {
      const slot = slots[pos];
      if (area(pos, 0, 0, 0, 0)) {
        if (slot[1].length) {
          const repeat = Math.ceil((slot[1].length) / 4) - 1;
          dragcard = {
            x: cardsize[0] * pos + repeat * scale * 2,
            y: repeat * scale,
            dx: pointers[0].x,
            dy: pointers[0].y,
            slot: slot,
            draw: slot[1].length-1,
          };
          winanim = false;
        }
        break;
      }
    }

    // Drag card from Stack
    for (const pos of Array.from({ length: 8 }).keys()) {
      const slot = slots[pos+8];
      const dy = gap.dn * slot[0].length + gap.up * slot[1].length + (slot[1].length > 0 ? -gap.up : 0);
      if (area(pos, 1, 0, dy)) {
        if (slot[1].length) {
          const depth = Math.min(Math.floor(Math.max(pointers[0].y - (gap.y * 2 + cardsize[1] * 1 + gap.dn * slot[0].length), 0) / 18 / scale), slot[1].length-1);
          const stack = slot[1].slice(depth);
          let pickable = true;
          if (stack.length-1 > 0) {
            let card = stack[0];
            for (const scard of stack.slice(1)) {
              if (isRankedAlt(scard, [0, [card]])) {
                card = scard;
              } else {
                speaker("Stop!");
                pickable = false;
              }
            }
          }
          if (pickable) {
            dragcard = {
              x: gap.x * (pos + 1) + cardsize[0] * pos,
              y: gap.y * 2 + cardsize[1] * 1 + gap.dn * slot[0].length + depth * gap.up,
              dx: pointers[0].x,
              dy: pointers[0].y,
              slot: slot,
              draw: depth,
            };
          }
        }
        break;
      }
    }
    for (const pos of Array.from({ length: 4 }).keys()) {
      const slot = slots[pos+4];
      if (area(pos+5, 0, 0, 0, 0) && slot[1].length) {
        speaker("Stop!");
        break;
      }
    }
  }

  if (dragcard) {
    let dragcards = 'draw' in dragcard ? dragcard.slot[1].slice(dragcard.draw) : [dragcard.slot[1][draw.draw]];
    let des = 0;
    for (const card of dragcards){
      context.drawImage(cards[card], dragcard.x, dragcard.y + des, ...cardsize);
      des += gap.up;
    }
  }
}

function rubberband() {
  returncard = dragcard;
  const returncards = 'draw' in dragcard ? dragcard.slot[1].slice(dragcard.draw) : [dragcard.slot[1][draw.draw]];
  const rubbersize = 4 * Math.ceil(fps.hz / 60);
  let rubberstep = rubbersize;
  const update = () => {
    if (!returncard || rubberstep === 0) {
      returncard = false;
      if (!dragcard) {
        if (task.sol) {
          game.sol();
        } else {
          game.freecell();
        }
      }
      return;
    }

    if (task.sol) {
      game.sol();
    } else {
      game.freecell();
    }

    requestAnimationFrame(update);
    let des = 0;
    for (const card of returncards) {
      const x = rubberstep / rubbersize * (pointers[0].x - returncard.dx) + returncard.x;
      const y = rubberstep / rubbersize * (pointers[0].y - returncard.dy) + returncard.y + des;
      context.drawImage(cards[card], x, y, ...cardsize);
      des += gap.up;
    }
    rubberstep -= 1;
  }
  update();
};

const handpop = () => {
  slots[0][1] = [...dragcard.slot[1].slice(0, draw.draw), ...dragcard.slot[1].slice(draw.draw+1)];
  hand.pop();
  draw.draw -= 1;
  draw.last = draw.draw;
  draw.cycle = true;
}

const draginto = (slot) => {
  if ('draw' in dragcard) {
    slot[1].push(...dragcard.slot[1].slice(dragcard.draw));
    dragcard.slot[1] = dragcard.slot[1].slice(0, dragcard.draw);
  } else {
    slot[1].push(dragcard.slot[1][draw.draw]);
    handpop();
  }
  snapshot();
}

const releasecard = () => {
  const area = (x, y, dx = 0, dy = 0, gapx = gap.x, gapy = gap.y) => {
    return (
      pointers[0].x - dragcard.dx + dragcard.x + cardsize[0] > cardsize[0] * x + gapx * (x + 1) &&
      pointers[0].x - dragcard.dx + dragcard.x < cardsize[0] * (x + 1) + dx + gapx * (x + 1) &&
      pointers[0].y - dragcard.dy + dragcard.y + cardsize[1] > cardsize[1] * y + gapy * y &&
      pointers[0].y - dragcard.dy + dragcard.y < cardsize[1] * (y + 1) + dy + gapy * (y + 1)
    )
  };

  const rubbery = () => {
    dragcard = false;
    moved = false;
    if (task.sol && !winanim) {
      game.sol();
    } else if (task.freecell) {
      game.freecell();
    }
    fastclick = performance.now();
  }

  if (task.sol && dragcard){
    let intersected_slots = [];
    let cheat = false;

    // Deal
    //if (area(8, 0)) {
    //  dragcard = false;
    //  returncard = false;
    //  new_deck();
    //  game.sol();
    //  return;
    //}

    // Collect intersected slots of Foundation or an action for double click
    for (const pos of Array.from({ length: 4 }).keys()) {
      const slot = slots[pos+1];
      if (fastclick + 200 > performance.now()) {
        const dragcards = 'draw' in dragcard ? dragcard.slot[1].slice(dragcard.draw) : [dragcard.slot[1][draw.draw]];
        const card = dragcards.at(-1);
        if (
          slot[1].length === 0 && isAce(card) ||
          slot[1].length > 0 && dragcards.length === 1 && isRanked(card, slot)
        ) {
          draginto(slot);
          game.sol();
          return;
        }
      } else if (area(pos+3, 0)) {
        intersected_slots.push(slot);
      }
    }

    // Drag card to Foundation
    if (intersected_slots.length) {
      for (const slot of intersected_slots){
        let dragcards = 'draw' in dragcard ? dragcard.slot[1].slice(dragcard.draw) : [dragcard.slot[1][draw.draw]];
        let card = dragcards.at(-1);
        if (
          slot[1].length === 0 && isAce(card) ||
          slot[1].length > 0 && dragcards.length === 1 && isRanked(card, slot)
        ) {
          draginto(slot);
          game.sol();
          return;
        }
      }
    }
    intersected_slots = [];

    // Collect intersected slots of Stack
    for (const pos of Array.from({ length: tableau_slots + cheat_slots }).keys()) {
      const slot = slots[pos+5];
      if (area(pos, 1, 0, gap.dn * slot[0].length + gap.up * (slot[1].length - 1))) {
        intersected_slots.push(slot);
        if (!cheat) {
          if (pos > 6) {
            cheat = 3;
          } else if ('draw' in dragcard && slot[0].length === 0 && dragcard.slot[0].length === 0) {
            cheat = 2;
          } else {
            cheat = 1;
          }
        }
      }
    }

    // Drag card to Stack
    if (intersected_slots.length) {
      const card = dragcard.slot[1]['draw' in dragcard ? dragcard.draw : draw.draw];
      for (const slot of intersected_slots) {
        if (!slot[1].length) {
          if (isKing(card) || cheat > 1 && !(dragcard.draw)) {
            if (!allow_cheat && cheat === 3) {
              allow_cheat = true;
              speaker("These are cheat slots, drag the card again to cheat, just remember this will deviate the original experience.\n\nCan only take highest face-up card or top card from stockpile.");
              rubberband();
              break;
            } else {
              draginto(slot);
              game.sol();
              fastclick = performance.now();
              return;
            }
          } else {
            rubberband();
          };
        } else if (isRankedAlt(card, slot)) {
          draginto(slot);
          game.sol();
          fastclick = performance.now();
          return;
        } else {
          rubberband();
        };
      }
    } else {
      rubberband();
    }
  } else if (task.freecell && dragcard) {
    let intersected_slots = [];

    // Collect intersected slots of Home Cell
    for (const pos of Array.from({ length: 4 }).keys()) {
      const slot = slots[pos+4];
      if (fastclick + 200 > performance.now()) {
        const dragcards = 'draw' in dragcard ? dragcard.slot[1].slice(dragcard.draw) : [dragcard.slot[1][draw.draw]];
        const card = dragcards.at(-1);
        if (
          !slot[1].at(-1) && isAce(card) ||
          slot[1].at(-1) && dragcards.length === 1 && isRanked(card, slot)
        ) {
          draginto(slot);
          game.freecell();
          return;
        }
      } else if (area(pos+5, 0, 0, 0, 0, 0)) {
        intersected_slots.push(slot);
      }
    }

    // Drag card to Home Cell
    if (intersected_slots.length) {
      for (const slot of intersected_slots) {
        let dragcards = 'draw' in dragcard ? dragcard.slot[1].slice(dragcard.draw) : [dragcard.slot[1][draw.draw]];
        let card = dragcards.at(-1);
        if (
          slot[1].length === 0 && isAce(card) ||
          slot[1].length > 0 && dragcards.length === 1 && isRanked(card, slot)
        ) {
          draginto(slot);
          game.freecell();
          return;
        }
      }
      //speaker("Home Cell");
    }
    intersected_slots = [];

    // Collect intersected slots of Free Cell
    for (const pos of Array.from({ length: 4 }).keys()) {
      const slot = slots[pos];
      if (area(pos, 0, 0, 0, 0, 0)) {
        intersected_slots.push(slot);
      }
    }

    // Drag card to Free Cell
    if (intersected_slots.length) {
      for (const slot of intersected_slots) {
        if (!slot[1].at(-1)) {
          let dragcards = 'draw' in dragcard ? dragcard.slot[1].slice(dragcard.draw) : [dragcard.slot[1][draw.draw]];
          if (dragcards.length === 1) {
            draginto(slot);
            game.freecell();
            return;
          } else {
            speaker("Stop!");
            rubberband();
            rubbery();
            return;
          }
        }
      }
      //speaker("Free Cell");
    }
    intersected_slots = [];

    // Collect intersected slots of Stack
    for (const pos of Array.from({ length: 8 }).keys()) {
      const slot = slots[pos+8];
      if (area(pos, 1, 0, gap.dn * slot[0].length + gap.up * (slot[1].length - 1))) {
        intersected_slots.push(slot);
      }
    }

    // Drag card to Stack
    if (intersected_slots.length) {
      const card = dragcard.slot[1]['draw' in dragcard ? dragcard.draw : draw.draw];
      for (const slot of intersected_slots){
        if (!slot[1].length) {
          draginto(slot);
          game.freecell();
          fastclick = performance.now();
          return;
        } else if (isRankedAlt(card, slot)) {
          draginto(slot);
          game.freecell();
          fastclick = performance.now();
          return;
        } else {
          rubberband();
        };
      }
    } else {
      //speaker("I voice for dialogbox! You can tell by looking at my face.");
      rubberband();
    }
  }
  rubbery();
}

function imawake() {
  if (task.freecell || task.sol || task.qix || task.glyph) {
    if (task.scr) {
      task.scr = false;

      if (task.freecell) {
        hintb.style.display = 'block';
        game.freecell();
      }

      if (task.sol) {
        hintb.style.display = 'block';
        if (!winanim) {
          game.sol();
        }
      }

      if (task.qix) {
        //desk.style.opacity = 0.5;
        desk.style.display = touch.is_touch_device ? 'inline-block' : 'none';
        busyqix = new Promise((resolve) => {
          qixupdate(resolve);
        });
        repaint.qix();
      }

      if (task.glyph) {
        //desk.style.opacity = 1;
        desk.style.display = 'inline-block';
        tailscr.style.display = 'block';
        new_glyph();
      }
    }

    clearTimeout(idlescr);
    idlescr = setTimeout(() => {
      new_screensaver();
    }, 60000);
  }
};

var crosshint, givehint;
var hints = 1;
var ZOOKd = null;
const fader = Array.from({ length: max_touches }).fill(false);
const repeatyeets = Array.from({ length: max_touches }).fill(false);

function repeatpress(tooie, down) {
  clearTimeout(repeatyeets[tooie]); // clearTimeout and clearInterval are interchangeable
  if (down) {
    repeatyeets[tooie] = setTimeout(() => {
      repeatyeets[tooie] = setInterval(() => {
        pressed(yeetCode[tooie], tooie, true);
      }, 20);
    }, 500);
  }
}

const update_pointers = (e_, callback, touchstart = false) => {
  for (const touch of e_.changedTouches) {
    for (const [index, pointer] of pointers.entries()) {
      if (
        touchstart &&
        !pointer.identifier ||
        pointer.identifier === touch.identifier
      ) {
        callback(pointer, index, touch);
        break;
      }
    }
  }
};

const FFdown = (e_) => {
  imawake();
  const tooies = [0];
  if (touch.is_touch_device) {
    tooies.length = 0;
    update_pointers(
      e_,
      (pointer, index, touch) => {
        const { identifier, pageX, pageY } = touch;
        pointer.x = pageX;
        pointer.y = pageY;
        pointer.down = true;
        pointer.identifier = identifier;
        tooies.push(index);
        cursordraw(index, true);
      },
      true,
    );
  } else {
    pointers[0].x = e_.x;
    pointers[0].y = e_.y;
    pointers[0].down = true;
  }

  for (const tooie of tooies) {
    if (e_.target.classList.contains('graphboard')) {
      graphdrawing = e_;
      graphdraw(e_);
    } else if (e_.target.classList.contains('lever')) {
      leverdrawing = e_;
      leverdraw(e_);
    } else if (e_.target.classList.contains('poppy') || e_.target.parentNode.classList.contains('poppy') || tooies.length > 1) {
      ZOOKd = true;
      if (task.sol && dragcard) {
        rubberband();
        dragcard = false;
      }
    //} else if (e_.target.id === 'keyboard') {
    //  const t = document.elementFromPoint(pointers[tooie].x, pointers[tooie].y);
    //  FFpress(tooie, t);
    } else if (e_.target.classList.contains('keyswitch')) {
      FFpress(tooie, e_.target);
    } else {
      ZOOKd = false;
      if (task.freecell || task.sol) {
        pickcard();
      }
    }
  }
}

const FFmove = (e_) => {
  clearTimeout(idlecursor);
  idlecursor = setTimeout(() => {
    canvas.style.cursor = 'none';
  }, 1500);
  canvas.style.cursor = 'default';
  imawake();

  if (e_) {
    const tooies = [0];
    if (touch.is_touch_device) {
      tooies.length = 0;
      update_pointers(
        e_,
        (pointer, index, touch) => {
          const { identifier, pageX, pageY } = touch;
          pointer.x = pageX;
          pointer.y = pageY;
          tooies.push(index);
          cursordraw(index);
        },
      );
    } else {
      pointers[0].x = e_.x;
      pointers[0].y = e_.y;
    }

    if (!touch.is_touch_device || e_.touches.length === 1) {
      e_.preventDefault();
    }

    for (tooie of tooies) {
      if (pointers[tooie].down) {
        rollkey(tooie);
      }
    }

    graphdraw(e_);
    leverdraw(e_);
  }

  if (task.freecell || task.sol && !winanim) {
    if (
      pointers[0].x > 11*9 + cardsize[0]*8 + cardsize[0]/2 - 16*scale &&
      pointers[0].x < 11*9 + cardsize[0]*8 + cardsize[0]/2 + 16*scale &&
      pointers[0].y > gap.y*1 + cardsize[1]*0 + cardsize[1]/2 - 8*scale &&
      pointers[0].y < gap.y*1 + cardsize[1]*0 + cardsize[1]/2 + 8*scale
    ) {
      if (!crosshint) {
        givehint = !givehint;
        if (givehint) {
          [hint1, hint2, hint3, hint4].slice(0, hints).map((e) => e.style.display = 'block');
          hintb.style.display = 'none';
        } else {
          hint1.style.display = 'none';
          hint2.style.display = 'none';
          hint3.style.display = 'none';
          hint4.style.display = 'none';
          hintb.style.display = 'block';
        }
        //game.sol();
      }
      clearTimeout(crosshint);
      crosshint = setTimeout(() => {
        crosshint = false;
      }, 200);
    }
  }

  if (task.freecell) {
    if (face === 2 && pointers[0].x < cardsize[0]*4*scale) {
      face = 1;
      repaint.freecell();
    } else if (face === 1 && pointers[0].x >= cardsize[0]*4*scale+62) {
      face = 2;
      repaint.freecell();
    }
  }

  if (dragcard) {
    let dragcards = 'draw' in dragcard ? dragcard.slot[1].slice(dragcard.draw) : [dragcard.slot[1][draw.draw]];
    let des = 0;

    if (task.sol) {
      game.sol();
    } else {
      game.freecell();
    }

    for (const card of dragcards){
      context.drawImage(cards[card], pointers[0].x - dragcard.dx + dragcard.x, pointers[0].y - dragcard.dy + dragcard.y + des, ...cardsize);
      des += gap.up;
    }
  }
}

const FFup = (e_) => {
  graphdrawing = false;
  leverdrawing = false;

  if (e_) {
    const tooies = [0];
    if (touch.is_touch_device) {
      tooies.length = 0;
      update_pointers(
        e_,
        (pointer, index, touch) => {
          pointer.down = false;
          pointer.identifier = false;
          tooies.push(index);
          cursordraw(index, false, true);
        },
      );
    } else {
      pointers[0].down = false;
    }

    if (!ZOOKd) {
      if (!e_.target.parentNode.classList.contains('poppy') && poppy.style.display !== 'none') {
        poppy.style.display = 'none';
      }
      if (dialogbox.style.display != 'none') {
        dialogbox.style.display = 'none';
        anger = 0;
        if (task.freecell) {
          repaint.freecell();
        }
        if (task.qix) {
          repaint.qix();
        }
      }
    }

    for (const tooie of tooies) {
      joystick[tooie] = false;
      for (const k of yeetCodes[tooie]) {
        pressed(k, tooie);
      }

      if (yeetCode[tooie] !== 'CapsLock' && yeetCode[tooie] !== 'ScrollLock') {
        pressed(yeetCode[tooie], tooie);
        repeatpress(tooie, false);
      }
      yeetCode[tooie] = 'Backspace';
      cursors[tooie].tail.style.display = 'none';
    }
    e_.preventDefault();
  }

  if (task.freecell || task.sol) {
    releasecard();
  }
}



const right_click = (e_) => {
  if (touch.is_touch_device && e_.touches.length > 1) {
    return;
  } else if (!touch.is_touch_device) {
    lockpress('CapsLock', e_.getModifierState('CapsLock'));
    lockpress('ScrollLock', e_.getModifierState('ScrollLock'));
  }

  for (const p of document.querySelectorAll('.poppywin')) {
    p.style.display = 'none';
  }
  poppy.style.display = 'block';
  const x = Math.min(
    pointers[0].x,
    document.documentElement.clientWidth - poppy.clientWidth,
  );
  const y = Math.min(
    pointers[0].y,
    document.documentElement.clientHeight - poppy.clientHeight,
  );
  poppy.style.left = Math.max(x, 0) + 'px';
  poppy.style.top = Math.max(y, 0) + 'px';

  ZOOKd = true;
  e_.preventDefault();
};

function typeOf(obj) {
  const stringified = Object.prototype.toString.call(obj);
  const type = stringified.split(' ')[1].slice(0, -1);
  return type.toLowerCase();
}

var DOMwriter = null;
var winsoln = 0;
var morescr, options, seedbox, seedboxnow, staropt, fpsopt
var pixelctrl, pixelstat, easectrl, easestat, easectrl2, easestat2;

function savestar(str, args) {
  const expires = new Date(Date.now() + 365 * 864e5).toUTCString();
  const cookiestring = JSON.stringify(args); //staroptions
  document.cookie = str + encodeURIComponent(cookiestring) + "; expires=" + expires + "; path=/; SameSite=Strict;";
  //no expiry would allow the cookie to be automatically deleted upon browser exit.
}

var graphdrawing = false;
var leverdrawing = false;

function cursordraw(tooie, start, end) {
  const pos = cursors[tooie].pos.style;
  const dot = cursors[tooie].dot.style;
  const sc = window.visualViewport.scale;

  const size = Math.ceil(3 / sc);
  const center = Math.floor(size / 2);
  const border = 1;

  if (start) {
    clearTimeout(fader[tooie]);

    pos.display = 'block';
    pos.animation = 'none';
    pos.top = pointers[tooie].y - border - center + 'px';
    pos.left = pointers[tooie].x - border - center + 'px';

    dot.display = 'block';
    dot.animation = 'none';
  }

  pos.width = size + 'px';
  pos.height = size + 'px';
  pos.boxShadow = 'inset 0 0 0 ' + border + 'px #fff';
  pos.padding = border + 'px';

  dot.top = pointers[tooie].y - center + 'px';
  dot.left = pointers[tooie].x - center + 'px';
  dot.width = size + 'px';
  dot.height = size + 'px';

  if (end) {
    pos.animation = '';
    dot.animation = '';
    fader[tooie] = setTimeout(() => {
      pos.display = 'none';
      dot.display = 'none';
    }, 900);
  }
}



function graphdraw(e) {
  if (graphdrawing) {
    const t = graphdrawing.target;
    const rect = t.getBoundingClientRect();
    const where = {
      x: Math.floor((touch.is_touch_device ? e.touches[0].clientX : e.clientX) - rect.left),
      y: Math.floor((touch.is_touch_device ? e.touches[0].clientY : e.clientY) - rect.top),
    };
    const x = Math.min(where.x - 2, 200);
    const y = Math.min(where.y - 2, 200);
    const dots = t.querySelectorAll('.dot');
    dots[0].style.left = x - 2 + 'px';
    dots[0].style.top = y - 3 + 'px';

    star.life = parseFloat((10.75 - x / 20).toFixed(2));
    star.x = (200 - y) + 1;
    star.y = Math.ceil((200 - y + 1) / star.r);
    pixelstat.innerHTML = `Pixel: ${star.x}px Life: ${star.life}s`;
  }
}

function leverdraw(e) {
  if (leverdrawing) {
    const t = leverdrawing.target;
    const rect = t.getBoundingClientRect();
    const coarse = 10;
    const where_x = Math.floor((touch.is_touch_device ? e.touches[0].clientX : e.clientX) - rect.left);
    const x = Math.min(parseInt((where_x - 1) / coarse) * coarse, 200);
    const dots = t.querySelectorAll('.dot');
    dots[0].style.left = x + 'px';

    star.accelerate = (200 - x) / 25;
    star.delay = 60 * fps.vfps;
    easestat.innerHTML = `Accelerate: ${star.accelerate}s`;
    //easestat2.innerHTML = `Ease: ${star.accelerate}s`;
  }
}

function updatestat() {
  pixelctrl.style.left = 200 - star.life * 20 + 13 + 'px';
  pixelctrl.style.top = 200 - star.x - 2 + 'px';
  pixelstat.innerHTML = `Pixel: ${star.x}px Life: ${star.life}s`;

  easectrl.style.left = 200 - star.accelerate * 25 + 'px';
  easestat.innerHTML = `Accelerate: ${star.accelerate}s`;

  //easectrl2.style.left = 200 - star.accelerate * 25 + 'px';
  //easestat2.innerHTML = `Ease: ${star.accelerate}s`;
}

var qixdb = null;
var qixsel = 0;
const qixsc = 2;
var qixmask = newCanvas();
var spoiler = newCanvas();
var spoilermask = newCanvas();
var qixmap = null;
var qixdim, qixpos, qixscr, qix_tails, qixline;
var qixsates = [];
var qixmobs = [];
var qixprojs = [];
var glyphm = newCanvas();
var glyphc = newCanvas();
var glyph_chars = 46;
var glyph_lines = 34;
var glyph_shift = 1;

var glyphimg = new Image();
glyphimg.src = 'SOL/glyph.png';
glyphimg.addEventListener('load', () => {
  glyphm.width = glyphm.canvas.width = glyphimg.width;
  glyphm.height = glyphm.canvas.height = glyphimg.height;
  glyphc.width = glyphc.canvas.width = 16 * glyph_chars;
  glyphc.height = glyphc.canvas.height = 16 * glyph_lines;

  glyphm.drawImage(glyphimg, 0, 0);
  glyphm.globalCompositeOperation = 'source-in';
  glyphm.fillStyle = '#0f0';
  glyphm.fillRect(0, 0, glyphimg.width, glyphimg.height);
});

function new_glyph(clear) {
  context.clearRect(0, 0, canvas.width, canvas.height);

  glyphscr.style.display = 'block';
  //desk.style.opacity = 1;
  desk.style.display = 'inline-block';
  if (clear) {
    editor.textContent = '';
    glyphc.clearRect(0, 0, glyphc.width, glyphc.height);
    glyph_cursor = 0;
    glyph_row = 0;
  }
}

function glyph_update(code) {
  const jump = () => {
    if (glyph_cursor >= glyph_chars - 1) {
      if (glyph_row >= glyph_lines - 1) {
        glyph_row = 0;
      } else {
        glyph_row += 1;
      }
      glyph_cursor = 0;
    } else {
      glyph_cursor += 1;
    }
  }

  if (code.startsWith('Arrow')) {
    const x = (code === 'ArrowLeft' ? -1 : 0) + (code === 'ArrowRight' ? 1 : 0);
    const y = (code === 'ArrowUp' ? -1 : 0) + (code === 'ArrowDown' ? 1 : 0);
    if (glyph_cursor + x >= 0 && glyph_cursor + x <= glyph_chars) {
      glyph_cursor += x;
    }
    if (glyph_row + y >= 0 && glyph_row + y < glyph_lines) {
      glyph_row += y;
    }
  } else if (code === 'Backspace') {
    if (glyph_cursor) {
      glyph_cursor -= 1;
    } else if (glyph_row) {
      glyph_row -= 1;
      glyph_cursor = glyph_chars;
    }

    glyphc.clearRect(16 * glyph_cursor, 16 * glyph_row, 16, 16);
  } else if (code === 'Enter') {
    editor.textContent += '\n';
    if (glyph_row >= glyph_lines - 1) {
      glyph_row = 0;
    } else {
      glyph_row += 1;
    }
    glyph_cursor = 0;
  } else if (code === 'Space') {
    editor.textContent += ' ';
    glyphc.clearRect(16 * glyph_cursor, 16 * glyph_row, 16, 16);

    jump();
  } else if (code.startsWith('Digit') && glyph_shift === 1 || code.startsWith('Key')) {
    editor.textContent += ' ';
    let charset = '0123456789';
    let des = 0;
    if (code.startsWith('Key')) {
      charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      des = 16 * glyph_shift;
    }
    const pos = 16 * charset.split('').indexOf(code.at(-1));

    glyphc.clearRect(16 * glyph_cursor, 16 * glyph_row, 16, 16);
    glyphc.drawImage(glyphm.canvas, pos, des, 16, 16, 16 * glyph_cursor, 16 * glyph_row, 16, 16);

    jump();
  } else {
    let key = vCode[code][1];
    if (key) {
      editor.textContent += key[glyph_shift-1];
      jump();
    }
  }

  const x = 16 * glyph_cursor + 7;
  const y = 16 * glyph_row + 7;

  tailscr.style.clipPath = `polygon(${x}px ${y}px,
${x+2}px ${y}px,
${x+2}px ${y+18}px,
${x}px ${y+18}px)`;
}



var mobspawner = false;
let qixzoom = 1;
let qixkeyboard = 0;
if (touch.is_touch_device) {
  qixkeyboard = canvas.width > 854 ? 200 : 180;
}

function new_qix() {
  Promise.all([busyqix]).then(() => {
    task.qix = true;
    loadcards(repaint.qix);
    busyqix = new Promise((resolve) => {
      qixupdate(resolve);
    });
  });

  anger = 0;
  qixdim = {
    x: Math.floor(qixmask.width / 2),
    y: Math.floor(qixmask.height / 2),
  }
  qixpos = {
    x: qixdim.x + 1,
    y: qixdim.y + 1,
  };
  qixscr = {
    x: qixpos.x,
    y: qixpos.y + qixkeyboard/2,
  }
  qix_tails = [];
  qixline = {
    x: 0,
    y: 0,
    d: 'x',
  };
  tailscr.style.display = 'none';

  const new_mob = (type, scr, size, c) => {
    const mob = document.createElement('DIV');
    mob.classList = c;
    mob.style.display = 'block';
    scr.appendChild(mob);

    const x = Math.round(Math.random());
    const y = Math.round(Math.random());
    const sx = Math.floor(Math.random() * 3);
    type.push({
      el: mob,
      size: size,
      pos: {
        x: Math.floor((Math.random() * qixmask.width - 2) + 2),
        y: Math.floor((Math.random() * qixmask.height - 2) + 2),
      },
      dir: {
        n: x,
        e: y,
        s: Math.abs(x-1),
        w: Math.abs(y-1),
      },
      speed: {
        x: sx,
        y: sx ? Math.floor(Math.random() * 3) : Math.ceil(Math.random() * 2),
      },
    });
  }

  while (qixsatescr.firstChild) {
    qixsatescr.lastChild.remove();
  }
  qixsatescr.style.display = 'block';
  qixsates.length = 0;

  while (qixmobscr.firstChild) {
    qixmobscr.lastChild.remove();
  }
  qixmobscr.style.display = 'block';
  qixmobs.length = 0;

  while (qixprojscr.firstChild) {
    qixprojscr.lastChild.remove();
  }
  qixprojscr.style.display = 'block';
  qixprojs.length = 0;

  Array.from({ length: 2 }, () => new_mob(qixsates, qixsatescr, 20, 'hint sate'));
  //Array.from({ length: 8 }, () => new_mob(qixprojs, qixprojscr, 6, 'hint bguncher'));

  clearInterval(mobspawner);
  mobspawner = setInterval(() => {
    if (qixmobs.length < 6) {
      if (Math.round(Math.random())) {
        new_mob(qixmobs, qixmobscr, 14, 'hint mob');
      } else {
        new_mob(qixmobs, qixmobscr, 26, 'hint ammo');
      }
      
      //echo(qixmobs.length + ' mobs ', false);
    }
  }, 2500);

  qixzoom = 1;
  qixmap = qixmask.getImageData(0, 0, qixmask.width, qixmask.height);
  for (const n of Array.from({ length: qixmap.data.length/4 }).keys()) {
    qixmap.data[n*4] = 0;
    qixmap.data[n*4+1] = 0;
    qixmap.data[n*4+2] = 0;
    qixmap.data[n*4+3] = 255;
  }

  clearSq(qixdim.x - 9, qixdim.y - 9, 19, 19);
  clearSq(qixdim.x - 8, qixdim.y - 8, 17, 17, qixdb.translucent);
  clearSq(0, 0, qixmask.width, 0);
  clearSq(0, 0, 0, qixmask.height);
  clearSq(0, qixmask.height - 1, qixmask.width, 0);
  clearSq(qixmask.width-1, 0, 0, qixmask.height);
  qixmask.putImageData(qixmap, 0, 0);

  for (const sate of qixsates) {
    draw_diamond(sate);
  }

  for (const zombie of qixmobs) {
    draw_diamond(zombie);
  }

  for (const proj of qixprojs) {
    draw_square(proj);
  }

  silhouette_update();
}

function qixscan(satellite) {
  const monstermap = new Uint8Array(qixmask.width*qixmask.height);
  let pixels = 0;
  for (const n of Array.from({ length: qixmask.width*qixmask.height }).keys()) {
    if (qixmap.data[n*4+3] === 255) {
      monstermap[n] = 1;
    } else {
      pixels++;
      monstermap[n] = 0;
    }
  }
  while (satellite.length > 0) {
    const y = satellite.pop();
    const x = satellite.pop();
    if (x >= 0 && y >= 0 && x < qixmask.width && y < qixmask.height && monstermap[y*qixmask.width + x]) {
      monstermap[y * qixmask.width + x] = 0;
      satellite.push(x + 1, y);
      satellite.push(x - 1, y);
      satellite.push(x, y + 1);
      satellite.push(x, y - 1);
    }
  }

  for (const [n, pixel] of monstermap.entries()) {
    if (pixel) {
      pixels++;
      qixmap.data[n*4+3] = qixdb.translucent;
    }
  }

  if (Math.floor((pixels/monstermap.length)*10000)/100 > 99) {
    setTimeout(() => {
      winanim = true;
      speaker('Press Q + R to restart the game.\n\nE and C to zoom in/out, Z to reset zooming.');
      qixsatescr.style.display = 'none';
      qixmobscr.style.display = 'none';
      qixprojscr.style.display = 'none';
      winsoln += 2;
      savestar('winsol=', winsoln);
      makemenu();
      repaint.qix();
    }, 0);
    clearInterval(mobspawner);
    mobspawner = false;
  }
}

function clearSq(x, y, w, h, co = 0) {
  const ww = qixmask.width;

  if (w > 0) {
    w += 1;
  } else {
    x += w;
    w = -w + 1;
  }

  if (h > 0) {
    h += 1;
  } else {
    y += h;
    h = -h + 1;
  }

  Array.from({ length: h }, (_, scanline) => {
    const scnmask = (y + scanline) * ww + x;
    Array.from({ length: w }, (_, row) => qixmap.data[(scnmask + row) * 4 + 3] = co);
  });
}

const cleared = (pow) => {
  return qixmap.data[pow * 4 + 3] !== 255;
}

function stixpath(nx, land) {
  const x = qixpos.x;
  const y = qixpos.y;

  if (!qix_tails.length) {
    if (land) {
      return;
    }
    qix_tails = [[x, y, 0, 0]];
    qixline.x = x;
    qixline.y = y;
    return;
  }

  const stix = qix_tails.at(-1);
  if (qixline.d === 'x' && qixline.x === x) {
    stix[3] = y - stix[1];
  } else if (qixline.y === y) {
    stix[2] = x - stix[0];
  } else {
    qix_tails.push([x, y, 0, 0]);
    qixline.x = x;
    qixline.y = y;
    qixline.d = nx ? 'y' : 'x';
  }
}

const securitycam = (pos) => {
  const outstanding = {
    width: Math.max(64, Math.floor(dim.x / qixsc - qixdim.x * qixzoom)),
    height: Math.max(64, Math.floor(dim.y / qixsc - qixdim.y * qixzoom)),
  }

  const left = (dim.x / qixsc - outstanding.width) / qixzoom;
  const right = (qixmask.width * qixzoom - dim.x / qixsc + outstanding.width) / qixzoom;
  if (
    pos.x > left &&
    pos.x < right
  ) {
    qixscr.x = pos.x;
  } else if (pos.x > left) {
    qixscr.x = qixmask.width - dim.x / qixsc / qixzoom + outstanding.width / qixzoom + 1;
  } else {
    qixscr.x = (dim.x / qixsc - outstanding.width) / qixzoom + 1;
  }

  const top = ((dim.y - qixkeyboard) / qixsc - outstanding.height) / qixzoom;
  const bottom = ((qixmask.height * qixzoom - (dim.y - qixkeyboard) / qixsc) + outstanding.height) / qixzoom;
  if (
    pos.y > top &&
    pos.y < bottom 
  ) {
    qixscr.y = pos.y + qixkeyboard/2/qixzoom;
  } else if (pos.y > top) {
    qixscr.y = qixmask.height - dim.y / qixsc / qixzoom + outstanding.height / qixzoom + 1 + qixkeyboard/qixzoom;
  } else {
    qixscr.y = (dim.y / qixsc - outstanding.height) / qixzoom + 1;
  }
}

function aliasedline(x0, y0, x1, y1) {
  const pixels = new Array();

  const dx = Math.abs(x1 - x0);
  const dy = Math.abs(y1 - y0);
  const sx = Math.sign(x1 - x0);
  const sy = Math.sign(y1 - y0);
  let err = dx - dy;

  pixels.push([x0, y0]);
  while (true) {
    if (x0 === x1 && y0 === y1) {
      break;
    }

    const e2 = 2 * err;
    if (e2 > -dy) {
      err -= dy;
      x0 += sx;
    }
    if (e2 < dx) {
      err += dx;
      y0 += sy;
    }
    pixels.push([x0, y0]);
  }

  return pixels;
}

function silhouette_update() {
  spoilermask.clearRect(0, 0, spoilermask.width, spoilermask.height);
  spoilermask.drawImage(qixmask.canvas, 0, 0, qixmask.width*qixsc, qixmask.height*qixsc);
  spoilermask.globalCompositeOperation = 'source-in';
  spoilermask.drawImage(silhouette, 0, 0, spoilermask.width, spoilermask.height);
  spoilermask.globalCompositeOperation = 'source-over';
}

function qix_player_movement() {
  const dir = {
    e: Keypress.KeyD || Keypress.ArrowRight,
    s: Keypress.KeyS || Keypress.ArrowDown,
    w: Keypress.KeyA || Keypress.ArrowLeft,
    n: Keypress.KeyW || Keypress.ArrowUp,
  }

  if (dir.w && face !== 1 || dir.e && face !== 2) {
    face = dir.w ? 1 : 2;
  }

  // invisible barrier    
  const landed = () => {
    if (pointers[0].hold) {
      pointers[0].hold = 0;
      if (qix_tails.length > 1 || qix_tails.length > 0 && (Math.abs(qix_tails[0][2]) > 1 || Math.abs(qix_tails[0][3]) > 1)) {
        for (const area of qix_tails) {
          clearSq(...area);
        }
        tailscr.style.display = 'none';
        const satellite = [];
        for (const sate of qixsates) {
          satellite.push(sate.pos.x, sate.pos.y);
        }
        qixscan(satellite);
        qixmask.putImageData(qixmap, 0, 0);

        silhouette_update();
        repaint.qix();
      }
      qix_tails = [];
    }
  }

  for (const frame of Array.from({ length: 120/fps.hz }).keys()) {
    const interstep = {
      x: 0,
      y: 0,
    }

    if (dir.w && !dir.e || dir.e && !dir.w) {
      for (const x of Array.from({ length: (Keypress.ShiftLeft || Keypress.ShiftRight) ? 2 : 1 }).keys()) {
        const pow = dir.w ? -x-1 : x+1;

        // death barrier
        if (qixpos.x + pow >= 0 && qixpos.x + pow <= qixmask.width) {
          interstep.x = pow;
        } else {
          break;
        }
      }
    }

    if (dir.n && !dir.s || dir.s && !dir.n) {
      for (const y of Array.from({ length: Keypress.Space ? 2 : 1 }).keys()) {
        const pow = dir.n ? -y-1 : y+1;

        // death barrier
        if (qixpos.y + pow >= 0 && qixpos.y + pow <= qixmask.height) {
          interstep.y = pow;
        } else {
          break;
        }
      }
    }

    if (interstep.x === 0 && interstep.y === 0) {
      return;
    }

    for (const [width, height] of aliasedline(0, 0, interstep.x, interstep.y)) {
      if (!width && !height) {
        continue;
      }
      const x = Math.sign(width);
      const y = Math.sign(height);
      if (winanim || cleared(qixpos.x + x + qixmask.width * (qixpos.y + y))) {
        stixpath(x, true);
        landed();
        qixpos.x += x;
        qixpos.y += y;
      } else if (pointers[0].down) {
        // on adventure
        pointers[0].hold = 1;
        stixpath(x);
        qixpos.x += x;
        qixpos.y += y;
      } else if (cleared(qixpos.x + width + qixmask.width * qixpos.y)) {
        stixpath(x, true);
        landed();
        qixpos.x += x;
      } else if (cleared(qixpos.x + qixmask.width * (qixpos.y + y))) {
        stixpath(x, true);
        landed();
        qixpos.y += y;
      } else {
        break;
      }
    }

    securitycam(qixpos);

    //if (step.x !== 0 && step.y !== 0) {
    //  step.x /= 2;
    //  step.y /= 2;
    //}
  }
  draw_tail(tailscr);
  repaint.qix();
}

// https://stackoverflow.com/questions/12219802/
function intersection(x0, y0, r0, x1, y1, r1) {
  const d = Math.hypot(...sub(x1, y1, x0, y0));
  if (d < (r0 + r1) && d > Math.abs(r0 - r1)) {
    return true;
  }
}

// https://stackoverflow.com/questions/1073336/
function intersection_line(x0, y0, x1, y1, x2, y2, r) {
  const [Ax, Ay] = sub(x2, y2, x0, y0);
  const [Bx, By] = sub(x1, y1, x0, y0);
  const [Cx, Cy] = add(...proj(Ax, Ay, Bx, By), x0, y0);
  const [Dx, Dy] = sub(Cx, Cy, x0, y0);

  const len = Math.abs(Bx) > Math.abs(By) ? Dx / Bx : Dy / By;
  if (len <= 0) {
    return Math.hypot(...sub(x2, y2, x0, y0)) < r;
  } else if (len >= 1) {
    return Math.hypot(...sub(x2, y2, x1, y1)) < r;
  } else {
    return Math.hypot(...sub(x2, y2, Cx, Cy)) < r;
  }
}

const add = (x0, y0, x1, y1) => [x0 + x1, y0 + y1];
const sub = (x0, y0, x1, y1) => [x0 - x1, y0 - y1];

const proj = (x0, y0, x1, y1) => {
  const dot = (x0, y0, x1, y1) => x0 * x1 + y0 * y1;
  const len = dot(x0, y0, x1, y1) / dot(x1, y1, x1, y1);
  return [len*x1, len*y1];
}

const gameover = () => {
  anger = 1;
  repaint.qix();
  task.qix = false;
  clearInterval(mobspawner);
  mobspawner = false;
  setTimeout(() => {
    new_qix();
  }, 250);
}

function qixmobstep(mob) {
  const r = mob.size / 4;
  const pos = mob.pos;
  const dir = mob.dir;
  const speed = Keypress.CapsLock ? {x:0, y:0} : mob.speed;
  for (const frame of Array.from({ length: 120/fps.hz }).keys()) {
    const interstep = {
      x: 0,
      y: 0,
    };

    if (dir.w && !dir.e || dir.e && !dir.w) {
      for (const x of Array.from({ length: speed.x }).keys()) {
        const pow = dir.w ? -x-1 : x+1;

        // death barrier
        if (pos.x + pow >= 0 && pos.x + pow <= qixmask.width && !cleared(pos.x + pow + qixmask.width * pos.y)) {
          interstep.x = pow;
        } else {
          const oldirE = dir.e;
          dir.e = dir.w;
          dir.w = oldirE;
          break;
        }
      }
    }

    if (dir.n && !dir.s || dir.s && !dir.n) {
      for (const y of Array.from({ length: speed.y }).keys()) {
        const pow = dir.n ? -y-1 : y+1;

        // death barrier
        if (pos.y + pow >= 0 && pos.y + pow <= qixmask.height && !cleared(pos.x + interstep.x + qixmask.width * (pos.y + pow))) {
          interstep.y = pow;
        } else {
          const oldirN = dir.n;
          dir.n = dir.s;
          dir.s = oldirN;
          break;
        }
      }
    }

    if (interstep.x === 0 && interstep.y === 0) {
      return;
    }
    pos.x += interstep.x;
    pos.y += interstep.y;

    // provoke player
    if (qix_tails.length > 0) {
      let last = null;
      for (const [x, y, width, height] of qix_tails) {
        if (!width && !height) {
          if (!last) {
            last = {
              x: x,
              y: y,
            }
          }
          continue;
        }
        if (last) {
          if (intersection_line(last.x, last.y, x, y, pos.x, pos.y, r)) {
            return true;
          }
          last = null;
        }
        if (intersection_line(x, y, x+width, y+height, pos.x, pos.y, r)) {
          return true;
        }
      }
      if (last) {
        if (intersection_line(last.x, last.y, qixpos.x, qixpos.y, pos.x, pos.y, r)) {
          return true;
        }
        last = null;
      }
    }
    if (intersection(pos.x, pos.y, r, qixpos.x, qixpos.y, 5)) {
      return true;
    }
  }
}

const corner = {
  x: 0,
  y: 0,
};

const find_corner = (width, height, x, y, last) => {
  if (0 < last.width) {
    if (0 < height) {
      corner.x = 1;
      corner.y = 0;
    } else if (height < 0) {
      corner.x = 0;
      corner.y = 0;
    }
  } else if (0 < last.height) {
    if (width < 0) {
      corner.x = 1;
      corner.y = 1;
    } else if (0 < width) {
      corner.x = 1;
      corner.y = 0;
    }
  } else if (last.width < 0) {
    if (height < 0) {
      corner.x = 0;
      corner.y = 1;
    } else if (0 < height) {
      corner.x = 1;
      corner.y = 1;
    }
  } else if (last.height < 0) {
    if (0 < width) {
      corner.x = 0;
      corner.y = 0;
    } else if (width < 0) {
      corner.x = 0;
      corner.y = 1;
    }
  } else {
    if (0 < width) {
      corner.x = 1;
      corner.y = 0;
    } else if (0 < height) {
      corner.x = 1;
      corner.y = 1;
    } else if (width < 0) {
      corner.x = 0;
      corner.y = 1;
    } else if (height < 0) {
      corner.x = 0;
      corner.y = 0;
    } else {
      if (0 > last.x - x) {
        if (0 > last.y - y) {
          corner.x = 1;
          corner.y = 0;
        } else {
          corner.x = 0;
          corner.y = 0;
        }
      } else if (last.x - x > 0) {
        if (last.y - y > 0) {
          corner.x = 0;
          corner.y = 1;
        } else {
          corner.x = 1;
          corner.y = 1;
        }
      }
      return true;
    }
    // but qix_tails.toReversed() need own implementation
    //last.x = x;
    //last.y = y;
  }
}

const clipPathTail = [];
function draw_tail(scr) {
  clipPathTail.length = 0;

  // Drawing to tail base
  let last = {
    x: 0,
    y: 0,
    width: 0,
    height: 0,
  };

  corner.x = 0;
  corner.y = 0;

  if (qix_tails.length) {
    tailscr.style.display = 'block';
    // delete this if I could have last.x and last.y from find_corner()
    last.x = qix_tails[0][0];
    last.y = qix_tails[0][1];
  } else {
    tailscr.style.display = 'none';
  }

  for (const [x, y, width, height] of qix_tails) {
    if (find_corner(width, height, x, y, last)) {
      last.x = x;
      last.y = y;
    }

    last.width = width;
    last.height = height;

    const xx = dim.x + (last.x + corner.x - qixscr.x) * qixsc;
    const yy = dim.y + (last.y + corner.y - qixscr.y) * qixsc;
    clipPathTail.push(`${xx}px ${yy}px`);

    last.x = x + width;
    last.y = y + height;
  };

  if (qix_tails.length) {
    const xx = dim.x + (last.x + corner.x - qixscr.x) * qixsc;
    const yy = dim.y + (last.y + corner.y - qixscr.y) * qixsc;
    clipPathTail.push(`${xx}px ${yy}px`);
  }

  // Tail base
  const xx = spoiler.width / 2 + dim.x - qixdim.x * qixsc + (qixpos.x - qixscr.x) * qixsc;
  const yy = spoiler.height / 2 + dim.y - qixdim.y * qixsc + (qixpos.y - qixscr.y) * qixsc;
  clipPathTail.push(`${xx}px ${yy}px`);

  // Reverse to tail end
  last = {
    x: 0,
    y: 0,
    width: 0,
    height: 0,
  }

  corner.x = 0;
  corner.y = 0;

  //echo('', false);
  for (const [x, y, width, height] of qix_tails.toReversed()) {
    if (find_corner(-width, -height, x, y, last)) {
      // buggy on diagonal
      //echo((last.x-x) + ' ' + (last.y-y) + ' ' + corner.x + ' ' + corner.y);
    }

    last.width = -width;
    last.height = -height;

    last.x = x + width;
    last.y = y + height;

    const xx = dim.x + (last.x + corner.x - qixscr.x) * qixsc;
    const yy = dim.y + (last.y + corner.y - qixscr.y) * qixsc;
    clipPathTail.push(`${xx}px ${yy}px`);
  };

  // Tail end
  if (qix_tails.length) {
    const [x, y, width, height] = qix_tails[0];
    if (0 < -width) {
      corner.x = 0;
      corner.y = 0;
    } else if (0 < -height) {
      corner.x = 1;
      corner.y = 0;
    } else if (-width < 0) {
      corner.x = 1;
      corner.y = 1;
    } else if (-height < 0) {
      corner.x = 0;
      corner.y = 1;
    }
    const xx = dim.x + (x + corner.x - qixscr.x) * qixsc;
    const yy = dim.y + (y + corner.y - qixscr.y) * qixsc;
    clipPathTail.push(`${xx}px ${yy}px`);
  }

  scr.style.clipPath = 'polygon(' + clipPathTail.join(',') + ')';
  clipPathTail.length = 0;
};

function draw_diamond(mob) {
  const pos = mob.pos;
  const size = mob.size;
  const xx = spoiler.width / 2 + dim.x - qixdim.x * qixsc + (pos.x - qixscr.x) * qixsc;
  const yy = spoiler.height / 2 + dim.y - qixdim.y * qixsc + (pos.y - qixscr.y) * qixsc;
  clipPathTail.push(`${xx}px ${yy - size}px,
${xx + size}px ${yy}px,
${xx}px ${yy + size}px,
${xx - size}px ${yy}px,
${xx}px ${yy - size}px`);

  mob.el.style.clipPath = 'polygon(' + clipPathTail.join(',') + ')';
  clipPathTail.length = 0;
}

function draw_square(mob) {
  const pos = mob.pos;
  const size = mob.size;
  const xx = spoiler.width / 2 + dim.x - qixdim.x * qixsc + (pos.x - qixscr.x) * qixsc;
  const yy = spoiler.height / 2 + dim.y - qixdim.y * qixsc + (pos.y - qixscr.y) * qixsc;
  clipPathTail.push(`${xx - size}px ${yy - size}px,
${xx + size}px ${yy - size}px,
${xx + size}px ${yy + size}px,
${xx - size}px ${yy + size}px,
${xx - size}px ${yy - size}px`);

  mob.el.style.clipPath = 'polygon(' + clipPathTail.join(',') + ')';
  clipPathTail.length = 0;
}

function qixupdate(resolve) {
  const update = () => {
    if (!task.qix) {
      return resolve(true);
    }
    if (!task.scr) {
      requestAnimationFrame(update);
    }

    if (qix_tails.length > 0 && !pointers[0].down) {
      const speed = 1;
      for (const frame of Array.from({ length: 120/fps.hz }).keys()) {
        if (qix_tails.length > 0) {
          const stix = qix_tails.at(-1);
          if (stix[2]) {
            stix[2] += stix[2] > 0 ? -speed : speed;
          } else if (stix[3]) {
            stix[3] += stix[3] > 0 ? -speed : speed;
          } else {
            qix_tails.pop();
          }
          qixpos.x = (stix[0] + stix[2]);
          qixpos.y = (stix[1] + stix[3]);
          securitycam(qixpos);
        }
      }
      if (qix_tails.length === 0) {
        pointers[0].hold = 0;
      }
      draw_tail(tailscr);
      repaint.qix();
    } else if ('WASD'.split('').some((k) => Keypress['Key' + k]) || ['Left', 'Up', 'Right', 'Down'].some((k) => Keypress['Arrow' + k])) {
      qix_player_movement();
    }

    for (const sate of qixsates) {
      if ('TFGH'.split('').some((k) => Keypress['Key' + k])) {
        sate.dir.n = Keypress.KeyT;
        sate.dir.e = Keypress.KeyH;
        sate.dir.s = Keypress.KeyG;
        sate.dir.w = Keypress.KeyF;
        sate.speed.x = 1;
        sate.speed.y = 1;
      } else {
        sate.dir.n = Math.round(Math.random());
        sate.dir.e = Math.round(Math.random());
        sate.dir.s = Math.round(Math.random());
        sate.dir.w = Math.round(Math.random());
        sate.speed.x = Math.round(Math.random() * 4);
        sate.speed.y = Math.round(Math.random() * 4);
      }

      draw_diamond(sate);

      if (qixmobstep(sate)) {
        gameover();
        return;
      }
    }

    if (!winanim) {
      for (const [n, proj] of qixprojs.entries()) {
        sate = qixsates[n % qixsates.length];
        proj.pos.x = sate.pos.x - 12 + 8*Math.floor(n/2);
        //proj.pos.y = sate.pos.y + 5 + 4*Math.floor(n/2);
        proj.pos.y = sate.pos.y;
        proj.speed.x = 0;
        proj.speed.y = 1;

        draw_square(proj);

        if (qixmobstep(proj)) {
          gameover();
          return;
        }
      }

      for (const mob of qixmobs) {
        draw_diamond(mob);
    
        if (qixmobstep(mob)) {
          gameover();
          return;
        }
      }
    } else {
      if (Keypress.KeyE || Keypress.KeyC || Keypress.KeyZ) {
        if (Keypress.KeyZ) {
          qixzoom = 1;
        } else {
          qixzoom = Keypress.KeyE ? qixzoom*1.01 : qixzoom/1.01;
        }
        securitycam(qixpos);
        repaint.qix();
      }

      if (Keypress.KeyQ && Keypress.KeyR) {
        new_qix();
      }
    }
  }
  update();
};



const neweditor = (B = '<br>', v = true) => {
  const d = document.createElement('DIV');
  d.classList = 'editor';
  d.style.display = v ? 'inline-block' : 'none';
  //d.setAttribute('contenteditable', 'plaintext-only');
  d.style.pointerEvents = 'none';
  //d.style.minHeight = '100%';
  d.spellcheck = false;
  d.innerHTML = B;
  document.body.appendChild(d);
  return d;
}

const inputcell = (B, w = '86px') => {
  const d = document.createElement('INPUT');
  d.type = 'text';
  d.style.width = w;
  d.placeholder = B;
  d.style.margin = '2px 20px';
  d.style.display = 'block';
  return d;
}

function makemenu() {
  while (poppy.firstChild) {
    poppy.lastChild.remove();
  }

  let listener = null;
  let dismissed = false;
  const tc = 'click';

  options = document.createElement('DIV');
  options.classList = 'poppy right';

  morescr = document.createElement('DIV');
  morescr.classList = 'poppy right';

  staropt = document.createElement('DIV');
  staropt.classList = 'poppy right';

  fpsopt = document.createElement('DIV');
  fpsopt.classList = 'poppy right';

  const newmenu = (name, listener, args, arrow) => {
    const e = document.createElement('DIV');
    if (name) {
      e.innerHTML = name;
      e.style.margin = '0 20px';
      listener(e, args);

      if (arrow) {
        const a = document.createElement('DIV');
        a.classList = 'poppyarrow';

        const p = document.createElement('DIV');
        p.classList = 'poppywin';

        p.append(arrow);
        a.append(p);
        e.append(a);
      }
    } else {
      e.style.borderTop = '1px solid #848484';
      e.style.borderBottom = '1px solid #fff';
    }

    return e;
  };

  const newgraph = () => {
    const e = document.createElement('DIV');
    e.classList = 'graphboard';
    touchFF(e);

    pixelctrl = document.createElement('DIV');
    pixelctrl.classList = 'dot';
    e.appendChild(pixelctrl);

    return e;
  }

  const newlever = () => {
    const e = document.createElement('DIV');
    e.classList = 'lever';
    touchFF(e);

    DOMwriter = document.createElement('DIV');
    DOMwriter.classList = 'bar';
    e.appendChild(DOMwriter);

    return e;
  }

  const unlock = (m, n, arrow) => {
    const e = document.createElement('DIV');
    e.textContent = m.join(n-winsoln);
    e.style.margin = '0 20px';
    e.style.color = '#848484';
    e.style.textShadow = '1px 1px #fff';

    e.addEventListener(tc, () => {
      speaker('You will need ' + (n-winsoln) + ' winning points to unlock this feature\n\nSolitaire (draw 1): 1 point\nSolitaire (draw 3): 4 points\nFreeCell: 2 points\nQix: 2 points');
    });

    if (arrow) {
      const a = document.createElement('DIV');
      a.classList = 'poppyarrow';
      e.append(a);
    }

    return e;
  };

  const submenu = (e) => {
    e.addEventListener('mousedown', (e_) => {
      const t = e.lastChild.lastChild;
      if (
        !e_.target.classList.contains('right') &&
        !e_.target.parentNode.classList.contains('right') &&
        !e_.target.classList.contains('left') &&
        !e_.target.parentNode.classList.contains('left') &&
        t.style.display === 'block'
      ) {
        dismissed = true;
        t.style.display = 'none';
      }
    });

    e.addEventListener(tc, () => {
      if (dismissed) {
        dismissed = false;
        return;
      }

      for (const p of document.querySelectorAll('.poppywin')) {
        p.style.display = 'none';
      }

      seedbox.value = seed;
      seedboxnow.value = seednow;

      const t = e.lastChild.lastChild;
      t.style.display = 'block';
      const where = e.getBoundingClientRect();
      const wheret = t.lastChild.getBoundingClientRect();
      const y = Math.min(
        0,
        document.documentElement.clientHeight - window.visualViewport.offsetTop - where.top - t.clientHeight,
      );
      const x = Math.min(
        0,
        document.documentElement.clientWidth - window.visualViewport.offsetLeft - where.right - t.clientWidth - 17,
      );

      t.style.top = y - 12 + 'px';
      if (x) {
        t.lastChild.classList = 'poppy left';
        t.style.left = -where.width - wheret.width - 36 + 'px';
      } else {
        t.lastChild.classList = 'poppy right';
        t.style.left = x + 'px';
      }
    });
  };

  listener = (e, arg) => {
    e.addEventListener(tc, () => {
      task.stop();
      task.sol = true;
      drawn = arg;
      loadcards(game.sol);
    });
  };

  if (!winsoln || winsoln >= 5) {
    poppy.append(newmenu('Solitaire (draw 1)', listener, 1));
  } else {
    poppy.append(unlock(['Solitaire (draw 1) (', ')'], 5));
  }

  if (winsoln >= 1) {
    poppy.append(newmenu('Solitaire (draw 3)', listener, 3));
    //poppy.append(newmenu('Solitaire (draw 5)', listener, 5));
  } else {
    poppy.append(unlock(['Solitaire (draw 3) (', ')'], 1));
    //poppy.append(unlock(['Solitaire (draw 5) (', ')'], 1));
  }

  listener = (e, arg) => {
    e.addEventListener(tc, () => {
      task.stop();
      task.freecell = true;
      //drawhint_freec();
      loadcards(game.freecell);
    });
  };

  if (winsoln >= 16) {
    poppy.append(newmenu('FreeCell', listener, 2));
  } else {
    poppy.append(unlock(['FreeCell (', ')'], 16));
  }

  if (winsoln >= 5) {
    listener = (e) => {
      e.addEventListener(tc, () => {
        winanim = false;

        task.stop();
        document.body.style.backgroundColor = '#DBE';

        if (!qixdb) {
          let promises = [];
          promises.push(new Promise(opendb('qix.json')));
          Promise.all(promises).then((resp) => {
            qixdb = JSON.parse(resp);
            silhouette.src = qixdb.gallery[qixsel].silhouette;
          }).catch((e) => {
            local_tooltip.style.display = 'inline-block';
            local_tooltip.textContent = '⚠';
            local_tooltip.dataset.tooltip = 'qix.json not found! (404 error)';
            console.log('qix.json not found! (404 error)');
            throw new Error(e);
          });
        } else {
          qixsel = (qixsel + 1) % qixdb.gallery.length;
          silhouette.src = qixdb.gallery[qixsel].silhouette;
        };
      });
    };
    poppy.append(newmenu('Qix', listener));

    listener = (e) => {
      e.addEventListener(tc, () => {
        task.stop();
        task.glyph = true;
        tailscr.style.display = 'block';
        const [x, y] = [7, 7];
        tailscr.style.clipPath = `polygon(
${x}px ${y}px,
${x + 2}px ${y}px,
${x + 2}px ${y + 18}px,
${x}px ${y + 18}px
)`;
        document.body.style.backgroundColor = '#DBE';
        new_glyph(true);
      });
    };
    poppy.append(newmenu('Glyph', listener));
    //newmenu('Chess', listener, [5, 3]);
  } else {
    poppy.append(unlock(['Qix (', ')'], 5));
    poppy.append(unlock(['Glyph (', ')'], 5));
  }

  poppy.append(newmenu('Manual', submenu, false, options));

  listener = (e) => {
    e.addEventListener(tc, () => {
      if (document.fullscreenElement) {
        document.exitFullscreen();
      } else {
        document.body.requestFullscreen();
      }
    });
  };
  options.append(newmenu('Fullscreen', listener));

  seedbox = inputcell('Load seed...', '120px');
  seedbox.addEventListener('change', () => seed = seedbox.value);
  options.append(seedbox);

  seedboxnow = inputcell('Alphanumeric seed', '120px');
  seedboxnow.addEventListener('change', () => seednow = seedboxnow.value);
  options.append(seedboxnow);

  listener = (e) => {
    e.addEventListener(tc, () => {
      speaker("I couldn't remember what I've said recently!");
    });
  };
  options.append(newmenu('Dialog history', listener));

  listener = (e) => {
    e.addEventListener(tc, () => {
      winsoln = 0;
      savestar('winsol=', winsoln);
      makemenu();
    });
  };
  options.append(newmenu('Reset', listener));

  poppy.append(newmenu());

  // screensaver
  listener = (e, args) => {
    e.addEventListener(tc, () => {
      task.stop();
      change_stars(args);

      if (pixelctrl) {
        updatestat();
      }
      savestar('star=', args);
    });
  };
  poppy.append(newmenu('Flying Windows',               listener, [2,      75,   'win95.png', true,   95,  95, 1.25, 4, false, false]));

  if (winsoln >= 5) {
    poppy.append(newmenu('Starfield',                  listener, [0,      200,  false,       false,   4,   4, 1.50, 0, false, false]));
  } else {
    poppy.append(unlock(['Starfield (', ')'], 5));
  }

  if (winsoln >= 24) {
    morescr.append(newmenu('Flying Windows 24-bit',    listener, [4,      75,   'win95.png', true,   95,  95, 1.25, 4, false, false]));
    morescr.append(newmenu('2000 flying Windows',      listener, [4,      2000, 'win95.png', true,   95,  95, 1.25, 4, false, false]));
    morescr.append(newmenu());
    if (winsoln >= 88) {
      morescr.append(newmenu('Star Fox',                 listener, [1,      100,  false,       false,   6,   12, 1.50, 0, false, false]));
    } else {
      morescr.append(unlock(['Star Fox (', ')'], 88))
    }
    morescr.append(newmenu('8000 colorful stars',      listener, [4,      8000, false,       false,   4,   4, 1.25, 0, false, false]));
    morescr.append(newmenu());
    morescr.append(newmenu('Surreal Xmas',             listener, ['xmas', xlight.length*160,  'light.png', true,  190, 190, 1.25, 4, "#072700", false]));
    morescr.append(newmenu('Deep nature',              listener, ['natu', xnatur.length*120,  'petal.png', true,  190, 190, 1.25, 4, "#170b00", false]));
    if (winsoln >= 124) {
      morescr.append(newmenu('Offshore',               listener, ['xott', xstrob.length*90,   'petal.png', true,  130, 130, 4, 4, "#331E66", false]));
    } else {
      morescr.append(unlock(['Offshore (', ')'], 124));
    }

    if (winsoln >= 100) {
      morescr.append(newmenu('Flying cards',           listener, ['card', 2,    false,       true, 71*2, 96*2, 1.25, 4, false, false]));
    } else {
      morescr.append(unlock(['Flying cards (', ')'], 100));
    }

    poppy.append(newmenu('More stars', submenu, false, morescr));
  } else {
    poppy.append(unlock(['More stars (', ')'], 24, true));
  }

  if (winsoln >= 16) {
    poppy.append(newmenu('Moving photo', listener, [4,      75,   'win95.png', true,   95,  95,    2, 4, false, true]));
  } else {
    poppy.append(unlock(['Moving photo (', ')'], 16));
  }

  // sol_computer
  listener = (e, arg) => {
    e.addEventListener(tc, () => {
      if (arg) {
        sol_computer = computerspeed === 0 ? true : !sol_computer;
        computerspeed = arg;
      } else {
        sol_computer = computerspeed !== 0 ? true : !sol_computer;
        computerspeed = 0;
      }

      if (task.sol) {
        game.sol();
      } else {
        task.stop();
        task.sol = true;
        drawn = 1;
        loadcards(game.sol);
      }
    });
  };
  //poppy.append(newmenu('Sol computer Solve!', listener, 30));
  //poppy.append(newmenu('Sol computer Debug', listener));

  poppy.append(newmenu());

  listener = (e, arg) => {
    e.addEventListener(tc, () => {
      if (arg) {
        scr.glide = !scr.glide;
        scr.fly = !!scr.glide;
      } else {
        scr.fly = scr.glide || !scr.fly;
        scr.glide = false;
      }
      //savestar();
    });
  };
  if (winsoln >= 32) {
    poppy.append(newmenu('Fly', listener));
  } else {
    poppy.append(unlock(['Fly (', ')'], 32));
  }

  if (winsoln >= 64) {
    poppy.append(newmenu('Glide', listener, true));

    document.addEventListener('wheel', (event) => {
      const w = -event.wheelDelta/480;
      if (star.life + w > 10.5) {
        star.life = 10.5;
      } else if (star.life + w >= 0.75) {
        star.life = parseInt((star.life + w)*4)/4;
      }
      pixelctrl.style.left = -star.life * 20 + 200 + 13 + 'px';
      pixelstat.innerHTML = `Pixel: ${star.x}px Life: ${star.life}s`;
    });

    poppy.append(newmenu('Star speed', submenu, false, staropt));

    graph = newgraph();
    staropt.appendChild(graph);

    pixelstat = document.createElement('DIV');
    staropt.appendChild(pixelstat);



    DOMwriter = newlever();
    staropt.appendChild(DOMwriter);

    easectrl = document.createElement('DIV');
    easectrl.classList = 'dot';
    DOMwriter.appendChild(easectrl);

    easestat = document.createElement('DIV');
    staropt.appendChild(easestat);



    //DOMwriter = newlever();
    //staropt.appendChild(DOMwriter);
    //
    //easectrl2 = document.createElement('DIV');
    //easectrl2.classList = 'dot';
    //DOMwriter.appendChild(easectrl2);
    //
    //easestat2 = document.createElement('DIV');
    //staropt.appendChild(easestat2);



    updatestat();

  } else {
    poppy.append(unlock(['Glide (', ')'], 64));
    poppy.append(unlock(['Star speed (', ')'], 64, true));
  }

  // paint
  listener = (e, arg) => {
    e.addEventListener(tc, () => {
      const vfps = 480/fps.vfps;
      if (scr.paint) {
        star.delay = star.delay/vfps;
      } else {
        star.delay = star.delay*vfps;
        starry(1000/(star.accelerate?vfps:480), fps.msec, fps.vfps);
      }

      if (arg === 2 && scr.paint !== 2) {
        scr.paint = 2;
        ccolor = 'rgba(0, 0, 0, 0)';
      } else if (arg === 1 && scr.paint !== 1) {
        scr.paint = 1;
        ccolor = 'rgba(0, 0, 0, 0.1)';
      } else {
        scr.paint = 0;
        ccolor = lastcolor;
      }
    });
  };
  //poppy.append(newmenu('Clear', listener, 0));
  //poppy.append(newmenu('Ghost', listener, 1));
  if (winsoln >= 88) {
    //poppy.append(newmenu('Hyperspace', listener, 1));
    poppy.append(newmenu('Hyperspace', listener, 2));
  } else {
    poppy.append(unlock(['Hyperspace (', ')'], 88));
  }

  poppy.append(newmenu());

  listener = (e) => {
    e.addEventListener(tc, () => {
      fps.display = !fps.display;
      result.style.display = fps.display ? 'block' : 'none';
    });
  };
  poppy.append(newmenu('Display FPS', listener));

  if (winsoln >= 16) {
    listener = (e, arg = 0) => {
      e.addEventListener(tc, () => {
        if (arg) {
          fps.throttle = true;
          fps.vfps = arg;
          fps.msec = 1000 / arg;
        } else {
          fps.throttle = false;
          fps.vfps = fps.hz;
          fps.msec = 1000 / fps.hz;
        }
        scrTime = performance.now();
        star.delay = 60 * fps.vfps;
        frameCount = 0;
        savestar('vfps=', arg);
      });
    };
    fpsopt.append(newmenu('2.5 FPS', listener, 2.5));
    fpsopt.append(newmenu('5 FPS', listener, 5));
    fpsopt.append(newmenu('10 FPS', listener, 10));
    fpsopt.append(newmenu('15 FPS', listener, 15));
    fpsopt.append(newmenu('20 FPS', listener, 20));
    fpsopt.append(newmenu('30 FPS', listener, 30));
    fpsopt.append(newmenu('60 FPS', listener, 60));
    fpsopt.append(newmenu('FPS = Hz', listener));
    poppy.append(newmenu('Frame rate', submenu, false, fpsopt));
  } else {
    poppy.append(unlock(['Frame rate (', ')'], 16, true));
  }
}

var glyph_cursor = 0;
var glyph_row = 0;
function pressed(code, tooie = 0, down) {
  if (KeypressX[code]) {
    //console.log(code, down ? 'down' : 'up', 'registered to', KeypressX[code].childNodes[0].innerHTML);
  } else {
    console.log(code, down ? 'down' : 'up', 'registered to', null);
    return;
  }

  if (down) {
    imawake();
    const cl = joystick[tooie] ? 'joystick' : 'pressed';
    KeypressX[code].childNodes[0].childNodes[0].classList.add(cl);
    KeypressX[code].childNodes[0].classList.add(cl);
    Keypress[code] = true;

    // glyph stuff

    if (['ShiftLeft', 'ShiftRight', 'CapsLock'].includes(code)) {
      glyph_shift = 2;
    } else if (task.glyph && code) {
      glyph_update(code);
    }
  } else {
    KeypressX[code].childNodes[0].childNodes[0].classList.remove('pressed', 'joystick');
    KeypressX[code].childNodes[0].classList.remove('pressed', 'joystick');
    Keypress[code] = false;

    // glyph stuff
    if (['ShiftLeft', 'ShiftRight', 'CapsLock'].includes(code)) {
      glyph_shift = 1;
    }
  }
}

function lockpress(code, down) {
  if (down) {
    pressed(code, 0, true);
  } else {
    pressed(code);
  }
}

function FFpress(tooie, t) {
  yeetdim[tooie] = t.getBoundingClientRect();
  yeetCode[tooie] = t.dataset.code;

  if (wasd.some((k) => k === yeetCode[tooie])) {
    joystick[tooie] = wasd;
    yeetCodes[tooie].push(yeetCode[tooie]);
  } else if (tfgh.some((k) => k === yeetCode[tooie])) {
    joystick[tooie] = tfgh;
    yeetCodes[tooie].push(yeetCode[tooie]);
  } else if (arrowks.some((k) => k === yeetCode[tooie])) {
    joystick[tooie] = arrowks;
    yeetCodes[tooie].push(yeetCode[tooie]);
  } else {
    joystick[tooie] = false;
  }

  if (joystick[tooie]) {
    const where = KeypressX[joystick[tooie][0]].getBoundingClientRect();
    deadzone[tooie] = {
      x: Math.floor(where.left + where.width / 2),
      y: Math.floor(where.bottom),
    }
    if (touch.is_touch_device) {
      deadzone[tooie].x += window.visualViewport.offsetLeft;
      deadzone[tooie].y += window.visualViewport.offsetTop;
    }
    pointers[tooie].x = deadzone[tooie].x;
    pointers[tooie].y = deadzone[tooie].y;
  }
  if (yeetCode[tooie] === 'CapsLock') {
    lockpress(yeetCode[tooie], !Keypress['CapsLock']);
  } else if (yeetCode[tooie] === 'ScrollLock') {
    lockpress(yeetCode[tooie], !Keypress['ScrollLock']);
  } else {
    pressed(yeetCode[tooie], tooie, true);
    repeatpress(tooie, true);
  }
}

function FFkeydown(e) {
  const { code } = e;
  if (['F3', 'F5', 'F7', 'Quote', 'Slash', 'Tab'].some((c) => c === code)) {
    e.preventDefault();
  }
  if (code === 'CapsLock') {
    lockpress('CapsLock', e.getModifierState('CapsLock'));
  } else if (code === 'ScrollLock') {
    lockpress('ScrollLock', e.getModifierState('ScrollLock'));
  } else {
    pressed(code, 0, true);
  }
}

function FFkeyup(e) {
  const { code } = e;
  if (['F3', 'F5', 'F7', 'Quote', 'Slash', 'Tab'].some((c) => c === code)) {
    e.preventDefault();
  }
  if (code !== 'CapsLock' && code !== 'ScrollLock') {
    pressed(code);
  }
}

const vCode = {
  AltLeft: ['Alt', null],
  AltRight: ['Alt', null],
  BracketLeft: ['[ {', '[{', true],
  BracketRight: ['] }', ']}', true],
  Backquote: ['` ~', '`~'],
  Backslash: ['\\ |', '\\|'],
  Backspace: ['Backspace', null],
  Calculator: ['Cal', null],
  CapsLock: ['Caps Lock', null],
  Comma: [', \<', ',\<', true],
  ControlLeft: ['Ctrl', null],
  ControlRight: ['Ctrl', null],
  ContextMenu: ['CM', null],
  Enter: ['Enter', '\n'],
  Equal: ['= +', '=+', true],
  Escape: ['Esc', null],
  Function: ['Fn', null],
  MetaLeft: ['Win', null],
  MetaRight: ['Win', null],
  Minus: ['- _', '-_', true],
  Period: ['. \>', '.\>', true],
  Quote: ['\' "', '\'"', true],
  Semicolon: ['; :', ';:', true],
  ShiftLeft: ['Shift', null],
  ShiftRight: ['Shift', null],
  Slash: ['/ ?', '/?'],
  Space: ['Space', ' '],
  Tab: ['Tab', null],

  PrintScreen: ['PrtSc', null],
  ScrollLock: ['ScrLk', null],
  Pause: ['Pause', null],

  Insert: ['Ins', null],
  Home: ['Home', null],
  PageUp: ['PgUp', null],

  Delete: ['Del', null],
  End: ['End', null],
  PageDown: ['PgDn', null],

  VolumeMute: ['Mute', null],
  VolumeUp: ['Inc', null],
  VolumeDown: ['Dec', null],

  NumLock: ['Num', null],
  NumpadDecimal: ['.', '.'],
  NumpadDivide: ['/', '/'],
  NumpadMultiply: ['*', '*'],
  NumpadSubtract: ['-', '-'],
  NumpadAdd: ['+', '+'],
  NumpadEnter: ['Enter', '\n'],
};

for (const k of ['F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10', 'F11', 'F12']) {
  vCode[k] = [k, null];
}

for (const [n, k] of ['0 )', '1 !', '2 @', '3 #', '4 $', '5 %', '6 ^', '7 &', '8 *', '9 ('].entries()) {
  vCode['Digit' + n] = [k, k.replace(/ +/, '')];
}

for (const k of 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('')) {
  vCode['Key' + k] = [k, k];
}

Array.from({ length: 10 }, (_, n) => vCode['Numpad' + n] = [''+n, ''+n]);

for (const [n, k] of '←↑→↓'.split('').entries()) {
  vCode['Arrow' + ['Left', 'Up', 'Right', 'Down'][n]] = [k, null];
}

const Keypress = Object.fromEntries(Object.keys(vCode).map((k) => [k, false]));
const KeypressX = {};
const yeetdim = Array.from({ length: max_touches});
const yeetCode = Array.from({ length: max_touches}).fill('Backspace');
const joystick = Array.from({ length: max_touches}).fill(false);
const yeetCodes = Array.from({ length: max_touches}).fill([]);
const deadzone = Array.from({ length: max_touches}).map(() => {
  return { x: 0, y: 0 };
});

const wasd = ['KeyW', 'KeyA', 'KeyS', 'KeyD'];
const tfgh = ['KeyT', 'KeyF', 'KeyG', 'KeyH'];
const arrowks = ['ArrowUp', 'ArrowLeft', 'ArrowDown', 'ArrowRight'];

function joystick_move(tooie) {
  const x = pointers[tooie].x - deadzone[tooie].x;
  const y = pointers[tooie].y - deadzone[tooie].y;

  cursors[tooie].tail.style.display = 'inline-block';
  drawhint_line(cursors[tooie].tail, deadzone[tooie].x, deadzone[tooie].y, pointers[tooie].x, pointers[tooie].y);

  const ks = [];
  if (Math.abs(x) > Math.abs(y)*2) {
    //horizontal
    if (x > 0) {
      ks.push(joystick[tooie][3]);
    } else {
      ks.push(joystick[tooie][1]);
    }
  } else if (Math.abs(x)*2 > Math.abs(y)) {
    //diagonal
    if (x > 0) {
      if (y > 0) {
        ks.push(joystick[tooie][2]);
        ks.push(joystick[tooie][3]);
      } else {
        ks.push(joystick[tooie][0]);
        ks.push(joystick[tooie][3]);
      }
    } else {
      if (y > 0) {
        ks.push(joystick[tooie][2]);
        ks.push(joystick[tooie][1]);
      } else {
        ks.push(joystick[tooie][0]);
        ks.push(joystick[tooie][1]);
      }
    }
  } else {
    //vertical
    if (y > 0) {
      ks.push(joystick[tooie][2]);
    } else {
      ks.push(joystick[tooie][0]);
    }
  }

  if (
    yeetCodes[tooie].length !== ks.length ||
    yeetCodes[tooie].some((ele, idx) => ele !== ks[idx])
  ) {
    for (const k of yeetCodes[tooie]) {
      if (!ks.includes(k)) {
        pressed(k, tooie);
      } else {
        yeetCode[tooie] = k;
      }
    }
    yeetCodes[tooie] = ks;
    for (const k of ks) {
      if (!Keypress[k]) {
        yeetCode[tooie] = k;
        pressed(yeetCode[tooie], tooie, true);
      }
    }
    repeatpress(tooie, true);
  }
}

function rollkey(tooie) {
  if (joystick[tooie]) {
    joystick_move(tooie);
  }

  const t = document.elementFromPoint(pointers[tooie].x - window.visualViewport.offsetLeft, pointers[tooie].y - window.visualViewport.offsetTop);
  if (!t) {
    return;
  }
  const newCode = t.dataset.code;

  if (!newCode || joystick[tooie] || newCode === 'CapsLock' || newCode === 'ScrollLock') {
    return;
  }

  const rect = t.getBoundingClientRect();
  if (Keypress[yeetCode[tooie]]) {
    if (
      pointers[tooie].x <= Math.floor(yeetdim[tooie].left) ||
      pointers[tooie].x >= Math.floor(yeetdim[tooie].right) ||
      pointers[tooie].y <= Math.floor(yeetdim[tooie].top) ||
      pointers[tooie].y >= Math.floor(yeetdim[tooie].bottom)
    ) {
      // come here if you see stuck keypresses
      pressed(yeetCode[tooie], tooie);
    }
  }
  if (!Keypress[newCode]) {
    yeetdim[tooie] = rect;
    yeetCode[tooie] = newCode;
    pressed(yeetCode[tooie], tooie, true);
    repeatpress(tooie, true);
  }
}

const poppyFF = (e_, dragscroll) => {
  e_.addEventListener('touchstart', (e) => {
    FFdown(e);

    touch.x = e.touches[0].pageX;
    touch.y = e.touches[0].pageY;

    if (touch.long_press_callback) {
      clearTimeout(touch.long_press_callback);
      touch.long_press_callback = null;
    } else {
      touch.long_press_callback = setTimeout(() => {
        right_click(e);
      }, 500);
    }
  });
  e_.addEventListener('touchmove', (e) => {
    if (!dragscroll) {
      FFmove(e);
    }

    touch.x = e.touches[0].pageX;
    touch.y = e.touches[0].pageY;

    clearTimeout(touch.long_press_callback);
    touch.long_press_callback = null;
  });
  e_.addEventListener('touchend', (e) => {
    FFup(e);

    clearTimeout(touch.long_press_callback);
    touch.long_press_callback = null;
  });
  e_.addEventListener('touchcancel', (e) => {
    FFup(e);

    clearTimeout(touch.long_press_callback);
    touch.long_press_callback = null;
  });
  e_.addEventListener('contextmenu', (e) => {
    e.preventDefault();
  });
};

function touchFF(e_) {
  e_.addEventListener('touchstart', (e) => {
    FFdown(e);
  });
  e_.addEventListener('touchmove', (e) => {
    e.preventDefault();
    FFmove(e);
  });
  e_.addEventListener('touchend', (e) => {
    FFup(e);
  });
  e_.addEventListener('touchcancel', (e) => {
    FFup(e);
  });
}

function drawkeyboard(socket, codes, c = 'keycap', w = 56, logo) {
  for (const code of codes) {
    const cap = document.createElement('DIV');
    cap.textContent = vCode[code][0];
    cap.classList = 'face';
    if (logo) {
      cap.classList.add('windo')
    }

    const keycap = document.createElement('DIV');
    keycap.classList = c;
    keycap.appendChild(cap);

    const keyswitch = document.createElement('DIV');
    keyswitch.classList = 'keyswitch';
    if (w) {
      keyswitch.style.width = w + 'px';
    }
    if (vCode[code][2]) {
      keyswitch.classList.add('cripple');
    }
    keyswitch.dataset.code = code;
    KeypressX[code] = keyswitch;
    keyswitch.appendChild(keycap);

    socket.appendChild(keyswitch);
  }
}

function windo(win) {
  const mask = newCanvas(95, 95);
  mask.fillStyle = '#445';
  mask.drawImage(win, 0, 0);
  mask.globalCompositeOperation = 'source-in';
  mask.fillRect(0, 0, 95, 95);
 
  let promise = new Promise(canvasToAB(mask.canvas, 'png'))
  promise.then(function(arri){
    const a = ABtoAB(arri);
    const wind = document.getElementsByClassName('windo');
    for (const win of wind) {
      const img = document.createElement('IMG');
      img.style.height = '10px';
      //img.style.imageRendering = "pixelated";
      img.src = ABtoURL(a);
      win.innerHTML = img.outerHTML;
    }
  })
};

var esc, f1, f5, f9, alphakeys, homekeys2, homekeys, arrows, numpad2, numpad;

function createkeyboard() {
  if (touch.is_touch_device) {
    touchFF(keyboard);
  }
  const keydiv = (sockets, left, w, v = 'var(--small)') => {
    const d = document.createElement('DIV');
    d.style.display = v;
    d.classList = 'keydiv';

    if (left) {
      d.style.marginLeft = left + 'px';
    }

    for (const s of sockets) {
      if (s) {
        d.appendChild(s);
      } else {
        const x = document.createElement('DIV');
        d.appendChild(x);
      }
    }

    if (w) {
      d.style.maxWidth = w;
      d.style.width = '100%';
    }

    return d;
  }

  const keysocket = (right, top, w) => {
    const d = document.createElement('DIV');
    d.classList = 'keysocket';

    if (right) {
      d.style.marginRight = right + 'px';
    }

    if (top) {
      d.style.marginTop = top + 'px';
    }

    if (w) {
      d.style.width = w;
    }
    return d;
  }



  // catastrophe viewports
  esc = keysocket(52, 0, 'calc(5% + 12px)');
  f1 = keysocket(21, 0, 'calc(32% - 46px)');
  f5 = keysocket(20, 0, 'calc(32% - 46px)');
  f9 = keysocket(0, 0, 'calc(32% - 46px)');
  alphakeys = keysocket(0, 12, 'calc(100% - 6px)');

  basekb = document.createElement('DIV');
  basekb.classList = 'keydiv';
  basekb.style.width = '838px';
  basekb.style.maxWidth = '100%';
  basekb.style.display = 'inline-block';
  keyboard.append(basekb);

  DOMwriter = keydiv([esc, f1, f5, f9, null], 0, '838px', 'var(--med)');
  DOMwriter.style.paddingBottom = '12px';
  basekb.append(DOMwriter);

  alphakeys = keysocket(0, 0, 'calc(100% - 6px)');
  basekb.append(keydiv([alphakeys], 0, '838px'));

  DOMwriter = document.createElement('DIV');
  DOMwriter.classList = 'keysocketrow';
  esc.appendChild(DOMwriter);
  drawkeyboard(DOMwriter, ['Escape'], 'keycap2');

  DOMwriter = document.createElement('DIV');
  DOMwriter.classList = 'keysocketrow';
  f1.appendChild(DOMwriter);
  drawkeyboard(DOMwriter, ['F1', 'F2', 'F3', 'F4']);

  DOMwriter = document.createElement('DIV');
  DOMwriter.classList = 'keysocketrow';
  f5.appendChild(DOMwriter);
  drawkeyboard(DOMwriter, ['F5', 'F6', 'F7', 'F8'], 'keycap2');

  DOMwriter = document.createElement('DIV');
  DOMwriter.classList = 'keysocketrow';
  f9.appendChild(DOMwriter);
  drawkeyboard(DOMwriter, ['F9', 'F10', 'F11', 'F12']);

  DOMwriter = document.createElement('DIV');
  DOMwriter.classList = 'keysocketrow';
  alphakeys.appendChild(DOMwriter);

  let keys = Array.from({ length: 9 }, (_, n) => 'Digit' + (n + 1));
  drawkeyboard(DOMwriter, ['Backquote', ...keys, 'Digit0', 'Minus', 'Equal']);
  drawkeyboard(DOMwriter, ['Backspace'], 'keycap2', 113);

  DOMwriter = document.createElement('DIV');
  DOMwriter.classList = 'keysocketrow';
  alphakeys.appendChild(DOMwriter);

  keys = [...'QWERTYUIOP'].map((k) => 'Key' + k);
  drawkeyboard(DOMwriter, ['Tab'], 'keycap2', 83);
  drawkeyboard(DOMwriter, [...keys, 'BracketLeft', 'BracketRight']);
  drawkeyboard(DOMwriter, ['Backslash'], 'keycap', 84);

  DOMwriter = document.createElement('DIV');
  DOMwriter.classList = 'keysocketrow';
  alphakeys.appendChild(DOMwriter);

  keys = [...'ASDFGHJKL'].map((k) => 'Key' + k);
  drawkeyboard(DOMwriter, ['CapsLock'], 'keycap2', 93);
  drawkeyboard(DOMwriter, [...keys, 'Semicolon', 'Quote']);
  drawkeyboard(DOMwriter, ['Enter'], 'keycap2', 125);

  DOMwriter = document.createElement('DIV');
  DOMwriter.classList = 'keysocketrow';
  alphakeys.appendChild(DOMwriter);

  keys = [...'ZXCVBNM'].map((k) => 'Key' + k);
  drawkeyboard(DOMwriter, ['ShiftLeft'], 'keycap2', 120);
  drawkeyboard(DOMwriter, [...keys, 'Comma', 'Period', 'Slash']);
  drawkeyboard(DOMwriter, ['ShiftRight'], 'keycap2', 149);

  DOMwriter = document.createElement('DIV');
  DOMwriter.classList = 'keysocketrow';
  alphakeys.appendChild(DOMwriter);

  drawkeyboard(DOMwriter, ['ControlLeft'], 'keycap2', 68);
  drawkeyboard(DOMwriter, ['MetaLeft'], 'keycap2', 68, true);
  drawkeyboard(DOMwriter, ['AltLeft'], 'keycap2', 68);
  drawkeyboard(DOMwriter, ['Space'], 'keycap', 351);
  drawkeyboard(DOMwriter, ['AltRight'], 'keycap2', 68);
  drawkeyboard(DOMwriter, ['MetaRight'], 'keycap2', 68,true);
  drawkeyboard(DOMwriter, ['Function'], 'keycap2', 68);
  drawkeyboard(DOMwriter, ['ControlRight'], 'keycap2', 68);


  // TKL for small viewports
  homekeys2 = keysocket(0, 0, 'calc(100% - 6px)');
  homekeys = keysocket(0, 12, 'calc(100% - 6px)');
  arrows = keysocket(0, 49, 'calc(100% - 6px)');
  DOMwriter = keydiv([homekeys2, null, homekeys, null, arrows], 6, '172px', 'var(--med)');
  keyboard.append(DOMwriter);


  DOMwriter = document.createElement('DIV');
  DOMwriter.classList = 'keysocketrow';
  homekeys2.appendChild(DOMwriter);

  drawkeyboard(DOMwriter, ['PrintScreen', 'ScrollLock', 'Pause'], 'keycap2');



  DOMwriter = document.createElement('DIV');
  DOMwriter.classList = 'keysocketrow';
  homekeys.appendChild(DOMwriter);

  drawkeyboard(DOMwriter, ['Insert', 'Home', 'PageUp'], 'keycap2');

  DOMwriter = document.createElement('DIV');
  DOMwriter.classList = 'keysocketrow';
  homekeys.appendChild(DOMwriter);

  drawkeyboard(DOMwriter, ['Delete', 'End', 'PageDown'], 'keycap2');


  DOMwriter = document.createElement('DIV');
  DOMwriter.classList = 'keysocketrow';
  arrows.appendChild(DOMwriter);

  let plate = document.createElement('DIV');
  plate.innerHTML = '&nbsp;';
  plate.classList = 'plate right';
  DOMwriter.appendChild(plate);

  drawkeyboard(DOMwriter, ['ArrowUp'], 'keycap2');

  plate = document.createElement('DIV');
  plate.innerHTML = '&nbsp;';
  plate.classList = 'plate left';
  DOMwriter.appendChild(plate);



  DOMwriter = document.createElement('DIV');
  DOMwriter.classList = 'keysocketrow';
  arrows.appendChild(DOMwriter);

  drawkeyboard(DOMwriter, ['ArrowLeft', 'ArrowDown', 'ArrowRight'], 'keycap2');



  // Shamefur dispray arr keys for unrestricted viewports
  numpad2 = keysocket(0, 0, 'calc(100% - 6px)');
  numpad = keysocket(0, 12, 'calc(100% - 6px)');
  DOMwriter = keydiv([numpad2, null, numpad], 6, '231px', 'var(--large)');
  keyboard.append(DOMwriter);

  DOMwriter = document.createElement('DIV');
  DOMwriter.classList = 'keysocketrow';
  numpad2.appendChild(DOMwriter);

  drawkeyboard(DOMwriter, ['Calculator', 'VolumeMute', 'VolumeDown', 'VolumeUp'], 'keycap2');

  DOMwriter = document.createElement('DIV');
  DOMwriter.classList = 'keysocketrow';
  numpad.appendChild(DOMwriter);

  drawkeyboard(DOMwriter, ['NumLock', 'NumpadDivide', 'NumpadMultiply', 'NumpadSubtract'], 'keycap2');

  drawkeyboard(numpad, ['NumpadAdd'], 'keycap2');
  let key = KeypressX['NumpadAdd'];
  key.childNodes[0].childNodes[0].style.height = '92px';
  key.style.float = 'right';

  DOMwriter = document.createElement('DIV');
  DOMwriter.classList = 'keysocketrow';
  numpad.appendChild(DOMwriter);

  drawkeyboard(DOMwriter, ['Numpad7', 'Numpad8', 'Numpad9']);

  DOMwriter = document.createElement('DIV');
  DOMwriter.classList = 'keysocketrow';
  numpad.appendChild(DOMwriter);

  drawkeyboard(DOMwriter, ['Numpad4', 'Numpad5', 'Numpad6']);

  drawkeyboard(numpad, ['NumpadEnter'], 'keycap2');
  key = KeypressX['NumpadEnter'];
  key.childNodes[0].childNodes[0].style.height = '92px';
  key.style.float = 'right';

  DOMwriter = document.createElement('DIV');
  DOMwriter.classList = 'keysocketrow';
  numpad.appendChild(DOMwriter);

  drawkeyboard(DOMwriter, ['Numpad1', 'Numpad2', 'Numpad3']);

  DOMwriter = document.createElement('DIV');
  DOMwriter.classList = 'keysocketrow';
  numpad.appendChild(DOMwriter);

  drawkeyboard(DOMwriter, ['Numpad0'], 'keycap', 113);
  drawkeyboard(DOMwriter, ['NumpadDecimal']);
}

function resize() {
  canvas.width = document.documentElement.clientWidth;
  canvas.height = document.documentElement.clientHeight;
  context.imageSmoothingEnabled = false;
  dim.x = Math.floor(canvas.width/2)
  dim.y = Math.floor(canvas.height/2);
  scr.friction.x = Math.ceil(canvas.width/canvas.height);
  scr.friction.y = Math.ceil(canvas.height/canvas.width);
  if (touch.is_touch_device) {
    qixkeyboard = canvas.width > 854 ? 200 : 180;
  }

  if (task.sol && !winanim) {
    repaint.sol();
  } else if (task.freecell) {
    repaint.freecell();
  } else if (task.qix) {
    repaint.qix();
  }
}

var cursors;
window.addEventListener('load', () => {
  opencss('starfield.css');
  result.style.display = fps.display ? 'block' : 'none';
  document.title = 'Starfield';

  cursors = Array.from({ length: max_touches }).map(() => {
    const pos = document.createElement('DIV');
    pos.classList = 'touchloc';
    document.body.appendChild(pos);

    const dot = document.createElement('DIV');
    dot.classList = 'touchloc_dot';
    document.body.appendChild(dot);

    DOMwriter = document.createElement('DIV');
    DOMwriter.classList = 'hintscreen';
    document.body.appendChild(DOMwriter);

    const tail = document.createElement('DIV');
    tail.classList = 'hint tail';
    DOMwriter.appendChild(tail);

    return { pos, dot, tail };
  });

  editor = neweditor();

  createkeyboard();

  if (touch.is_touch_device) {
    poppyFF(canvas);
    poppyFF(rescue, true);
    poppy.addEventListener('touchstart', (e_) => {
      if (e_.touches.length > 1) {
        ZOOKd = true;
      }
    });
  } else {
    document.addEventListener('mousedown', FFdown);
    document.addEventListener('mouseup', FFup);
    document.addEventListener('mousemove', FFmove);
    document.addEventListener('contextmenu', (e_) => {
      right_click(e_);
    });
  }

  //let e = document.createElement("DIV");
  //e.innerHTML = '&times;';
  //e.style.cursor = 'pointer';
  //e.style.fontSize = '30px';
  //e.addEventListener('click', () => {
  //  poppy.style.display = 'none';
  //});
  //poppy.appendChild(e);

  const glyphscr = document.createElement('DIV');
  glyphscr.id = 'glyphscr';
  document.body.appendChild(glyphscr);
  glyphscr.appendChild(glyphc.canvas);

  const cookies = document.cookie.split(';');
  let starcookie = false;
  for (const cookie of cookies) {
    const ck = cookie.trimStart();
    if (ck.indexOf('winsol=') === 0) {
      winsoln = parseInt(decodeURIComponent(ck.substring('winsol='.length, ck.length)));
    }

    if (ck.indexOf('star=') === 0) {
      const str = decodeURIComponent(ck.substring('star='.length, ck.length));
      try {
        change_stars(JSON.parse(str));
        starcookie = true;
      } catch (e) {
        echo('Corrupted cookie string, please choose a star and refresh the page');
      };
    }

    if (ck.indexOf('vfps=') === 0) {
      vfps = parseFloat(decodeURIComponent(ck.substring('vfps='.length, ck.length)));
      if (vfps) {
        fps.throttle = true;
        fps.vfps = vfps;
        fps.msec = 1000 / vfps;
      } else {
        fps.throttle = false;
        fps.vfps = fps.hz;
        fps.msec = 1000 / fps.hz;
      }
    }
  }

  if (!winsoln) {
    if (touch.is_touch_device) {
      speaker('Long press for star options');
    } else {
      speaker('Right-click for star options');
    }
  }

  if (!starcookie) {
    alpha.src = 'win95.png';
  }

  makemenu();

  document.addEventListener('keydown', FFkeydown);
  document.addEventListener('keyup', FFkeyup);
  addEventListener('scroll', () => {
    if (touch.is_touch_device) {
      rescue.style.bottom = document.documentElement.clientHeight - window.visualViewport.offsetTop - 90 + 'px';
      rescue.style.left = window.visualViewport.offsetLeft + 40 + 'px';
      rescue.style.height = 5*5/window.visualViewport.scale + 'px';
      rescue.style.width = 5*5/window.visualViewport.scale + 2 + 'px';

      result.style.bottom = document.documentElement.clientHeight - window.visualViewport.offsetTop - 30 + 'px';
    }
  });
  addEventListener('resize', () => {
    if (winanim) {
      resize_flag = true;
    } else {
      resize();
    }
  });

  //addEventListener('visibilitychange', () => {
  //  frameCount = 0;
  //});

  document.body.appendChild(canvas);
  shaderscr.appendChild(shader.canvas);

  dim.x = Math.floor(canvas.width/2)
  dim.y = Math.floor(canvas.height/2);
  pointers[0].x = dim.x;
  pointers[0].y = dim.y;
  scr.friction.x = Math.ceil(canvas.width/canvas.height);
  scr.friction.y = Math.ceil(canvas.height/canvas.width);

  const close = document.getElementById('close');
  close.addEventListener('click', () => {
    dialogbox.style.display = 'none';
    anger = 0;
    if (task.freecell) {
      repaint.freecell();
    }
    if (task.qix) {
      repaint.qix();
    }
  });
});
</script>
</head>
<body>
<div id='shaderscr'></div>
<div class='hintscreen'><div class='hint tail' id='hint1'></div></div>
<div class='hintscreen'><div class='hint' id='hint2'></div></div>
<div class='hintscreen'><div class='hint' id='hint3'></div></div>
<div class='hintscreen'><div class='hint' id='hint4'></div></div>
<div class='hintscreen'><div class='hint tail' id='hintb'></div></div>
<div class='hintscreen'><div class='hint tail' id='tailscr'></div></div>
<div class='hintscreen' id='qixsatescr'></div>
<div class='hintscreen' id='qixmobscr'></div>
<div class='hintscreen' id='qixprojscr'></div>
<div id='result'></div>
<div id='stdout'>Output:</div>
<div class='poppy' id='poppy'></div>
<div id='dialogbox'><div id='close'>&times;</div><div id='dialog'></div></div>
<div id='desk'>
  <div id='rescue'><div style='position:absolute; width:14px; pointer-events: none;'>↔</div>↕</div>
  <div id='keyboard'></div>
  <div id='wristrest'>SHAMEFUL BAR</div>
</div>
</body>
</html>
